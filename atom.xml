<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eryoung2的个人博客</title>
  
  <subtitle>ErYoung2写字的地方</subtitle>
  <link href="http://eryoung2.github.io/atom.xml" rel="self"/>
  
  <link href="http://eryoung2.github.io/"/>
  <updated>2022-07-13T10:34:15.493Z</updated>
  <id>http://eryoung2.github.io/</id>
  
  <author>
    <name>ErYoung2</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s+crio+podman搭建集群</title>
    <link href="http://eryoung2.github.io/2022/07/13/k8s-crio-podman%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/"/>
    <id>http://eryoung2.github.io/2022/07/13/k8s-crio-podman%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/</id>
    <published>2022-07-13T10:26:27.000Z</published>
    <updated>2022-07-13T10:34:15.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在传统的k8s集群中，我们都是使用docker engine做为底层的容器管理软件的，而docker engine因为不是k8s亲生的解决方案，所以实际使用中会有更多的分层。之前我们也讲过，k8s为了调用docker engine，专门写了一个dockershim做为CRI，而在1.20版本的时候，k8s就宣布停止更新dockershim了，也就是说再往后的版本就不推荐使用k8s+dockershim+docker engine的方案了。</p><p>而k8s官方比较推荐的解决方案中，官方比较推荐的是cri-o或者containerd，前者是基于开放容器计划(OCI)的实现，后者是基于docker的containerd，后脱离出来进行独立开发的组件，现归属于CNCF组织。</p><h2 id="CRI-O-vs-containerd-vs-docker-daemon"><a href="#CRI-O-vs-containerd-vs-docker-daemon" class="headerlink" title="CRI-O vs containerd vs docker daemon"></a>CRI-O vs containerd vs docker daemon</h2><p>这三者有啥区别呢？</p><p>首先，cri-o是cri的实现，可以直接调用底层的runc</p><p>其次，containerd是CRI-Containerd的实现，可以调用底层的runc</p><p>而docker则需要先调用dockershim，然后调用docker，再调用containerd，最后调用底层的runc</p><p>三者区别如图：</p><p><img src="/./k8s-crio-podman%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/crio%20vs%20containd%20vs%20docker.png" alt="cri-o vs containerd vs docker"></p><h2 id="k8s-crio-podman实现"><a href="#k8s-crio-podman实现" class="headerlink" title="k8s+crio+podman实现"></a>k8s+crio+podman实现</h2><h3 id="podman安装"><a href="#podman安装" class="headerlink" title="podman安装"></a>podman安装</h3><p>可参考我前一篇文章</p><p><a href="https://www.cnblogs.com/young233/p/16439698.html">docker的平替–podman - eryoung2 - 博客园</a></p><p>三台机都需要安装podman</p><h3 id="k8s的安装"><a href="#k8s的安装" class="headerlink" title="k8s的安装"></a>k8s的安装</h3><p>可参考我另一篇文章</p><p><a href="https://www.cnblogs.com/young233/p/15119748.html">kubernetes 搭建集群 - eryoung2 - 博客园</a></p><p>三台机都需要安装kubelet&#x2F;kubeadm&#x2F;kubectl，并启动kubelet</p><h3 id="cri-o的安装"><a href="#cri-o的安装" class="headerlink" title="cri-o的安装"></a>cri-o的安装</h3><h4 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu(18.04)"></a>Ubuntu(18.04)</h4><p>1 准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modprobe overlay  # 打开overlay</span><br><span class="line">modprobe br_netfilter  # 打开netfilter</span><br><span class="line">cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf &lt;&lt;EOF #内核处理</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br><span class="line">swapoff -a #kube scheduler要求关闭swap</span><br></pre></td></tr></table></figure><p>2 安装CRI-O</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本</span></span><br><span class="line">OS=xUbuntu_18.04</span><br><span class="line">CRIO_VERSION=1.23</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加源</span></span><br><span class="line">echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot;|sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class="line">echo &quot;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$CRIO_VERSION/$OS/ /&quot;|sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$CRIO_VERSION.list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加key</span></span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$CRIO_VERSION/$OS/Release.key | sudo apt-key add -</span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">sudo apt update -y</span><br><span class="line">sudo apt install cri-o cri-o-runc cri-tools -y</span><br></pre></td></tr></table></figure><p>3 检查CRI-O</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# apt show cri-o</span><br><span class="line">Package: cri-o</span><br><span class="line">Version: 1.23.3~0</span><br><span class="line">Priority: optional</span><br><span class="line">Section: devel</span><br><span class="line">Maintainer: Peter Hunt &lt;haircommander@fedoraproject.org&gt;</span><br><span class="line">Installed-Size: 98.3 MB</span><br><span class="line">Depends: libgpgme11, libseccomp2, conmon, containers-common (&gt;= 0.1.27) | golang-github-containers-common, tzdata</span><br><span class="line">Suggests: cri-o-runc | runc (&gt;= 1.0.0), containernetworking-plugins</span><br><span class="line">Replaces: cri-o-1.19, cri-o-1.20, cri-o-1.21, cri-o-1.22</span><br><span class="line">Homepage: https://github.com/cri-o/cri-o</span><br><span class="line">Download-Size: 19.9 MB</span><br><span class="line">APT-Manual-Installed: yes</span><br><span class="line">APT-Sources: http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/1.23/xUbuntu_18.04  Packages</span><br><span class="line">Description: OCI-based implementation of Kubernetes Container Runtime Interface.</span><br><span class="line"></span><br><span class="line">N: Ignoring file &#x27;ystemctlqq&#x27; in directory &#x27;/etc/apt/sources.list.d/&#x27; as it has no filename extension</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable crio.service</span><br><span class="line">systemctl start crio.service</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# systemctl status crio</span><br><span class="line">● crio.service - Container Runtime Interface for OCI (CRI-O)</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crio.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2022-07-13 01:26:03 CST; 16h ago</span><br><span class="line">     Docs: https://github.com/cri-o/cri-o</span><br><span class="line"> Main PID: 5338 (crio)</span><br><span class="line">    Tasks: 15</span><br><span class="line">   CGroup: /system.slice/crio.service</span><br><span class="line">           └─5338 /usr/bin/crio</span><br></pre></td></tr></table></figure><p>4 使用cri-o</p><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# crictl info</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &#123;</span><br><span class="line">    &quot;conditions&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;RuntimeReady&quot;,</span><br><span class="line">        &quot;status&quot;: true,</span><br><span class="line">        &quot;reason&quot;: &quot;&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;NetworkReady&quot;,</span><br><span class="line">        &quot;status&quot;: true,</span><br><span class="line">        &quot;reason&quot;: &quot;&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# crictl images</span><br><span class="line">IMAGE                                TAG                 IMAGE ID            SIZE</span><br><span class="line">docker.io/calico/cni                 v3.23.2             a87d3f6f1b8fd       263MB</span><br><span class="line">docker.io/calico/node                v3.23.2             a3447b26d32c7       224MB</span><br><span class="line">docker.io/library/nginx              latest              41b0e86104ba6       146MB</span><br><span class="line">k8s.gcr.io/coredns/coredns           v1.8.6              a4ca41631cc7a       47MB</span><br><span class="line">k8s.gcr.io/etcd                      3.5.3-0             aebe758cef4cd       301MB</span><br><span class="line">k8s.gcr.io/kube-apiserver            v1.24.2             d3377ffb7177c       131MB</span><br><span class="line">k8s.gcr.io/kube-controller-manager   v1.24.2             34cdf99b1bb3b       121MB</span><br><span class="line">k8s.gcr.io/kube-proxy                v1.24.2             a634548d10b03       112MB</span><br><span class="line">k8s.gcr.io/kube-scheduler            v1.24.2             5d725196c1f47       52.3MB</span><br><span class="line">k8s.gcr.io/pause                     3.6                 6270bb605e12e       690kB</span><br><span class="line">k8s.gcr.io/pause                     3.7                 221177c6082a8       718kB</span><br></pre></td></tr></table></figure><h4 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos(7)"></a>Centos(7)</h4><p>1 准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VERSION=1.22</span><br><span class="line">sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/CentOS_7/devel:kubic:libcontainers:stable.repo</span><br><span class="line">sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:$&#123;VERSION&#125;.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$&#123;VERSION&#125;/CentOS_7/devel:kubic:libcontainers:stable:cri-o:$&#123;VERSION&#125;.repo</span><br></pre></td></tr></table></figure><p>2 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum install cri-o cri-tools -y</span><br></pre></td></tr></table></figure><p>3 查看cri-o版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 systemd]# rpm -qi cri-o</span><br><span class="line">Name        : cri-o</span><br><span class="line">Epoch       : 0</span><br><span class="line">Version     : 1.22.5</span><br><span class="line">Release     : 2.2.el7</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: 2022年07月13日 星期三 01时36分47秒</span><br><span class="line">Group       : Unspecified</span><br><span class="line">Size        : 236845729</span><br><span class="line">License     : ASL 2.0</span><br><span class="line">Signature   : RSA/SHA256, 2022年07月10日 星期日 12时53分28秒, Key ID 4d64390375060aa4</span><br><span class="line">Source RPM  : cri-o-1.22.5-2.2.el7.src.rpm</span><br><span class="line">Build Date  : 2022年07月10日 星期日 12时53分00秒</span><br><span class="line">Build Host  : sheep87</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Vendor      : obs://build.opensuse.org/devel:kubic</span><br><span class="line">URL         : https://github.com/cri-o/cri-o</span><br><span class="line">Summary     : Open Container Initiative-based implementation of Kubernetes Container Runtime Interface</span><br><span class="line">Description :</span><br><span class="line">Open Container Initiative-based implementation of Kubernetes Container Runtime</span><br><span class="line">Interface.</span><br></pre></td></tr></table></figure><p>4 启动cri-o</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now cri-o</span><br></pre></td></tr></table></figure><p>5 查看cri-o状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 systemd]# systemctl status crio</span><br><span class="line">● crio.service - Container Runtime Interface for OCI (CRI-O)</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crio.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2022-07-13 01:41:06 CST; 16h ago</span><br><span class="line">     Docs: https://github.com/cri-o/cri-o</span><br><span class="line"> Main PID: 24127 (crio)</span><br><span class="line">    Tasks: 15</span><br><span class="line">   Memory: 13.7M</span><br><span class="line">   CGroup: /system.slice/crio.service</span><br><span class="line">           └─24127 /usr/bin/crio</span><br></pre></td></tr></table></figure><p>三台机都安装cri-o并启动。</p><h2 id="K8S启动"><a href="#K8S启动" class="headerlink" title="K8S启动"></a>K8S启动</h2><p>在master上，跑下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address 192.168.1.150 --apiserver-bind-port 6443 --kubernetes-version 1.24.2 --pod-network-cidr 10.244.0.0/16</span><br></pre></td></tr></table></figure><p>然后等5分钟，就创建了一个k8s集群的master node。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.150:6443 --token gjxt6y.0wljlhfkjz90v12m --discovery-token-ca-cert-hash sha256:d69fc5929e442210c97ab85c05a8c2906f5819a74d5b0fa3481032d6a8f3fc07 </span><br></pre></td></tr></table></figure><p>在三台机上跑这三条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>否则会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure><h2 id="检查集群"><a href="#检查集群" class="headerlink" title="检查集群"></a>检查集群</h2><p>在以上所有内容都完成之后，我们可以看一下nodes或者pods</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# kubectl get nodes</span><br><span class="line">NAME    STATUS   ROLES           AGE    VERSION</span><br><span class="line">home    Ready    control-plane   179m   v1.24.2</span><br><span class="line">node1   Ready    &lt;none&gt;          179m   v1.24.2</span><br><span class="line">node2   Ready    &lt;none&gt;          179m   v1.24.2</span><br><span class="line">root@home:~# kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-6d4b75cb6d-4wxjh       1/1     Running   0          179m</span><br><span class="line">kube-system   coredns-6d4b75cb6d-7qxpv       1/1     Running   0          179m</span><br><span class="line">kube-system   etcd-home                      1/1     Running   2          3h</span><br><span class="line">kube-system   kube-apiserver-home            1/1     Running   2          3h</span><br><span class="line">kube-system   kube-controller-manager-home   1/1     Running   2          3h</span><br><span class="line">kube-system   kube-proxy-9w7mf               1/1     Running   0          179m</span><br><span class="line">kube-system   kube-proxy-hpw6c               1/1     Running   0          179m</span><br><span class="line">kube-system   kube-proxy-tbpr8               1/1     Running   0          179m</span><br><span class="line">kube-system   kube-scheduler-home            1/1     Running   2          3h</span><br></pre></td></tr></table></figure><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ol><li><p><a href="https://medium.com/nerd-for-tech/using-cri-o-as-container-runtime-for-kubernetes-b8ddf8326d38">Using CRI-O as container runtime for Kubernetes</a></p></li><li><p><a href="https://computingforgeeks.com/install-cri-o-container-runtime-on-ubuntu-linux/">Ubuntu安装cri-o</a></p></li><li><p><a href="https://computingforgeeks.com/install-cri-o-container-runtime-on-centos-linux/">Install CRI-O Container Runtime on CentOS 8 &#x2F; CentOS 7 | ComputingForGeeks</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在传统的k8s集群中，我们都是使用docker engine做为底层的容器管理软件的，而docker engine因为不是k8s亲生的解决方</summary>
      
    
    
    
    <category term="云原生" scheme="http://eryoung2.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="podman" scheme="http://eryoung2.github.io/tags/podman/"/>
    
    <category term="k8s" scheme="http://eryoung2.github.io/tags/k8s/"/>
    
    <category term="cri-o" scheme="http://eryoung2.github.io/tags/cri-o/"/>
    
  </entry>
  
  <entry>
    <title>ssh服务</title>
    <link href="http://eryoung2.github.io/2022/07/12/ssh%E6%9C%8D%E5%8A%A1/"/>
    <id>http://eryoung2.github.io/2022/07/12/ssh%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-07-11T18:02:11.000Z</published>
    <updated>2022-07-11T18:04:18.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念、定义："><a href="#概念、定义：" class="headerlink" title="概念、定义："></a>概念、定义：</h2><ul><li>SSH是Secure Shell Protocol的简写，由IETF网络工作小组（Network Working Group）制定。</li><li>SSH在数据传输之前，将联机数据包进行加密处理，才会发出给服务端。</li><li>SSH是unix&#x2F;linux进行远程控制或者传输文件的一种协议。</li><li>SSH包括两部分，SSH客户端和SSHD服务端。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>SSH是密文传输，较明文传输的telnet安全。</li><li>SSH是基于TCP传输协议的，所以是可靠传输。</li><li>SSH的默认端口是22，如要改变端口号，需在修改配置文件之后，加-p参数指定新端口进行ssh连接。</li></ul><h2 id="连接过程："><a href="#连接过程：" class="headerlink" title="连接过程："></a>连接过程：</h2><p>基于账户密码的连接方式：</p><ol><li>客户端用会话密钥加密用户名、认证方法、密码并将加密后的结果发至服务器端。</li><li>服务器端使用会话密钥解密得到用户名、密码，进行核对。若正确，则通过连接；若失败，则返回认证失败报文给客户端。客户端循环第一步，<br>直至达到最大连接次数，TCP连接关闭。<br>基于公钥私钥的连接方式：<ol><li>客户端使用ssh-keygen生成一对公钥和私钥。</li><li>客户端将公钥推送至服务端。ssh-copy-id -i <del>&#x2F;.ssh&#x2F;id_rsa.pub server,即将本机的公钥推送至server机的</del>&#x2F;.ssh&#x2F;authorized_keys里。</li><li>客户端用会话密钥加密用户名、认证方法、公钥并将加密后的结果发至服务器端。</li><li>服务器端进行解密后，对比此公钥是否存在于server机的~&#x2F;.ssh&#x2F;authorized_keys里。若存在，通过验证，进行下一步；若不存在，<br>则返回失败信息。</li><li>服务器端生成质询码，用客户端公钥进行一次加密，用会话密钥进行二次加密，推送给客户端。</li><li>客户端使用会话密钥进行一次解密，用公钥进行二次解密得到质询码。将质询码用会话密钥加密后重新发送给服务器端。</li><li>服务器端使用会话密钥解密后，判断是否是自己的质询码。如果是，则免密登录；若不是，则返回连接失败的信息。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念、定义：&quot;&gt;&lt;a href=&quot;#概念、定义：&quot; class=&quot;headerlink&quot; title=&quot;概念、定义：&quot;&gt;&lt;/a&gt;概念、定义：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SSH是Secure Shell Protocol的简写，由IETF网络工作小组（Network</summary>
      
    
    
    
    <category term="服务" scheme="http://eryoung2.github.io/categories/%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="ssh" scheme="http://eryoung2.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>git创建空白分支</title>
    <link href="http://eryoung2.github.io/2022/07/08/git%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BD%E5%88%86%E6%94%AF/"/>
    <id>http://eryoung2.github.io/2022/07/08/git%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BD%E5%88%86%E6%94%AF/</id>
    <published>2022-07-08T14:59:56.000Z</published>
    <updated>2022-07-08T15:00:46.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在github上创建一些新的分支，发现默认会从某一个分支拉过来成立一个新的分支，.git文件下会有前一分支的提交信息，例如head、ref、logs等。</p><p>那我们能不能创建一个新的分支，让它成为一个空白的分支，不带其他分支的head、ref、logs呢？</p><p>答案是可以的，可以使用orphan参数。</p><h2 id="git-orphan"><a href="#git-orphan" class="headerlink" title="git orphan"></a>git orphan</h2><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan branch-name</span><br></pre></td></tr></table></figure><p>首先我们在github创建一个test仓库，克隆到本地，写入一些东西进行提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) ls</span><br><span class="line">➜  test git:(master) git logs</span><br><span class="line">git：&#x27;logs&#x27; 不是一个 git 命令。参见 &#x27;git --help&#x27;。</span><br><span class="line"></span><br><span class="line">最相似的命令是</span><br><span class="line">log</span><br><span class="line">➜  test git:(master) git log</span><br><span class="line">fatal: 您的当前分支 &#x27;master&#x27; 尚无任何提交</span><br><span class="line">➜  test git:(master) echo &quot;init test&quot; &gt; test1.txt</span><br><span class="line">➜  test git:(master) ✗ git add test1.txt</span><br><span class="line">➜  test git:(master) ✗ git commit -m &quot;test1&quot;</span><br><span class="line">[master（根提交） 80674b3] test1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test1.txt</span><br><span class="line">➜  test git:(master) git push -u</span><br><span class="line">枚举对象中: 3, 完成.</span><br><span class="line">对象计数中: 100% (3/3), 完成.</span><br><span class="line">写入对象中: 100% (3/3), 216 字节 | 216.00 KiB/s, 完成.</span><br><span class="line">总共 3（差异 0），复用 0（差异 0），包复用 0</span><br><span class="line">To github.com:ErYoung2/test.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">分支 &#x27;master&#x27; 设置为跟踪来自 &#x27;origin&#x27; 的远程分支 &#x27;master&#x27;。</span><br><span class="line">➜  test git:(master) git log</span><br><span class="line">commit 80674b32438bd3bfe0de6d6183b91ea8bdfca129 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: ErYoung2 </span><br><span class="line">Date:   Fri Jul 8 22:35:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    test1</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>可以看到，我们有一条提交记录。我们创建一个新的branch，先不使用orphan参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) git branch test master</span><br><span class="line">➜  test git:(master) git checkout test</span><br><span class="line">切换到分支 &#x27;test&#x27;</span><br><span class="line">➜  test git:(test) git log</span><br><span class="line">commit 80674b32438bd3bfe0de6d6183b91ea8bdfca129 (HEAD -&gt; test, origin/master, master)</span><br><span class="line">Author: ErYoung2 </span><br><span class="line">Date:   Fri Jul 8 22:35:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    test1</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>我们再使用orphan参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(test) git checkout --orphan test2</span><br><span class="line">切换到一个新分支 &#x27;test2&#x27;</span><br><span class="line">➜  test git:(test2) ✗ git log</span><br><span class="line">fatal: 您的当前分支 &#x27;test2&#x27; 尚无任何提交</span><br></pre></td></tr></table></figure><p>就可以发现，新建的分支test2是没有提交记录的。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>这个主要两个作用：</p><ol><li><p>减少仓库数量，我们可以直接切换就好</p></li><li><p>减少新分支对于原分支的依赖，可以不受原分支.git历史文件的干扰，从而可以达到在旧仓库达到git init的效果，进而方便自己的管理。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在github上创建一些新的分支，发现默认会从某一个分支拉过来成立一个新的分支，.git文件下会有前一分支的提交信息，例如head、re</summary>
      
    
    
    
    <category term="版本控制" scheme="http://eryoung2.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="git" scheme="http://eryoung2.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>linux-dd命令</title>
    <link href="http://eryoung2.github.io/2022/07/05/linux-dd%E5%91%BD%E4%BB%A4/"/>
    <id>http://eryoung2.github.io/2022/07/05/linux-dd%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-05T09:36:57.000Z</published>
    <updated>2022-07-05T09:39:51.222Z</updated>
    
    <content type="html"><![CDATA[<p>dd命令可以轻易实现创建指定大小的文件，如：</p><p><strong><font color="red">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test bs&#x3D;1M count&#x3D;1000</font></strong></p><p>会生成一个1000M的test文件，文件内容为全0（因从&#x2F;dev&#x2F;zero中读取，&#x2F;dev&#x2F;zero为0源）。<br>但是这样为实际写入硬盘，文件产生速度取决于硬盘读写速度，如果欲产生超大文件，速度很慢。</p><p>在某种场景下，我们只想让文件系统认为存在一个超大文件在此，但是并不实际写入硬盘。<br>则可以：</p><p><strong><font color="red">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test bs&#x3D;1M count&#x3D;0 seek&#x3D;100000</font></strong></p><p>此时创建的文件在文件系统中的显示大小为100000MB，但是并不实际占用block，因此创建速度与内存速度相当。<br>seek的作用是跳过输出文件中指定大小的部分，这就达到了创建大文件，但是并不实际写入的目的。</p><p>当然，因为不实际写入硬盘，所以你在容量只有10G的硬盘上创建100G的此类文件都是可以的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dd命令可以轻易实现创建指定大小的文件，如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;dd if&amp;#x3D;&amp;#x2F;dev&amp;#x2F;zero of&amp;#x3D;test bs&amp;#x3D;1M count&amp;#x3D;1000&lt;/font&gt;&lt;/st</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>docker的平替--podman</title>
    <link href="http://eryoung2.github.io/2022/07/03/docker%E7%9A%84%E5%B9%B3%E6%9B%BF-podman/"/>
    <id>http://eryoung2.github.io/2022/07/03/docker%E7%9A%84%E5%B9%B3%E6%9B%BF-podman/</id>
    <published>2022-07-03T05:01:14.000Z</published>
    <updated>2022-07-04T06:51:26.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，docker这个东西，是CaaS(Container as a Service，容器即服务)的通常解法。我们使用docker来管理容器的生命周期，比如镜像的生成、容器的管理和定制(Dockerfile)、仓库的上传和下载等。</p><p>但是docker存在很多不方便使用的地方，所以我们可以使用podman来做平替。</p><h2 id="podman介绍"><a href="#podman介绍" class="headerlink" title="podman介绍"></a>podman介绍</h2><p>Podman(Pod Manager), 是由RedHat公司推出的容器管理工具。它可以做为docker的平替，使用上也非常相似。但其实二者之间也存在非常显著的差别，相比起来podman会比docker更加完善一些。</p><h2 id="podman与docker的差异"><a href="#podman与docker的差异" class="headerlink" title="podman与docker的差异"></a>podman与docker的差异</h2><h3 id="1-底层CRI"><a href="#1-底层CRI" class="headerlink" title="1. 底层CRI"></a>1. 底层CRI</h3><ul><li><p>docker：使用的是docker-shim, 这个CRI(Container Runtime Interface, 容器运行接口)并不是docker实现的，而是kubernetes帮它实现的。由于早期没有docker平替工具，故kubernetes开发了一个api调用docker管理下的容器资源。后来由于有了其他的平替工具，所以kubernetes在1.20版本正式停止维护docker-shim这个CRI，使用其余CRI(可以由其他容器管理工具实现，例如CRI-O等)。这也就是当时讲的“kubernetes停止对docker维护”的意思。</p></li><li><p>podman：使用的是CRI-O，该接口来自于开放容器计划(OCI), 可以让kubelet来调用下层的容器资源，而不需要人为管理，如图所示。</p><p>其余比较知名的CRI还有containerd、lxd等。</p><p><img src="https://pic4.zhimg.com/v2-1d3b4a0f70fd5fb472d6d26c589f0763_r.jpg" alt="preview"></p></li></ul><h3 id="2-守护进程"><a href="#2-守护进程" class="headerlink" title="2. 守护进程"></a>2. 守护进程</h3><ul><li><p>docker：后台有docker-daemon，需要root权限</p></li><li><p>podman：没有daemon，不需要root权限</p></li></ul><h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h3><ul><li><p>docker：如果你在容器外有一些文件无法访问，在启动镜像映射文件的时候，你将此文件映射到容器中时，使用docker exec进入容器后，就可以编辑了。</p></li><li><p>podman：即使你将容器外无法访问的文件映射到容器中时，也无法编辑此文件。</p><p>因此，podman比docker安全性更好。</p></li></ul><h2 id="podman安装"><a href="#podman安装" class="headerlink" title="podman安装"></a>podman安装</h2><h3 id="1-ubuntu"><a href="#1-ubuntu" class="headerlink" title="1. ubuntu"></a>1. ubuntu</h3><p>1） ubuntu22.04，可直接apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y podman</span><br></pre></td></tr></table></figure><p>2）ubuntu18.04和20.04，需要添加源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. /etc/os-release</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_<span class="variable">$&#123;VERSION_ID&#125;</span>/ /&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class="line"></span><br><span class="line">curl -L <span class="string">&quot;https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_<span class="variable">$&#123;VERSION_ID&#125;</span>/Release.key&quot;</span> | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">apt install -y podman</span><br></pre></td></tr></table></figure><h3 id="2-centos"><a href="#2-centos" class="headerlink" title="2. centos"></a>2. centos</h3><p>1）cent8可以直接yum安装docker，默认装的是podman</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure><p>2）cent7，可以安装epel-release, 然后yum安装podman</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y podman</span><br></pre></td></tr></table></figure><p>如果非root用户来使用podman，可能会遇到namespace没权限的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user namespaces are not enabled <span class="keyword">in</span> /proc/sys/user/max_user_namespaces</span><br></pre></td></tr></table></figure><p>此功能是Centos3.8添加进去的，默认关闭，需要打开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># cat /proc/sys/user/max_user_namespaces</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># 临时打开</span></span><br><span class="line"></span><br><span class="line">[root@node2 ~]<span class="comment"># echo 200 &gt; /proc/sys/user/max_user_namespaces  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel 设置</span></span><br><span class="line">[root@node2 ~]<span class="comment"># grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</span></span><br><span class="line"><span class="comment"># 写入配置文件</span></span><br><span class="line">[root@node2 ~]<span class="comment"># echo &quot;user.max_user_namespaces=200&quot; &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">[root@node2 ~]<span class="comment"># sysctl -p</span></span><br><span class="line"><span class="comment"># 关闭namespace</span></span><br><span class="line">[root@node2 ~]<span class="comment"># grubby --remove-args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</span></span><br></pre></td></tr></table></figure><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>当然，如果你敲docker上瘾，也可以使用alias修改别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias docker=podman&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="仓库源"><a href="#仓库源" class="headerlink" title="仓库源"></a>仓库源</h2><p>如果podman使用默认的仓库源，可能会pull不下来，所以需要修改仓库源。</p><p>由于podman不需要root权限，任何人都可以使用，所以每个人可以设置自己的源，就像环境变量一样，每人一个。</p><p>全局配置: &#x2F;etc&#x2F;containers&#x2F;registries.conf</p><p>个人配置: ~&#x2F;.config&#x2F;containers&#x2F;registries.conf</p><p>配置方法：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">unqualified-search-registries</span> = <span class="string">[&quot;docker.io&quot;, &quot;registry.access.redhat.com&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[[registry]]</span></span><br><span class="line"><span class="attr">prefix</span> = <span class="string">&quot;docker.io&quot;</span></span><br><span class="line"><span class="attr">location</span> = <span class="string">&quot;docker.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[[registry.mirror]]</span></span><br><span class="line"><span class="attr">location</span> = <span class="string">&quot;docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line"><span class="attr">[[registry.mirror]]</span></span><br><span class="line"><span class="attr">location</span> = <span class="string">&quot;registry.docker-cn.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>podman pull的时候，比docker多了一个镜像选择的过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">young@home:/opt$ podman pull nginx</span><br><span class="line">✔ docker.io/library/nginx:latest</span><br><span class="line">Trying to pull docker.io/library/nginx:latest...</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob 589b7251471a <span class="keyword">done</span>  </span><br><span class="line">Copying blob 186b1aaa4aa6 <span class="keyword">done</span>  </span><br><span class="line">Copying blob a0bcbecc962e <span class="keyword">done</span>  </span><br><span class="line">Copying blob b4df32aa5a72 <span class="keyword">done</span>  </span><br><span class="line">Copying blob a9edb18cadd1 <span class="keyword">done</span>  </span><br><span class="line">Copying blob a2abf6c4d29d <span class="keyword">done</span>  </span><br><span class="line">Copying config 605c77e624 <span class="keyword">done</span>  </span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85</span><br><span class="line">young@home:/opt$ podman images</span><br><span class="line">REPOSITORY                 TAG         IMAGE ID      CREATED       SIZE</span><br><span class="line"></span><br><span class="line">docker.io/library/nginx    latest      605c77e624dd  6 months ago  146 MB</span><br><span class="line">young@home:/opt$ podman run -d -p 8000:80 docker.io/library/nginx </span><br><span class="line"></span><br><span class="line">6e898573edec454699c760b9d5f23091cb22143563e038e8d2cdf0d5277c03dc</span><br><span class="line">young@home:/opt$ </span><br><span class="line">young@home:/opt$ docker container ps -a</span><br><span class="line">CONTAINER ID  IMAGE                             COMMAND               CREATED        STATUS            PORTS                                             NAMES</span><br><span class="line"></span><br><span class="line">6e898573edec  docker.io/library/nginx:latest    nginx -g daemon o...  4 seconds ago  Up 5 seconds ago  0.0.0.0:8000-&gt;80/tcp                              hopeful_brattain</span><br></pre></td></tr></table></figure><p>然后访问ip:8000, 发现run起来了。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/07/03-13-07-51-%E6%88%AA%E5%B1%8F2022-07-03%2013.06.20.png" alt="nginx"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，docker这个东西，是CaaS(Container as a Service，容器即服务)的通常解法。我们使用docker来管</summary>
      
    
    
    
    <category term="容器" scheme="http://eryoung2.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="podman" scheme="http://eryoung2.github.io/tags/podman/"/>
    
  </entry>
  
  <entry>
    <title>清理缓存</title>
    <link href="http://eryoung2.github.io/2022/07/03/%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/"/>
    <id>http://eryoung2.github.io/2022/07/03/%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-02T17:19:41.000Z</published>
    <updated>2022-07-04T06:51:54.420Z</updated>
    
    <content type="html"><![CDATA[<p>释放缓存区内存的方法</p><p><strong>1）清理pagecache（页面缓存）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># echo 1 &gt; /proc/sys/vm/drop_caches 或者 # sysctl -w vm.drop_caches=1</span></span><br></pre></td></tr></table></figure><p><strong>2）清理dentries（目录缓存）和inodes</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># echo 2 &gt; /proc/sys/vm/drop_caches 或者 # sysctl -w vm.drop_caches=2</span></span><br></pre></td></tr></table></figure><p><strong>3）清理pagecache、dentries和inodes</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches 或者 # sysctl -w vm.drop_caches=3</span></span><br></pre></td></tr></table></figure><p>上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在&#x2F;etc&#x2F;sysctl.conf文件中配置：vm.drop_caches&#x3D;1&#x2F;2&#x2F;3，然后sysctl -p生效即可！</p><p>另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># sync</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;释放缓存区内存的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）清理pagecache（页面缓存）&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
    <category term="内核" scheme="http://eryoung2.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux ACL权限控制</title>
    <link href="http://eryoung2.github.io/2022/06/27/linux-ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://eryoung2.github.io/2022/06/27/linux-ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</id>
    <published>2022-06-27T15:48:24.000Z</published>
    <updated>2022-06-27T15:50:03.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ACL是Access Control List（访问控制列表）的缩写，用于linux复杂的用户权限控制当中。</p><p>Cent7系统之前，只有系统安装时创建的文件系统支持ACL，后来创建的文件系统则不支持。</p><p>Cent7系统后，不管文件系统是否在安装系统时被建立，都支持ACL。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong><font color="red">getfacl：用于查看ACL权限。</font></strong></p><p><strong><font color="red">setfacl：用于设置ACL权限。</font></strong></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="1-查看文件或目录权限"><a href="#1-查看文件或目录权限" class="headerlink" title="1. 查看文件或目录权限"></a>1. 查看文件或目录权限</h4><p><strong><font color="red">getfacl 文件&#x2F;文件夹名</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# getfacl ~</span><br><span class="line">getfacl: Removing leading &#x27;/&#x27; from absolute path names</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::r-x</span><br><span class="line">group::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h4 id="2-修改用户对文件或目录的权限"><a href="#2-修改用户对文件或目录的权限" class="headerlink" title="2. 修改用户对文件或目录的权限"></a>2. 修改用户对文件或目录的权限</h4><p><strong><font color="red">setfacl -m u:uname:access 文件&#x2F;文件夹名</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# setfacl -m u:young:rwx -R ~   #将/root的权限赋予young</span><br><span class="line">[root@vm1 ~]# getfacl ~</span><br><span class="line">getfacl: Removing leading &#x27;/&#x27; from absolute path names</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::r-x</span><br><span class="line">user:young:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><p>我将我个人对&#x2F;root文件夹的访问权限改成了可读可写，而组内用户有读权限，组外用户无任何权限。</p><p>接下来进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[young@vm1 root]$ dd if=/dev/zero of=/root/testfile bs=1M count=20 #创建一个测试文件</span><br><span class="line">记录了20+0 的读入</span><br><span class="line">记录了20+0 的写出</span><br><span class="line">20971520字节(21 MB)已复制，0.0154888 秒，1.4 GB/秒</span><br><span class="line">[young@vm1 root]$ ll|grep testfile </span><br><span class="line">-rw-rw-r--  1 young young 20971520 8月  30 01:49 testfile</span><br><span class="line">[young@vm1 root]$ id nobody</span><br><span class="line">uid=99(nobody) gid=99(nobody) 组=99(nobody)</span><br></pre></td></tr></table></figure><p>的确，young用户由于被赋权。所以可以在&#x2F;root目录下进行读写；而nobody用户由于未被赋权，且不在root组内，故什么权限都没有。</p><p>测试完毕后，我们使用setfacl -b &#x2F;root取消刚才添加的ACL权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# setfacl -b /root</span><br><span class="line">[root@vm1 ~]# getfacl ~</span><br><span class="line">getfacl: Removing leading &#x27;/&#x27; from absolute path names</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::r-x</span><br><span class="line">group::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h4 id="3-修改组对文件或目录的权限："><a href="#3-修改组对文件或目录的权限：" class="headerlink" title="3. 修改组对文件或目录的权限："></a>3. 修改组对文件或目录的权限：</h4><p>**<font color="red">setfacl g:gid:access 文件&#x2F;目录路径</font>**，用法与给用户赋权一致，故不再赘述。</p><h4 id="4-移动-x2F-复制文件或目录时需要注意的点："><a href="#4-移动-x2F-复制文件或目录时需要注意的点：" class="headerlink" title="4. 移动&#x2F;复制文件或目录时需要注意的点："></a>4. 移动&#x2F;复制文件或目录时需要注意的点：</h4><p>移动文件&#x2F;目录时，默认连带ACL权限一起移动。</p><p>复制文件时，默认不保留权限；需要加使用**<font color="red">cp -p</font>**命令，才保留权限。</p><h4 id="5-挂载时需要注意的点："><a href="#5-挂载时需要注意的点：" class="headerlink" title="5. 挂载时需要注意的点："></a>5. 挂载时需要注意的点：</h4><p>如原来的文件系统不支持ACL权限，我们可以将其重新挂载。</p><p><strong><font color="red">mount -o remount, acl 挂载点</font></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;ACL是Access Control List（访问控制列表）的缩写，用于linux复杂的用户权限控制当中。&lt;/p&gt;
&lt;p&gt;Cent7系统之</summary>
      
    
    
    
    <category term="权限管理" scheme="http://eryoung2.github.io/categories/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux安装jdk8</title>
    <link href="http://eryoung2.github.io/2022/06/25/linux%E5%AE%89%E8%A3%85jdk8/"/>
    <id>http://eryoung2.github.io/2022/06/25/linux%E5%AE%89%E8%A3%85jdk8/</id>
    <published>2022-06-25T14:56:03.000Z</published>
    <updated>2022-06-25T14:57:26.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="1-下载安装包并上传"><a href="#1-下载安装包并上传" class="headerlink" title="1. 下载安装包并上传"></a>1. 下载安装包并上传</h4><h4 id="2-解压"><a href="#2-解压" class="headerlink" title="2.  解压"></a>2.  解压</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@home:/home/young# tar zxf jdk-8u131-linux-x64.tar.gz -C /usr/local/</span><br><span class="line">root@home:/home/young# mv /usr/local/jdk1.8.0_131/ /usr/local/java8</span><br></pre></td></tr></table></figure><h4 id="3-在-x2F-etc-x2F-profile添加项目"><a href="#3-在-x2F-etc-x2F-profile添加项目" class="headerlink" title="3. 在&#x2F;etc&#x2F;profile添加项目"></a>3. 在&#x2F;etc&#x2F;profile添加项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java8/</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="4-使-x2F-etc-x2F-profile生效"><a href="#4-使-x2F-etc-x2F-profile生效" class="headerlink" title="4. 使&#x2F;etc&#x2F;profile生效"></a>4. 使&#x2F;etc&#x2F;profile生效</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="5-验证jdk版本"><a href="#5-验证jdk版本" class="headerlink" title="5. 验证jdk版本"></a>5. 验证jdk版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;h4 id=&quot;1-下载安装包并上传&quot;&gt;&lt;a href=&quot;#1-下载安装包并上传&quot; class=&quot;headerlink&quot; title=&quot;1. 下载</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vim操作(第一弹)</title>
    <link href="http://eryoung2.github.io/2022/06/24/vim%E6%93%8D%E4%BD%9C-%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <id>http://eryoung2.github.io/2022/06/24/vim%E6%93%8D%E4%BD%9C-%E7%AC%AC%E4%B8%80%E5%BC%B9/</id>
    <published>2022-06-23T17:52:40.000Z</published>
    <updated>2022-06-23T17:54:51.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vi&#x2F;vim是unix&#x2F;linux操作系统下的文本编辑器。<br>由于unix&#x2F;linux万物届文件的特性，vi&#x2F;vim可以编辑任何格式的文件。<br>下面是常见的知识点，仅供参考。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="编辑方式"><a href="#编辑方式" class="headerlink" title="编辑方式"></a>编辑方式</h4><p>vi&#x2F;vim + 文件路径。其中，文件路径可以是绝对路径，也可以是相对路径。如果这个文件不存在，就会新建一个文件。</p><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>vi&#x2F;vim常用的模式有两种：命令行模式和输入模式。</p><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p>由命令行模式切换到输入模式的命令：</p><ul><li><p>新增 (append)<br>a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。<br>A： 从光标所在列最後面的地方开始新增资料。</p></li><li><p>插入（insert）<br>i： 从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。<br>I ：从光标所在列的第一个非空白字元前面开始插入资料。</p></li><li><p>开始(open)<br>o ：在光标所在列下新增一列并进入输入模式。<br>O: 在光标所在列上方新增一列并进入输入模式。</p></li><li><p>保存&#x2F;退出<br>在指令模式下键入:q,:q!,:wq或:x(注意:号），就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出，如果文件已有新的变化，vi会提示你保存文件而:q命令也会失效，这时你可以用:w命令保存文件后再用:q退出，或用:wq或:x命令退出，如果你不想保存改变后的文件，你就需要用:q!命令，这个命令将不保存文件而直接退出vi。</p></li><li><p>常用操作(命令行模式下)：<br>Ctrl+F：下翻一页<br>Ctrl+B:上翻一页<br>&#x2F;+单词：查找<br>dd：删除一行</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;vi&amp;#x2F;vim是unix&amp;#x2F;linux操作系统下的文本编辑器。&lt;br&gt;由于unix&amp;#x2F;linux万物届文件的特性，v</summary>
      
    
    
    
    <category term="编辑器" scheme="http://eryoung2.github.io/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
    <category term="vim" scheme="http://eryoung2.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从架构</title>
    <link href="http://eryoung2.github.io/2022/06/21/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <id>http://eryoung2.github.io/2022/06/21/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</id>
    <published>2022-06-21T01:39:46.000Z</published>
    <updated>2022-06-21T06:43:31.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mysql是我们经常使用的关系型数据库，在实际使用中，我们会使用单数据库，也会使用各种集群技术。其中最常用的是主从集群。</p><p>主从分很多种，一主一丛、双主、一主多从、多主多从等。其中主数据库可读可写，从机只读不写。</p><p>本文主要介绍前两种，主写从读和双主互备。</p><p>而这些方案实现的原理，则是binlog复制。</p><h2 id="Binlog复制"><a href="#Binlog复制" class="headerlink" title="Binlog复制"></a>Binlog复制</h2><p>Mysql有很多log，binlog是其中一种。当mysql执行了改动语句时，改动会被记录在binlog中，所以主从复制主要复制的就是这个binlog。</p><p>但具体来讲，Mysql主从复制涉及到三个线程：</p><p>1）主节点的log dump thread，给从库I&#x2F;O线程传Binlog数据</p><p>2）从节点的I&#x2F;O线程，会请求主库并将得到的Binlog写到本地的relay log中</p><p>3）从节点的SQL线程，会读取relay log中的日志，并解析成SQL语句进行同步</p><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/21-14-42-59-mysql-arch.png"></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>针对主从架构，我们准备两台机，并各自安装mysql server，端口3306.</p><table><thead><tr><th></th><th>主机</th><th>从机</th></tr></thead><tbody><tr><td>IP地址</td><td>192.168.1.150</td><td>192.168.1.113</td></tr><tr><td>用户</td><td>repl</td><td>repl</td></tr><tr><td>数据库</td><td>Test_DB</td><td>Test_DB</td></tr><tr><td>数据表</td><td>STUDENTS</td><td>STUDENTS</td></tr></tbody></table><p>由于这两台机是不同的系统，所以安装mysql这里就不展示了，我们直接开始数据库设置。</p><p>1）在两台数据库都创建Test_DB数据库和STUDENTS表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE Test_DB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENTS (  </span><br><span class="line">ID <span class="type">INT</span>                           <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">NAME <span class="type">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">AGE <span class="type">INT</span>                         <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">ADDRESS <span class="type">CHAR</span> (<span class="number">25</span>),  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (ID)  </span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>2）在两台数据库都创建复制用户，并赋权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;repl123&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>. <span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>3）在两台数据库打开binlog，在配置文件中添加，并添加bind-address，然后重启数据库</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log_bin</span>                 = <span class="string">mysql-bin</span></span><br><span class="line"><span class="attr">binlog_format</span>           = <span class="string">ROW</span></span><br><span class="line"><span class="attr">bind-address</span>            = <span class="string">0.0.0.0</span></span><br></pre></td></tr></table></figure><h2 id="互为主备or主写从读？"><a href="#互为主备or主写从读？" class="headerlink" title="互为主备or主写从读？"></a>互为主备or主写从读？</h2><h3 id="主写从读"><a href="#主写从读" class="headerlink" title="主写从读"></a>主写从读</h3><p>顾名思义，主写从读就是主库写，从库读取主库的binlog并备份。在对外提供服务的时候，应用向主库写入信息，可以从主库或从库读取。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/21-14-43-12-master-slave.png"></p><p>需要在从库的配置中添加只读选项，然后重启从库。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read-only</span></span><br><span class="line"><span class="attr">super_read_only</span></span><br></pre></td></tr></table></figure><h3 id="互为主备"><a href="#互为主备" class="headerlink" title="互为主备"></a>互为主备</h3><p>不需要添加什么配置。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/21-14-43-24-master-master.png"></p><h2 id="binlog复制"><a href="#binlog复制" class="headerlink" title="binlog复制"></a>binlog复制</h2><h3 id="主写从读-1"><a href="#主写从读-1" class="headerlink" title="主写从读"></a>主写从读</h3><p>顾名思义，我们需要在从库同步主库的binlog状态，并开启同步。</p><p>1）首先，查询主库的binlog状态，找到file和position，这里file是mysql-bin.000009，Position是3205，代表主库目前的binlog位置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">             File: mysql<span class="operator">-</span>bin<span class="number">.000009</span></span><br><span class="line">         Position: <span class="number">3205</span></span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>2）从库同步主库，并启动同步。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.150&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repl&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;repl123&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000009&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">3205</span>;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure><p>如果成功的话，查询slave状态如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave status\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> source <span class="keyword">to</span> send event</span><br><span class="line">                  Master_Host: <span class="number">192.168</span><span class="number">.1</span><span class="number">.150</span></span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: <span class="number">3306</span></span><br><span class="line">                Connect_Retry: <span class="number">60</span></span><br><span class="line">              Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000009</span></span><br><span class="line">          Read_Master_Log_Pos: <span class="number">3205</span></span><br><span class="line">               Relay_Log_File: node3<span class="operator">-</span>relay<span class="operator">-</span>bin<span class="number">.000002</span></span><br><span class="line">                Relay_Log_Pos: <span class="number">960</span></span><br><span class="line">        Relay_Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000009</span></span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>Slave_IO_Running和Slave_SQL_Running都是Yes，说明同步成功。</p><p>如果不成功的话，可以找找哪里出了问题，并停止同步，重新定位主库的binlog。</p><h3 id="互为主备-1"><a href="#互为主备-1" class="headerlink" title="互为主备"></a>互为主备</h3><p>其实互为主备比主写从读多一步，就是主库也要同步从库。</p><p>在主机上跑同步，file和position是从库的master状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.113&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repl&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;repl123&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000012&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">2920</span>;</span><br><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><p>在从库上也跑同步，file和position是主库的master状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.150&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repl&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;repl123&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000009&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">3205</span>;</span><br><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><p>这样互为主备就做好了。我们插入一条信息时，另外一库也会同步。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然，互为主备肯定有问题，那就是如果各种原因导致的主从复制失效，导致两个库的数据不同步、binlog不同步，这时候我们只有祭出恢复的方法了，比如把主库导入从库，或者从备份进行恢复且重新做同步，这就是另一个问题了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mysql是我们经常使用的关系型数据库，在实际使用中，我们会使用单数据库，也会使用各种集群技术。其中最常用的是主从集群。&lt;/p&gt;
&lt;p&gt;主从</summary>
      
    
    
    
    <category term="数据库" scheme="http://eryoung2.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://eryoung2.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>hexo添加图床</title>
    <link href="http://eryoung2.github.io/2022/06/16/hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%BA%8A/"/>
    <id>http://eryoung2.github.io/2022/06/16/hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%BA%8A/</id>
    <published>2022-06-16T15:10:16.000Z</published>
    <updated>2022-06-21T01:41:01.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果大家用过Markdown的话，就会知道在markdown里边插入图片时非常蛋疼，但凡换个地方来发布，图片就会404.</p><p>由于我最近在github pages上建了一个blog，我也遇到了这个问题，这时候就得找找办法。经过查询资料，我发现可以通过github创建图床来解决，效果不错。</p><p>当然，需要我们提前打开一个功能，在_config.yml中打开<strong>post_asset_folder</strong>, 将其置为true。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>顾名思义，图床就是对博客图片的集中管理。目前比较好用的应用有SM.MS、iPic、Picgo等。由于我这里使用MarkText来写博客，而MarkText也支持了创建图床的功能，故直接使用此功能来做图床。</p><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><h3 id="1-在github上创建一个git仓库"><a href="#1-在github上创建一个git仓库" class="headerlink" title="1. 在github上创建一个git仓库"></a>1. 在github上创建一个git仓库</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-34-48-git.png"></p><h3 id="2-创建一个Access-token"><a href="#2-创建一个Access-token" class="headerlink" title="2. 创建一个Access token"></a>2. 创建一个Access token</h3><p>在”<strong>用户-Setting-Developer Settings</strong>“下建立一个access token，创建之后有一串密文，将其保存下来。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-35-02-token.png"></p><h3 id="3-在MarkText设置图床"><a href="#3-在MarkText设置图床" class="headerlink" title="3. 在MarkText设置图床"></a>3. 在MarkText设置图床</h3><p>打开MarkText的<strong>reference-image</strong>, 按如下内容做设置</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-35-24-setup.png"></p><p>然后就可以了。不得不说，挺好用的哈哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果大家用过Markdown的话，就会知道在markdown里边插入图片时非常蛋疼，但凡换个地方来发布，图片就会404.&lt;/p&gt;
&lt;p&gt;由于</summary>
      
    
    
    
    <category term="博客优化" scheme="http://eryoung2.github.io/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="hexo" scheme="http://eryoung2.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>常用发布方式总结</title>
    <link href="http://eryoung2.github.io/2022/06/14/%E5%B8%B8%E7%94%A8%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://eryoung2.github.io/2022/06/14/%E5%B8%B8%E7%94%A8%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-14T15:23:16.000Z</published>
    <updated>2022-06-23T17:42:33.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，在IT公司中，如果要发布新版本的话，需要考虑上线的安全性与稳定性。传统的方法是先停机，然后做新版本发布，最后重新上线。但我们都知道，这样做会导致服务中断，可能会造成业务丢失，从而造成损失。</p><p>所以我们通常会使用一些不会造成服务中断的发布方式，即边发布新版本，边提供服务，使得发布过程变得较为平滑。</p><p>常用的发布方式有：蓝绿发布、滚动发布、灰度发布(金丝雀发布)三种。</p><h2 id="蓝绿发布"><a href="#蓝绿发布" class="headerlink" title="蓝绿发布"></a>蓝绿发布</h2><p>蓝绿发布中，一共有两套系统。一套运行旧版本应用，被称为“绿色”；一套运行新版本应用，被称为“蓝色”。两套系统均功能完善，并且正在运行的系统，只是系统版本和对外服务情况不同。正在对外提供服务的老系统是绿色系统，新部署的系统是蓝色系统。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/15-00-15-14-lanlv.png"></p><p>两套系统互不干扰，我们可以单独对蓝色系统进行调试，而不影响绿色系统提供服务。</p><p>在蓝色系统调试好后，可将流量导至蓝色系统，进行用户测试；若出现问题，则切回绿色系统。</p><p>在用户测试没问题后，升级绿色系统。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1）蓝绿部署的目的是<strong>减少发布时的中断时间</strong>、<strong>能够快速撤回发布</strong>。</p><p>2）两套系统没有耦合的时候才能百分百保证不干扰。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>蓝绿发布是发布方式中的一种，需要根据特定情况进行选择。蓝绿部署能够简单快捷实施的前提假设是目标系统是非常内聚的，如果目标系统相当复杂，那么如何切换、两套系统的数据是否需要以及如何同步等，都需要仔细考虑。</p><p>当你切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果你的数据库后端无法处理，会是一个比较麻烦的问题；</p><ul><li>可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能会导致服务停止。</li><li>需要提前考虑数据库与应用部署同步迁移 &#x2F;回滚的问题。</li><li>蓝绿部署需要有基础设施支持。</li><li>在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。</li></ul><h2 id="滚动发布"><a href="#滚动发布" class="headerlink" title="滚动发布"></a>滚动发布</h2><p>相比蓝绿发布将机器分为两拨，滚动发布会分得更细。每次只升级一小部分机器，然后滚动升级，最终完成全部升级。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/15-00-15-01-gundong.png"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>1）这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。</p><p>2）回滚困难。</p><h3 id="滚动发布注意事项"><a href="#滚动发布注意事项" class="headerlink" title="滚动发布注意事项"></a>滚动发布注意事项</h3><p>1）滚动发布没有一个确定可行的环境。蓝绿部署我们知道老版本是可行的，但是滚动发布不行。</p><p>2）修改了现有环境。</p><p>3）回滚困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚，这个回滚却是一个痛苦，并且漫长的过程。</p><p>4）有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容&#x2F;缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。</p><p>5）因为是逐步更新，那么我们在上线代码的时候，就会短暂出现新老版本不一致的情况，如果对上线要求较高的场景，那么就需要考虑如何做好兼容的问题。 </p><h2 id="灰度发布（金丝雀发布）"><a href="#灰度发布（金丝雀发布）" class="headerlink" title="灰度发布（金丝雀发布）"></a>灰度发布（金丝雀发布）</h2><p>灰度发布，也叫金丝雀发布。是指在黑与白之间平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度，而我们平常所说的金丝雀部署也就是灰度发布的一种方式。</p><p>具体到服务器上, 实际操作中还可以做更多控制，譬如说，给最初更新的10台服务器设置较低的权重、控制发送给这10台服务器的请求数，然后逐渐提高权重、增加请求数。一种平滑过渡的思路, 这个控制叫做“流量切分”。</p><p>关于金丝雀发布这个名字的来源，可以参考以下故事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/15-00-14-49-huidu.png"></p><p>过程:</p><p>1）准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。</p><p>2）将“金丝雀”服务器部署进服务器中, 测试。</p><p>3）从负载均衡列表中移除掉“金丝雀”服务器。</p><p>4）升级“金丝雀”应用（排掉原有流量并进行部署）。</p><p>5）对应用进行自动化测试。</p><p>6）将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。</p><p>7）如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）</p><h2 id="A-x2F-B测试"><a href="#A-x2F-B测试" class="headerlink" title="A&#x2F;B测试"></a>A&#x2F;B测试</h2><p>顾名思义，上面三个都是发布策略，而A&#x2F;B是个测试策略。二者侧重点不同，发布策略主要关注新系统的程序bug和隐患，而测试策略主要关注新旧版本之间的使用对比，关注实际效果，如转化率、订单情况等。</p><p>A&#x2F;B测试时，线上同时运行多个版本的服务，这些服务通常会有一些体验上的差异，譬如说页面样式、颜色、操作流程不同。相关人员通过分析各个版本服务的实际效果，选出效果最好的版本。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/15-00-14-35-ab.png"></p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://www.cnblogs.com/Courage129/p/14498788.html">微服务部署之蓝绿发布、滚动发布、灰度发布区别与特点</a></p><p><a href="https://zh.wikipedia.org/wiki/A/B%E6%B8%AC%E8%A9%A6">AB测试</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，在IT公司中，如果要发布新版本的话，需要考虑上线的安全性与稳定性。传统的方法是先停机，然后做新版本发布，最后重新上线。但我们都知</summary>
      
    
    
    
    <category term="IT概念" scheme="http://eryoung2.github.io/categories/IT%E6%A6%82%E5%BF%B5/"/>
    
    
    <category term="发布方式" scheme="http://eryoung2.github.io/tags/%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Sourcetree 跳过注册环节</title>
    <link href="http://eryoung2.github.io/2022/06/12/Sourcetree-%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%8E%AF%E8%8A%82/"/>
    <id>http://eryoung2.github.io/2022/06/12/Sourcetree-%E8%B7%B3%E8%BF%87%E6%B3%A8%E5%86%8C%E7%8E%AF%E8%8A%82/</id>
    <published>2022-06-12T02:23:40.000Z</published>
    <updated>2022-06-16T15:47:20.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天在电脑上装了个sourcetree，结果它硬要我注册，烦得很。<br>于是查了一下怎么跳过注册环节，结果还真有，试了一下，真给力！<br>特此记录。</p><h3 id="MAC版本："><a href="#MAC版本：" class="headerlink" title="MAC版本："></a>MAC版本：</h3><ol><li><p>打开sourcetree</p></li><li><p>关闭sourcetree</p></li><li><p>命令终端输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.torusknot.SourceTreeNotMAS completedWelcomeWizardVersion 3</span><br></pre></td></tr></table></figure></li><li><p>打开sourcetree即可跳过登录</p></li></ol><p> </p><h3 id="Windows版本："><a href="#Windows版本：" class="headerlink" title="Windows版本："></a>Windows版本：</h3><ol><li><p>打开我的电脑，输入“%LocalAppData%\Atlassian\SourceTree\”，并新建一个<strong>accounts.json</strong>文件，如图:<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-47-13-win_sourcetree.png"></p></li><li><p>在<strong>accounts.json</strong>文件中输入以下内容后，重新登录，即可跳过注册&#x2F;登陆环节，直接使用。</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;$id&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;$type&quot;</span><span class="punctuation">:</span><span class="string">&quot;SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;Authenticate&quot;</span><span class="punctuation">:</span><span class="keyword">true</span><span class="punctuation">,</span> <span class="attr">&quot;HostInstance&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>  <span class="attr">&quot;$id&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;$type&quot;</span><span class="punctuation">:</span><span class="string">&quot;SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;Host&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>   <span class="attr">&quot;$id&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span><span class="punctuation">,</span>   <span class="attr">&quot;$type&quot;</span><span class="punctuation">:</span><span class="string">&quot;SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount&quot;</span><span class="punctuation">,</span>   <span class="attr">&quot;Id&quot;</span><span class="punctuation">:</span><span class="string">&quot;atlassian account&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;BaseUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;https://id.atlassian.com/&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;Credentials&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>   <span class="attr">&quot;$id&quot;</span><span class="punctuation">:</span><span class="string">&quot;4&quot;</span><span class="punctuation">,</span>   <span class="attr">&quot;$type&quot;</span><span class="punctuation">:</span><span class="string">&quot;SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account&quot;</span><span class="punctuation">,</span>   <span class="attr">&quot;Username&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>   <span class="attr">&quot;Email&quot;</span><span class="punctuation">:</span><span class="keyword">null</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;IsDefault&quot;</span><span class="punctuation">:</span><span class="keyword">false</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几天在电脑上装了个sourcetree，结果它硬要我注册，烦得很。&lt;br&gt;于是查了一下怎么跳过注册环节，结果还真有，试了一下，真给力！&lt;b</summary>
      
    
    
    
    <category term="工具使用" scheme="http://eryoung2.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="Sourcetree" scheme="http://eryoung2.github.io/tags/Sourcetree/"/>
    
  </entry>
  
  <entry>
    <title>hexo 改变主题的问题</title>
    <link href="http://eryoung2.github.io/2022/06/06/hexo-%E6%94%B9%E5%8F%98%E4%B8%BB%E9%A2%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://eryoung2.github.io/2022/06/06/hexo-%E6%94%B9%E5%8F%98%E4%B8%BB%E9%A2%98%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-06-06T02:23:08.000Z</published>
    <updated>2022-06-06T17:11:10.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo改变主题后部署报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1 安装插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><p>2 清空缓存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>3 重新部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hexo改变主题后部署报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="错误排查" scheme="http://eryoung2.github.io/categories/%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="hexo" scheme="http://eryoung2.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
