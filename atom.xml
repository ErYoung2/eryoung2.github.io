<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eryoung2的个人博客</title>
  
  <subtitle>ErYoung2写字的地方</subtitle>
  <link href="http://eryoung2.github.io/atom.xml" rel="self"/>
  
  <link href="http://eryoung2.github.io/"/>
  <updated>2022-08-09T11:56:00.346Z</updated>
  <id>http://eryoung2.github.io/</id>
  
  <author>
    <name>ErYoung2</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>powershell执行策略</title>
    <link href="http://eryoung2.github.io/2022/08/09/powershell%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/"/>
    <id>http://eryoung2.github.io/2022/08/09/powershell%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/</id>
    <published>2022-08-09T09:33:58.000Z</published>
    <updated>2022-08-09T11:56:00.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博文，我介绍了一下powershell和cmd的对比。通过学习，我发现powershell的确比cmd更加power，也更加适应现在的使用场景。<br>那么本文将继续介绍一个powershell的另一个特性，执行策略。</p><h2 id="execution-policy描述"><a href="#execution-policy描述" class="headerlink" title="execution policy描述"></a>execution policy描述</h2><p>首先我们看看官网是怎么描述execution policy的:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">PowerShell&#x27;s execution policy is a safety feature that controls the conditions under which PowerShell loads configuration files and runs scripts. This feature helps prevent the execution of malicious scripts.</span><br><span class="line"></span><br><span class="line">On a Windows computer you can set an execution policy for the local computer, for the current user, or for a particular session. You can also use a Group Policy setting to set execution policies for computers and users.</span><br><span class="line"></span><br><span class="line">Execution policies for the local computer and current user are stored in the registry. You don&#x27;t need to set execution policies in your PowerShell profile. The execution policy for a particular session is stored only in memory and is lost when the session is closed.</span><br><span class="line"></span><br><span class="line">The execution policy isn&#x27;t a security system that restricts user actions. For example, users can easily bypass a policy by typing the script contents at the command line when they cannot run a script. Instead, the execution policy helps users to set basic rules and prevents them from violating them unintentionally.</span><br><span class="line"></span><br><span class="line">On non-Windows computers, the default execution policy is Unrestricted and cannot be changed. The Set-ExecutionPolicy cmdlet is available, but PowerShell displays a console message that it&#x27;s not supported. While Get-ExecutionPolicy returns Unrestricted on non-Windows platforms, the behavior really matches Bypass because those platforms do not implement the Windows Security Zones.我们总结一下，这段文字中提到了几个要点：</span><br><span class="line"></span><br><span class="line">1. powershell的执行策略是种安全特性，保证不会什么猫狗脚本都执行，对于操作系统是种保护。</span><br><span class="line">2. windows的执行策略执行粒度分3种：本机、当前用户、特定会话。本机和当前用户的策略会存进注册表，当前会话的执行策略只会进内存，会话一断就会消失。</span><br><span class="line">3. 执行策略并不会限制用户操作，只是给了用户一把安全锁，可用可不用。</span><br><span class="line">4. 对于非windows机器，不会有执行策略的设置，因此会建议windows机器来做设置。</span><br><span class="line"></span><br><span class="line">## 常见的执行策略</span><br><span class="line"></span><br><span class="line">明白了上面的几个要点，我们来看windows提供了哪些执行策略供我们使用。</span><br><span class="line"></span><br><span class="line">1. ByPass</span><br><span class="line">   任何脚本都可以执行，且没有任何提示。</span><br><span class="line"></span><br><span class="line">2. Undefined</span><br><span class="line">   没有设置脚本执行策略。</span><br><span class="line"></span><br><span class="line">3. Unrestricted</span><br><span class="line">   允许运行未签名的脚本，但是会有安全性提示。</span><br><span class="line"></span><br><span class="line">4. Default</span><br><span class="line">   默认策略，对客户端是Restricted，对服务端是RemoteSigned</span><br><span class="line"></span><br><span class="line">5. RemoteSigned</span><br><span class="line">   Windows Server 2012 R2 之后的默认策略</span><br><span class="line">   如果从网络下载的脚本会有限制，需要添加数字签名；如果是本地创建的脚本，则不需要数字签名可以运行。</span><br><span class="line"></span><br><span class="line">但是问题来了，真的会有老哥从网络上下载到本地运行，而不是复制粘贴到本地，自己创建的文件里？</span><br><span class="line"></span><br><span class="line">不会吧，不会吧？</span><br><span class="line">![image](https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/08/09-17-37-42-buhui.jpg)</span><br><span class="line"></span><br><span class="line">6. AllSigned</span><br><span class="line">   本策略只允许运行具有数字签名的脚本。</span><br><span class="line"></span><br><span class="line">7. Restricted</span><br><span class="line">   本策略允许运行命令，但无法运行脚本。</span><br><span class="line"></span><br><span class="line">## 运行范围</span><br><span class="line"></span><br><span class="line">上面也讲了，powershell有3种范围：本机、当前用户、当前会话。</span><br><span class="line">可使用Scope选项进行设置。</span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line">PS C:\Windows\system32&gt; Get-ExecutionPolicy -Scope LocalMachine</span><br><span class="line">RemoteSigned</span><br><span class="line">PS C:\Windows\system32&gt; Get-ExecutionPolicy -Scope CurrentUser</span><br><span class="line">Undefined</span><br><span class="line">PS C:\Windows\system32&gt; Set-ExecutionPolicy RemoteSigned -Scope CurrentUserc</span><br><span class="line">执行策略更改</span><br><span class="line">执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170</span><br><span class="line">中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?</span><br><span class="line">[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): A</span><br><span class="line">PS C:\Windows\system32&gt; Get-ExecutionPolicy -Scope CurrentUser</span><br><span class="line">RemoteSigned</span><br></pre></td></tr></table></figure><h2 id="cmd调用powershell"><a href="#cmd调用powershell" class="headerlink" title="cmd调用powershell"></a>cmd调用powershell</h2><p>由于powershell和cmd是不同的命令行，而且powershell有执行策略的限制，如果我们想使用cmd去运行powershell脚本，除了需要设置powershell的策略，还需要使用cmd设置ps1脚本默认的运行方式。<br>默认方式是打开&#x2F;编辑，而不是运行。</p><p>设置成运行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ftype</span> Microsoft.PowerShellScript.<span class="number">1</span>=&quot;<span class="variable">%SystemRoot%</span>\system32\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe&quot; &quot;%<span class="number">1</span>&quot;</span><br></pre></td></tr></table></figure><p>设置成编辑：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ftype</span> Microsoft.PowerShellScript.<span class="number">1</span>=&quot;<span class="variable">%SystemRoot%</span>\system32\notepad.exe&quot; &quot;%<span class="number">1</span>&quot;</span><br></pre></td></tr></table></figure><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">官网</a><br><a href="https://www.cnblogs.com/sparkdev/p/7460518.html">powershell脚本执行策略</a><br><a href="https://www.codeleading.com/article/55285613479/">CMD命令行修改.ps1文件（powershell脚本）的默认打开方式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇博文，我介绍了一下powershell和cmd的对比。通过学习，我发现powershell的确比cmd更加power，也更加适应现在的</summary>
      
    
    
    
    <category term="windows" scheme="http://eryoung2.github.io/categories/windows/"/>
    
    
    <category term="powershell" scheme="http://eryoung2.github.io/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>powershell和cmd比较</title>
    <link href="http://eryoung2.github.io/2022/08/04/powershell%E5%92%8Ccmd%E6%AF%94%E8%BE%83/"/>
    <id>http://eryoung2.github.io/2022/08/04/powershell%E5%92%8Ccmd%E6%AF%94%E8%BE%83/</id>
    <published>2022-08-03T18:32:40.000Z</published>
    <updated>2022-08-09T11:28:59.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>计算机啊这东西，本质上是硬件和软件的综合体。如果只有硬件没有软件的话，这也是台辣鸡而已。而计算机软件中最靠近硬件的一层，就是操作系统层。</p><p>操作系统有很多种，比如Unix&#x2F;Linux&#x2F;Mac OS&#x2F;Windows几种。其中，我们接触的第一款操作系统应该就是微软(巨硬)公司的windows系列了。这款操作系统从1985年发表第一款操作系统Windows1.0开始，到现在已经有将近40年的历史了。所以Windows内部也一定存在很多祖传的应用，比如Windows NT、扫雷、cmd等。</p><p>虽然Windows是一款以视窗为主要交互模式的操作系统，但是对于一个脚本佬，命令行同样重要。甚至有时命令行的交互效率比视窗的点点点更高，也更快捷方便(就比如我刚开始使用linux的shell的时候，对此非常抗拒，觉得十分难用；但是用久了就回不去了，现在整天骂Windows，为啥设计得如此不透明)。</p><p>当然啦，脚本佬毕竟是少数，大部分人还是觉得Windows的点点点更加符合自己的使用习惯。然而作为一个脚本佬，就没办法再搁那儿点点点了，这样难免被人说lowbi。于是我简单地看了一下Windows的命令行，发现有两种–黑框的cmd和篮框的powershell。那本文主要讨论这二者的异同。</p><p>    </p><h2 id="cmd-vs-powershell"><a href="#cmd-vs-powershell" class="headerlink" title="cmd vs powershell"></a>cmd vs powershell</h2><p>我呢，是个土包子，看到这二者的第一感觉就是，powershell是加强版的cmd。这句话说了等于没说，因为的确如此。如果这个问题是个面试题，你要这么答，很难保证面试官不会继续问下去，“请详细讲讲，这二者有啥异同”？这时候就喝喝了，你就没话可讲了，最后就得被迫回家等消息。那我们这里不废话，直接上表格：</p><table><thead><tr><th></th><th>cmd</th><th>powershell</th></tr></thead><tbody><tr><td>框框颜色</td><td>黑色</td><td>蓝色</td></tr><tr><td>起用时间</td><td>1981年</td><td>2006年</td></tr><tr><td>适用性</td><td>仅支持cmd脚本(bat,cmd)</td><td>支持cmd脚本(bat,cmd)和powershell脚本(ps1)</td></tr><tr><td>扩展性</td><td>仅支持cmd内置函数</td><td>支持cmd内置函数+powershell cmdlet</td></tr><tr><td>命令别名</td><td>不支持</td><td>支持</td></tr><tr><td>输出内容类型</td><td>文本</td><td>对象</td></tr><tr><td>程序并发</td><td>不支持</td><td>支持</td></tr><tr><td>是否有ISE(编译器)</td><td>无，只有命令行</td><td>有，而且能直接调试</td></tr><tr><td>是否支持.net库</td><td>否</td><td>是</td></tr><tr><td>是否支持WMI（监控工具）</td><td>否</td><td>是</td></tr><tr><td>是否可以管理微软云资源</td><td>否</td><td>是</td></tr><tr><td>是否支持shell</td><td>否</td><td>是</td></tr><tr><td>是否可以运行所有类型程序</td><td>否</td><td>是</td></tr></tbody></table><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面我总结了powershell和cmd的异同点，可以从中看到powershell是cmd的加强版，但是加强得过了头，基本上也可以作为Windows不同世代，实现命令行交互的两种方式了。其中cmd能做的事情powershell都能做，而powershell除了兼容cmd以外，也增加了几项对脚本佬更加友善的改进：</p><ol><li><p>增加了cmdlet，使得很多功能可以像成熟的编程语言一样直接调用。</p></li><li><p>拉进了与linux shell的操作距离，使得学习成本大大降低。</p></li><li><p>支持了很多更友善的功能，比如ISE和WMI，操作感比cmd更先进。</p></li><li><p>增加了操作其他语言的便捷性，使得powershell通用性更好。</p></li><li><p>增加了管理其余基础资源的功能，使得我们使用vagrant或者terraform时更方便。</p></li><li><p>由于powershell本身建立在.net框架之上，所以直接可以调用,net相关功能，对于.net开发者是一种福音。</p></li></ol><p>总之，它给了常年使用linux命令行方式进行作业的人(比如我这脚本佬)更好的信心去使用windows进行编程和测试，其强大的功能也令我叹为观止。只能说I need more 抛瓦烧，微软巨硬，魔兽该出新资料片啦！</p><p>    </p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://www.educba.com/powershell-vs-command-prompt/">PowerShell vs Command Prompt | Top 14 Differences You Should Know</a></p><p><a href="https://www.yiibai.com/powershell/powershell-cmdlet.html">https://www.yiibai.com/powershell/powershell-cmdlet.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/380068863">https://zhuanlan.zhihu.com/p/380068863</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;计算机啊这东西，本质上是硬件和软件的综合体。如果只有硬件没有软件的话，这也是台辣鸡而已。而计算机软件中最靠近硬件的一层，就是操作系统层。&lt;/</summary>
      
    
    
    
    <category term="技术对比" scheme="http://eryoung2.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/"/>
    
    <category term="windows" scheme="http://eryoung2.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/windows/"/>
    
    
    <category term="cmd" scheme="http://eryoung2.github.io/tags/cmd/"/>
    
    <category term="powershell" scheme="http://eryoung2.github.io/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>podman网络缺失</title>
    <link href="http://eryoung2.github.io/2022/07/30/podman%E7%BD%91%E7%BB%9C%E7%BC%BA%E5%A4%B1/"/>
    <id>http://eryoung2.github.io/2022/07/30/podman%E7%BD%91%E7%BB%9C%E7%BC%BA%E5%A4%B1/</id>
    <published>2022-07-29T19:37:47.000Z</published>
    <updated>2022-07-29T19:38:44.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>podman由于没有daemon，使用的时候会出现network问题。</p><p>今天打算跑一个busybox时，发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@home:~/manifests# podman run -it busybox</span><br><span class="line">ERRO[0000] error loading cached network config: network &quot;podman&quot; not found in CNI cache</span><br><span class="line">WARN[0000] falling back to loading from existing plugins on disk</span><br><span class="line">ERRO[0000] Error tearing down partially created network namespace for container 25909b12b14aa8a8d1c1934e6e58b5cb55ca0e4e9af45fdff359620f3bc290ce: CNI network &quot;podman&quot; not found</span><br><span class="line">Error: error configuring network namespace for container 25909b12b14aa8a8d1c1934e6e58b5cb55ca0e4e9af45fdff359620f3bc290ce: CNI network &quot;podman&quot; not found</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>没有podman所支持的网络环境。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以跑以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@home:~/manifests# podman network create podman</span><br><span class="line">/etc/cni/net.d/podman.conflist</span><br></pre></td></tr></table></figure><p>然后问题解决，就可以启动容器了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@home:~/manifests# podman run -it busybox</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://github.com/containers/podman/issues/12651">Running podman with sudo returns <code>error loading cached network config: network &amp;quot;podman&amp;quot; not found in CNI cache</code> · Issue #12651 · containers&#x2F;podman · GitHub</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;podman由于没有daemon，使用的时候会出现network问题。&lt;/p&gt;
&lt;p&gt;今天打算跑一个busybox时，发现报错：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="容器" scheme="http://eryoung2.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="podman" scheme="http://eryoung2.github.io/tags/podman/"/>
    
  </entry>
  
  <entry>
    <title>git fetch和git pull对比</title>
    <link href="http://eryoung2.github.io/2022/07/26/git-fetch%E5%92%8Cgit-pull%E5%AF%B9%E6%AF%94/"/>
    <id>http://eryoung2.github.io/2022/07/26/git-fetch%E5%92%8Cgit-pull%E5%AF%B9%E6%AF%94/</id>
    <published>2022-07-26T10:45:20.000Z</published>
    <updated>2022-07-26T11:22:19.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h2><p>你：面试官您好，我是xxx，毕业于xxx学校，工作xxx年，精通各种git命令。</p><p>面试官：您好您好，我问个常见的问题考察一下您的技术水平哈。请问，git pull和git fetch有什么区别，二者都在什么情况下使用？</p><p>你：emmmm…母鸡喔</p><p>面试官（微笑）：回家等消息吧，有结果通知你~</p><h2 id="二者区分"><a href="#二者区分" class="headerlink" title="二者区分"></a>二者区分</h2><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>首先我们来看一下git fetch的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch only downloads latest changes into the local repository. </span><br><span class="line">It downloads fresh changes that other developers have pushed to </span><br><span class="line">the remote repository since the late fetch and allows you to review </span><br><span class="line">and merge manually at a later time using git merge. </span><br><span class="line">Because it doesn&#x27;t change your working directory or the staging area, </span><br><span class="line">it is entirely safe, and you can run it as often as you want.</span><br></pre></td></tr></table></figure><p>我们提取几个关键信息：</p><ol><li><p>git fetch提取远端的最新改变到本地</p></li><li><p>git fetch不强行改变本地状态和预存区</p></li><li><p>可使用git merge手动合并</p></li><li><p>git fetch很安全</p></li></ol><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>我们再看一下git pull的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull downloads latest changes into the local repository </span><br><span class="line">and it also automatically merges change in your working directory. </span><br><span class="line">It doesn&#x27;t give you a chance to review the changes before merging, </span><br><span class="line">and as a consequence, &#x27;merge conflicts&#x27; can and do occur. One important thing</span><br><span class="line">to keep in mind is that it will merge only into the current working branch.</span><br><span class="line">Other branches will stay unaffected.</span><br></pre></td></tr></table></figure><p>我们再提取几个关键信息：</p><ol><li><p>git pull直接将改动同步到本地工作区</p></li><li><p>git pull没机会做merge操作</p></li><li><p>git pull可能出现merge冲突</p></li><li><p>最好在同分支之间使用git pull，否则会出错误</p></li></ol><p>总之：<font color="red">git pull &#x3D; git fetch + git merge</font></p><h2 id="二者在git中的位置"><a href="#二者在git中的位置" class="headerlink" title="二者在git中的位置"></a>二者在git中的位置</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/07/26-18-47-43-git%20fetch%20vs%20git%20pull.png" alt="image"></p><h2 id="git-fetch使用"><a href="#git-fetch使用" class="headerlink" title="git fetch使用"></a>git fetch使用</h2><ol><li>获取远端分支的最新内容到FETCH_HEAD，并查看。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git <span class="built_in">log</span> -p FETCH_HEAD</span><br></pre></td></tr></table></figure><ol start="2"><li>如果可以合并，就合并内容到本地</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>这里解释一下这个FETCH_HEAD, 它是一个版本链接，记录在本地一个文件中(.git&#x2F;FETCH_HEAD)，指向当前分支最新版本。</p><h2 id="git-pull使用"><a href="#git-pull使用" class="headerlink" title="git pull使用"></a>git pull使用</h2><p>git pull的使用相当于上面两步的和，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此题不难，但答不上来的侮辱性极强。</p><p>本题主要考察的是git的基础知识，多看一些博客或者文章就可以搞定。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://www.youtube.com/watch?v=ip1UxTswbo8&ab_channel=KKJavaTutorials">git fetch vs git pull</a></p><p><a href="https://git-scm.com/docs/git-fetch">git官网</a></p><p><a href="https://juejin.cn/post/6844903921794859021">git fetch &amp; pull详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;情景重现&quot;&gt;&lt;a href=&quot;#情景重现&quot; class=&quot;headerlink&quot; title=&quot;情景重现&quot;&gt;&lt;/a&gt;情景重现&lt;/h2&gt;&lt;p&gt;你：面试官您好，我是xxx，毕业于xxx学校，工作xxx年，精通各种git命令。&lt;/p&gt;
&lt;p&gt;面试官：您好您好，我问个常见</summary>
      
    
    
    
    <category term="工具使用" scheme="http://eryoung2.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="http://eryoung2.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>高山低谷 -- 林奕匡</title>
    <link href="http://eryoung2.github.io/2022/07/23/%E9%AB%98%E5%B1%B1%E4%BD%8E%E8%B0%B7-%E6%9E%97%E5%A5%95%E5%8C%A1/"/>
    <id>http://eryoung2.github.io/2022/07/23/%E9%AB%98%E5%B1%B1%E4%BD%8E%E8%B0%B7-%E6%9E%97%E5%A5%95%E5%8C%A1/</id>
    <published>2022-07-23T03:17:26.000Z</published>
    <updated>2022-07-23T03:18:13.377Z</updated>
    
    <content type="html"><![CDATA[<p>站在树林内，就如没氧气，<br>在夕阳下，寂寥吧，没权利见你。<br>早知高的山、低的谷，将你我分隔两地，失去人情味。<br>你那贵族游戏，我的街角游记，<br>天真到信真心，太儿戏。</p><p>    </p><p>你快乐过生活，我拼命去生存，<br>几多人位于山之巅俯瞰我的疲倦。<br>渴望被成全，努力做人谁怕气喘，<br>但那终点，挂在那天边。</p><p>    </p><p>你界定了生活，我侮辱了生存，<br>只适宜滞于山之谷整理我的凌乱。<br>渴望大团圆，脚下路程难以削短，<br>未见终点，也未见恩典，我与你极远。</p><p>    </p><p>越望，越无望，未来没有我，<br>在断崖下，尽头吧，乐园未有过。<br>仿佛天一黑天一光挥发了一句再会，只见人下堕。<br>快慰继续传播，你都不慰问我，<br>区分到太清楚，太严苛。</p><p>    </p><p>你快乐过生活，我拼命去生存，<br>几多人位于山之巅俯瞰我的疲倦。<br>渴望被成全，努力做人谁怕气喘，<br>但那终点，挂在那天边。</p><p>    </p><p>你界定了生活，我侮辱了生存，<br>只适宜滞于山之谷整理我的凌乱。<br>渴望大团圆，脚下路程难以削短，<br>未见终点，也未见恩典，我与你极远。</p><p>    </p><p>我却尚要生存，偷偷存活于山之谷等到某天魂断。<br>你继续盘旋，我继续埋藏我爱恋，<br>没有终点，永没有终点，那永远极远。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;站在树林内，就如没氧气，&lt;br&gt;在夕阳下，寂寥吧，没权利见你。&lt;br&gt;早知高的山、低的谷，将你我分隔两地，失去人情味。&lt;br&gt;你那贵族游戏，我的街角游记，&lt;br&gt;天真到信真心，太儿戏。&lt;/p&gt;
&lt;p&gt;    &lt;/p&gt;
&lt;p&gt;你快乐过生活，我拼命去生存，&lt;br&gt;几多人位于山之</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="林奕匡" scheme="http://eryoung2.github.io/tags/%E6%9E%97%E5%A5%95%E5%8C%A1/"/>
    
  </entry>
  
  <entry>
    <title>《高山低谷》 -- 林奕匡</title>
    <link href="http://eryoung2.github.io/2022/07/23/%E3%80%8A%E9%AB%98%E5%B1%B1%E4%BD%8E%E8%B0%B7%E3%80%8B-%E6%9E%97%E5%A5%95%E5%8C%A1/"/>
    <id>http://eryoung2.github.io/2022/07/23/%E3%80%8A%E9%AB%98%E5%B1%B1%E4%BD%8E%E8%B0%B7%E3%80%8B-%E6%9E%97%E5%A5%95%E5%8C%A1/</id>
    <published>2022-07-23T03:16:05.000Z</published>
    <updated>2022-07-30T03:31:46.437Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>ruby gem timed out解决</title>
    <link href="http://eryoung2.github.io/2022/07/23/ruby-gem-timed-out%E8%A7%A3%E5%86%B3/"/>
    <id>http://eryoung2.github.io/2022/07/23/ruby-gem-timed-out%E8%A7%A3%E5%86%B3/</id>
    <published>2022-07-22T19:33:00.000Z</published>
    <updated>2022-07-22T19:34:18.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在折腾vagrant的时候，发现当我安装vagrant时，需要一些ruby插件。</p><p>如果我们没有设置正确的源，就会报time out的错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: While executing gem ... (Gem::RemoteFetcher::UnknownHostError)</span><br><span class="line">    timed out (https://api.rubygems.org/latest_specs.4.8.gz)</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以使用国内源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">gem sources -a https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure><p>就可以了。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://gems.ruby-china.com/">ruby gems中文官网</a></p><p><a href="https://blog.csdn.net/Never__Give_Up_/article/details/100592393">Ruby Gem Timeout【超时】问题的解决_Joel__Li的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天在折腾vagrant的时候，发现当我安装vagrant时，需要一些ruby插件。&lt;/p&gt;
&lt;p&gt;如果我们没有设置正确的源，就会报time</summary>
      
    
    
    
    <category term="环境配置" scheme="http://eryoung2.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="ruby" scheme="http://eryoung2.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>飘向北方--namewee</title>
    <link href="http://eryoung2.github.io/2022/07/20/%E9%A3%98%E5%90%91%E5%8C%97%E6%96%B9-namewee/"/>
    <id>http://eryoung2.github.io/2022/07/20/%E9%A3%98%E5%90%91%E5%8C%97%E6%96%B9-namewee/</id>
    <published>2022-07-20T07:06:30.000Z</published>
    <updated>2022-07-27T07:32:24.170Z</updated>
    
    <content type="html"><![CDATA[<p>王：</p><p>漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。</p><p>    </p><p>黄：<br>有人说他在老家欠了一堆钱，想要避避风头，<br>有人说他练就了一身武艺，却没机会展露，<br>有人失去了自我，手足无措四处漂流，<br>有人为了梦想为了三餐为养家糊口。<br>他住在燕郊区，残破的求职公寓，<br>拥挤的大楼里，堆满陌生人都来自外地，<br>他埋头写着履历，怀抱着多少憧憬，<br>往返在九三零号公路，内心盼着奇迹。<br>不听也不想，不敢回头望的遗憾，<br>扛下了梦想，要毅然决然去流浪。<br>卸下了自尊、光环，过去多风光，<br>就算再不堪、败仗，也不能投降。<br>再见了南方，眺望最美丽的家乡，<br>椰子树摇晃，梦境倒映着的幻象。<br>雾霾太猖狂，不散，都看不清前方。</p><p>    </p><p>王：<br>漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。<br>也是最后寄望，回不去的远方～Oh～</p><p>    </p><p>黄：<br>空气太脏、太浑浊，他说不喜欢，<br>车太混乱、太匆忙，他还不习惯。<br>人行道一双有一双，斜视冷漠的眼光，<br>他经常自将己灌醉，强迫融入，这大染缸。<br>走着脚步蹒跚，二锅头在摇晃，<br>失意的人啊偶尔醉倒在那胡同陋巷。<br>咀嚼爆肚涮羊，手中盛着一碗热汤，<br>用力地、温暖着，内心里的不安。<br>不听也不想，不敢回头望的遗憾，<br>扛下了梦想，要毅然决然去流浪。<br>卸下了自尊、光环，过去多风光，<br>就算再不堪、败仗，也不能投降。<br>再见了南方，眺望最美丽的家乡，<br>椰子树摇晃，梦境倒映着的幻象。<br>雾霾太猖狂，不散，都看不清前方。</p><p>    </p><p>王：<br>漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。<br>就像那尘土飘散随着风向，谁又能带领着我一起飞翔，<br>我站在天坛中央闭上眼，祈求一家人都平安。</p><p>我漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。</p><p>我漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。</p><p>    </p><p>合：<br>我站在天子脚下，被踩的喘不过气，<br>走在前门大街，跟人潮，总会分歧。<br>或许我根本不属于这里，早就该离去，<br>谁能给我致命的一击，请用力到彻底。<br>这里是梦想的中心，但梦想都遥不可及，<br>这里是圆梦的圣地，但却总是扑朔迷离。<br>多少人敌不过残酷的现实，从此销声匿迹，<br>多少人陷入了昏迷，剩下一具，空壳尸体。<br>Rest in Peace～</p><p>    </p><p> </p><p>王：<br>漂向北方，别再问我家乡～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;王：&lt;/p&gt;
&lt;p&gt;漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；&lt;br&gt;我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。&lt;/p&gt;
&lt;p&gt;    &lt;/p&gt;
&lt;p&gt;黄：&lt;br&gt;有人说他在老家欠了一堆钱，想要避避风头，&lt;br&gt;有人说他练就了一身武艺，却没机会展露，&lt;b</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="namewee" scheme="http://eryoung2.github.io/tags/namewee/"/>
    
    <category term="王力宏" scheme="http://eryoung2.github.io/tags/%E7%8E%8B%E5%8A%9B%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm介绍</title>
    <link href="http://eryoung2.github.io/2022/07/19/kubeadm%E4%BB%8B%E7%BB%8D/"/>
    <id>http://eryoung2.github.io/2022/07/19/kubeadm%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-07-19T05:01:17.000Z</published>
    <updated>2022-07-19T07:09:11.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，k8s中有三位大哥：kubelet, kubeadm, kubectl.</p><p>其中：</p><ul><li><p>kubelet是服务，用来调用下层的container管理器，从而对底层容器进行管理。</p></li><li><p>kubectl是API，供我们调用，键入命令对k8s资源进行管理。</p></li><li><p>kubeadm是管理器，我们可以使用它进行k8s节点的管理。</p></li></ul><p>基于kubeadm，我们最常用的功能有三个：</p><ul><li><p>init：初始化k8s节点</p></li><li><p>join：将worker节点加入到k8s集群</p></li><li><p>reset：尽最大努力还原init或者join对集群的影响</p></li></ul><p>那么，接下来就对这三个功能进行介绍。</p><h2 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>运行此命令来搭建 Kubernetes 控制平面节点。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>“init” 命令执行以下阶段：</p><p>1 预加载(preflight), 检查环境。</p><p>2 生成CA证书。</p><p>3 生成kubeconfig文件，以便kubelet和kubectl连接到API服务器，并生成一个admin.conf，便于管理。</p><p>4 为 API 服务器、控制器管理器和调度器生成静态 Pod 的清单文件。</p><p>5 对控制平面节点应用标签和污点标记以便不会在它上面运行其它的工作负载。</p><p>6 生成token令牌。</p><p>7 创建configmap提供集群节点的信息与RBAC的访问规则；允许启动引导token令牌访问API；配置自动签发新的CSR请求。</p><p>8 安装插件，coredns和kube-proxy，需要安装CNI之后才可使用coredns。</p><p>按照官方说法，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">preflight                    Run pre-flight checks</span><br><span class="line">certs                        Certificate generation</span><br><span class="line">  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components</span><br><span class="line">  /apiserver                   Generate the certificate for serving the Kubernetes API</span><br><span class="line">  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet</span><br><span class="line">  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy</span><br><span class="line">  /front-proxy-client          Generate the certificate for the front proxy client</span><br><span class="line">  /etcd-ca                     Generate the self-signed CA to provision identities for etcd</span><br><span class="line">  /etcd-server                 Generate the certificate for serving etcd</span><br><span class="line">  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other</span><br><span class="line">  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd</span><br><span class="line">  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd</span><br><span class="line">  /sa                          Generate a private key for signing service account tokens along with its public key</span><br><span class="line">kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file</span><br><span class="line">  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself</span><br><span class="line">  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes</span><br><span class="line">  /controller-manager          Generate a kubeconfig file for the controller manager to use</span><br><span class="line">  /scheduler                   Generate a kubeconfig file for the scheduler to use</span><br><span class="line">kubelet-start                Write kubelet settings and (re)start the kubelet</span><br><span class="line">control-plane                Generate all static Pod manifest files necessary to establish the control plane</span><br><span class="line">  /apiserver                   Generates the kube-apiserver static Pod manifest</span><br><span class="line">  /controller-manager          Generates the kube-controller-manager static Pod manifest</span><br><span class="line">  /scheduler                   Generates the kube-scheduler static Pod manifest</span><br><span class="line">etcd                         Generate static Pod manifest file for local etcd</span><br><span class="line">  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance</span><br><span class="line">upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap</span><br><span class="line">  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap</span><br><span class="line">  /kubelet                     Upload the kubelet component config to a ConfigMap</span><br><span class="line">upload-certs                 Upload certificates to kubeadm-certs</span><br><span class="line">mark-control-plane           Mark a node as a control-plane</span><br><span class="line">bootstrap-token              Generates bootstrap tokens used to join a node to a cluster</span><br><span class="line">kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap</span><br><span class="line">  /experimental-cert-rotation  Enable kubelet client certificate rotation</span><br><span class="line">addon                        Install required addons for passing Conformance tests</span><br><span class="line">  /coredns                     Install the CoreDNS addon to a Kubernetes cluster</span><br><span class="line">  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h --help 帮助</span><br><span class="line">--dry-run 干跑，看效果，不做改变</span><br><span class="line">--apiserver-advertise-address apiserver的ip地址，默认主节点ip</span><br><span class="line">--apiserver-bind-port apiserver监听端口，默认6443</span><br><span class="line">--node-name string 指定节点名称</span><br><span class="line">--image-repository 指定容器的仓库，默认k8s.gcr.io</span><br><span class="line">--pod-network-cidr 指定pod的CIDR，例如“10.244.0.0/16”</span><br><span class="line">--token-ttl duration 指定token的有效时间，默认24小时</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>内容很多，我谨列出几个常见的参数，具体使用可查询官方文档。</p><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init | Kubernetes</a></p><h2 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a>kubeadm join</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p>使得worker node加入到k8s集群中。</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>kubeadm初始化集群时，我们需要建立双向信任。这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p><p>有两种主要的发现方案：</p><p>1 使用共享令牌和 API 服务器的 IP 地址(基于令牌发现)，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</span><br></pre></td></tr></table></figure><p>2 提供一个标准 kubeconfig 文件的一个子集(基于文件发现)，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --discovery-file path/to/file.conf</span><br><span class="line">kubeadm join --discovery-file https://url/file.conf</span><br></pre></td></tr></table></figure><p>kubeadm join运行的过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">preflight              Run join pre-flight checks</span><br><span class="line">control-plane-prepare  Prepare the machine for serving a control plane</span><br><span class="line">  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret</span><br><span class="line">  /certs                 Generate the certificates for the new control plane components</span><br><span class="line">  /kubeconfig            Generate the kubeconfig for the new control plane components</span><br><span class="line">  /control-plane         Generate the manifests for the new control plane components</span><br><span class="line">kubelet-start          Write kubelet settings, certificates and (re)start the kubelet</span><br><span class="line">control-plane-join     Join a machine as a control plane instance</span><br><span class="line">  /etcd                  Add a new local etcd member</span><br><span class="line">  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)</span><br><span class="line">  /mark-control-plane    Mark a node as a control-plane</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-h --help 帮助</span><br><span class="line">--dry-run 干跑，看效果，不做改变</span><br><span class="line">--discovery-token 基于令牌的发现</span><br><span class="line">--discovery-file 基于文件的发现</span><br></pre></td></tr></table></figure><p>内容很多，我谨列出几个常见的参数，具体使用可查询官方文档。</p><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join | Kubernetes</a></p><h2 id="kubeadm-reset"><a href="#kubeadm-reset" class="headerlink" title="kubeadm reset"></a>kubeadm reset</h2><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><p>该命令尽力还原由 kubeadm init 或 kubeadm join 所做的更改。</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><p>过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preflight              Run reset pre-flight checks</span><br><span class="line">update-cluster-status  Remove this node from the ClusterStatus object.</span><br><span class="line">remove-etcd-member     Remove a local etcd member.</span><br><span class="line">cleanup-node           Run cleanup node.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[reset] Reading configuration from the cluster...</span><br><span class="line">[reset] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">W0719 03:48:16.785110    4092 preflight.go:55] [reset] WARNING: Changes made to this host by &#x27;kubeadm init&#x27; or &#x27;kubeadm join&#x27; will be reverted.</span><br><span class="line">[reset] Are you sure you want to proceed? [y/N]: y</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[reset] Stopping the kubelet service</span><br><span class="line">[reset] Unmounting mounted directories in &quot;/var/lib/kubelet&quot;</span><br><span class="line">[reset] Deleting contents of directories: [/etc/kubernetes/manifests /etc/kubernetes/pki]</span><br><span class="line">[reset] Deleting files: [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf]</span><br><span class="line">[reset] Deleting contents of stateful directories: [/var/lib/etcd /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni]</span><br></pre></td></tr></table></figure><p>需要注意，它只会删除掉&#x2F;etc&#x2F;kubernetes&#x2F;下的文件，～&#x2F;.kube下的文件需要手动删除，否则重新建立k8s集群时会报错。</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-h --help 帮助</span><br><span class="line">--dry-run 干跑，看效果，不做改变</span><br><span class="line">-f 不询问，强制执行</span><br><span class="line">--cri-socket 指定CRI插槽，默认为/var/lib/kubelet</span><br></pre></td></tr></table></figure><p>内容很多，我谨列出几个常见的参数，具体使用可查询官方文档。</p><p>(<a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset | Kubernetes</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，k8s中有三位大哥：kubelet, kubeadm, kubectl.&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="云原生" scheme="http://eryoung2.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="k8s" scheme="http://eryoung2.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s+crio+podman搭建集群</title>
    <link href="http://eryoung2.github.io/2022/07/13/k8s-crio-podman%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/"/>
    <id>http://eryoung2.github.io/2022/07/13/k8s-crio-podman%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/</id>
    <published>2022-07-13T10:26:27.000Z</published>
    <updated>2022-07-13T10:56:00.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在传统的k8s集群中，我们都是使用docker engine做为底层的容器管理软件的，而docker engine因为不是k8s亲生的解决方案，所以实际使用中会有更多的分层。之前我们也讲过，k8s为了调用docker engine，专门写了一个dockershim做为CRI，而在1.20版本的时候，k8s就宣布停止更新dockershim了，也就是说再往后的版本就不推荐使用k8s+dockershim+docker engine的方案了。</p><p>而k8s官方比较推荐的解决方案中，官方比较推荐的是cri-o或者containerd，前者是基于开放容器计划(OCI)的实现，后者是基于docker的containerd，后脱离出来进行独立开发的组件，现归属于CNCF组织。</p><h2 id="CRI-O-vs-containerd-vs-docker-daemon"><a href="#CRI-O-vs-containerd-vs-docker-daemon" class="headerlink" title="CRI-O vs containerd vs docker daemon"></a>CRI-O vs containerd vs docker daemon</h2><p>这三者有啥区别呢？</p><p>首先，cri-o是cri的实现，可以直接调用底层的runc</p><p>其次，containerd是CRI-Containerd的实现，可以调用底层的runc</p><p>而docker则需要先调用dockershim，然后调用docker，再调用containerd，最后调用底层的runc</p><p>三者区别如图：</p><img title="" src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/07/13-18-54-22-crio%20vs%20containd%20vs%20docker.png" alt="" data-align="left"><h2 id="k8s-crio-podman实现"><a href="#k8s-crio-podman实现" class="headerlink" title="k8s+crio+podman实现"></a>k8s+crio+podman实现</h2><h3 id="podman安装"><a href="#podman安装" class="headerlink" title="podman安装"></a>podman安装</h3><p>可参考我前一篇文章</p><p><a href="https://www.cnblogs.com/young233/p/16439698.html">docker的平替–podman - eryoung2 - 博客园</a></p><p>三台机都需要安装podman</p><h3 id="k8s的安装"><a href="#k8s的安装" class="headerlink" title="k8s的安装"></a>k8s的安装</h3><p>可参考我另一篇文章</p><p><a href="https://www.cnblogs.com/young233/p/15119748.html">kubernetes 搭建集群 - eryoung2 - 博客园</a></p><p>三台机都需要安装kubelet&#x2F;kubeadm&#x2F;kubectl，并启动kubelet</p><h3 id="cri-o的安装"><a href="#cri-o的安装" class="headerlink" title="cri-o的安装"></a>cri-o的安装</h3><h4 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu(18.04)"></a>Ubuntu(18.04)</h4><p>1 准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">modprobe overlay  # 打开overlay</span><br><span class="line">modprobe br_netfilter  # 打开netfilter</span><br><span class="line">cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf &lt;&lt;EOF #内核处理</span><br><span class="line">net.bridge.bridge-nf-call-iptables  = 1</span><br><span class="line">net.ipv4.ip_forward                 = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br><span class="line">swapoff -a #kube scheduler要求关闭swap</span><br></pre></td></tr></table></figure><p>2 安装CRI-O</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定版本</span></span><br><span class="line">OS=xUbuntu_18.04</span><br><span class="line">CRIO_VERSION=1.23</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加源</span></span><br><span class="line">echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /&quot;|sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class="line">echo &quot;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$CRIO_VERSION/$OS/ /&quot;|sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$CRIO_VERSION.list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加key</span></span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$CRIO_VERSION/$OS/Release.key | sudo apt-key add -</span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/Release.key | sudo apt-key add -</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">sudo apt update -y</span><br><span class="line">sudo apt install cri-o cri-o-runc cri-tools -y</span><br></pre></td></tr></table></figure><p>3 检查CRI-O</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# apt show cri-o</span><br><span class="line">Package: cri-o</span><br><span class="line">Version: 1.23.3~0</span><br><span class="line">Priority: optional</span><br><span class="line">Section: devel</span><br><span class="line">Maintainer: Peter Hunt &lt;haircommander@fedoraproject.org&gt;</span><br><span class="line">Installed-Size: 98.3 MB</span><br><span class="line">Depends: libgpgme11, libseccomp2, conmon, containers-common (&gt;= 0.1.27) | golang-github-containers-common, tzdata</span><br><span class="line">Suggests: cri-o-runc | runc (&gt;= 1.0.0), containernetworking-plugins</span><br><span class="line">Replaces: cri-o-1.19, cri-o-1.20, cri-o-1.21, cri-o-1.22</span><br><span class="line">Homepage: https://github.com/cri-o/cri-o</span><br><span class="line">Download-Size: 19.9 MB</span><br><span class="line">APT-Manual-Installed: yes</span><br><span class="line">APT-Sources: http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/1.23/xUbuntu_18.04  Packages</span><br><span class="line">Description: OCI-based implementation of Kubernetes Container Runtime Interface.</span><br><span class="line"></span><br><span class="line">N: Ignoring file &#x27;ystemctlqq&#x27; in directory &#x27;/etc/apt/sources.list.d/&#x27; as it has no filename extension</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable crio.service</span><br><span class="line">systemctl start crio.service</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# systemctl status crio</span><br><span class="line">● crio.service - Container Runtime Interface for OCI (CRI-O)</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crio.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Wed 2022-07-13 01:26:03 CST; 16h ago</span><br><span class="line">     Docs: https://github.com/cri-o/cri-o</span><br><span class="line"> Main PID: 5338 (crio)</span><br><span class="line">    Tasks: 15</span><br><span class="line">   CGroup: /system.slice/crio.service</span><br><span class="line">           └─5338 /usr/bin/crio</span><br></pre></td></tr></table></figure><p>4 使用cri-o</p><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# crictl info</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &#123;</span><br><span class="line">    &quot;conditions&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;RuntimeReady&quot;,</span><br><span class="line">        &quot;status&quot;: true,</span><br><span class="line">        &quot;reason&quot;: &quot;&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;NetworkReady&quot;,</span><br><span class="line">        &quot;status&quot;: true,</span><br><span class="line">        &quot;reason&quot;: &quot;&quot;,</span><br><span class="line">        &quot;message&quot;: &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# crictl images</span><br><span class="line">IMAGE                                TAG                 IMAGE ID            SIZE</span><br><span class="line">docker.io/calico/cni                 v3.23.2             a87d3f6f1b8fd       263MB</span><br><span class="line">docker.io/calico/node                v3.23.2             a3447b26d32c7       224MB</span><br><span class="line">docker.io/library/nginx              latest              41b0e86104ba6       146MB</span><br><span class="line">k8s.gcr.io/coredns/coredns           v1.8.6              a4ca41631cc7a       47MB</span><br><span class="line">k8s.gcr.io/etcd                      3.5.3-0             aebe758cef4cd       301MB</span><br><span class="line">k8s.gcr.io/kube-apiserver            v1.24.2             d3377ffb7177c       131MB</span><br><span class="line">k8s.gcr.io/kube-controller-manager   v1.24.2             34cdf99b1bb3b       121MB</span><br><span class="line">k8s.gcr.io/kube-proxy                v1.24.2             a634548d10b03       112MB</span><br><span class="line">k8s.gcr.io/kube-scheduler            v1.24.2             5d725196c1f47       52.3MB</span><br><span class="line">k8s.gcr.io/pause                     3.6                 6270bb605e12e       690kB</span><br><span class="line">k8s.gcr.io/pause                     3.7                 221177c6082a8       718kB</span><br></pre></td></tr></table></figure><h4 id="Centos-7"><a href="#Centos-7" class="headerlink" title="Centos(7)"></a>Centos(7)</h4><p>1 准备</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VERSION=1.22</span><br><span class="line">sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/CentOS_7/devel:kubic:libcontainers:stable.repo</span><br><span class="line">sudo curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:$&#123;VERSION&#125;.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$&#123;VERSION&#125;/CentOS_7/devel:kubic:libcontainers:stable:cri-o:$&#123;VERSION&#125;.repo</span><br></pre></td></tr></table></figure><p>2 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum install cri-o cri-tools -y</span><br></pre></td></tr></table></figure><p>3 查看cri-o版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 systemd]# rpm -qi cri-o</span><br><span class="line">Name        : cri-o</span><br><span class="line">Epoch       : 0</span><br><span class="line">Version     : 1.22.5</span><br><span class="line">Release     : 2.2.el7</span><br><span class="line">Architecture: x86_64</span><br><span class="line">Install Date: 2022年07月13日 星期三 01时36分47秒</span><br><span class="line">Group       : Unspecified</span><br><span class="line">Size        : 236845729</span><br><span class="line">License     : ASL 2.0</span><br><span class="line">Signature   : RSA/SHA256, 2022年07月10日 星期日 12时53分28秒, Key ID 4d64390375060aa4</span><br><span class="line">Source RPM  : cri-o-1.22.5-2.2.el7.src.rpm</span><br><span class="line">Build Date  : 2022年07月10日 星期日 12时53分00秒</span><br><span class="line">Build Host  : sheep87</span><br><span class="line">Relocations : (not relocatable)</span><br><span class="line">Vendor      : obs://build.opensuse.org/devel:kubic</span><br><span class="line">URL         : https://github.com/cri-o/cri-o</span><br><span class="line">Summary     : Open Container Initiative-based implementation of Kubernetes Container Runtime Interface</span><br><span class="line">Description :</span><br><span class="line">Open Container Initiative-based implementation of Kubernetes Container Runtime</span><br><span class="line">Interface.</span><br></pre></td></tr></table></figure><p>4 启动cri-o</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now cri-o</span><br></pre></td></tr></table></figure><p>5 查看cri-o状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 systemd]# systemctl status crio</span><br><span class="line">● crio.service - Container Runtime Interface for OCI (CRI-O)</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crio.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 三 2022-07-13 01:41:06 CST; 16h ago</span><br><span class="line">     Docs: https://github.com/cri-o/cri-o</span><br><span class="line"> Main PID: 24127 (crio)</span><br><span class="line">    Tasks: 15</span><br><span class="line">   Memory: 13.7M</span><br><span class="line">   CGroup: /system.slice/crio.service</span><br><span class="line">           └─24127 /usr/bin/crio</span><br></pre></td></tr></table></figure><p>三台机都安装cri-o并启动。</p><h2 id="K8S启动"><a href="#K8S启动" class="headerlink" title="K8S启动"></a>K8S启动</h2><p>在master上，跑下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --apiserver-advertise-address 192.168.1.150 --apiserver-bind-port 6443 --kubernetes-version 1.24.2 --pod-network-cidr 10.244.0.0/16</span><br></pre></td></tr></table></figure><p>然后等5分钟，就创建了一个k8s集群的master node。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.1.150:6443 --token gjxt6y.0wljlhfkjz90v12m --discovery-token-ca-cert-hash sha256:d69fc5929e442210c97ab85c05a8c2906f5819a74d5b0fa3481032d6a8f3fc07 </span><br></pre></td></tr></table></figure><p>在三台机上跑这三条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>否则会报错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure><h2 id="检查集群"><a href="#检查集群" class="headerlink" title="检查集群"></a>检查集群</h2><p>在以上所有内容都完成之后，我们可以看一下nodes或者pods</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@home:~# kubectl get nodes</span><br><span class="line">NAME    STATUS   ROLES           AGE    VERSION</span><br><span class="line">home    Ready    control-plane   179m   v1.24.2</span><br><span class="line">node1   Ready    &lt;none&gt;          179m   v1.24.2</span><br><span class="line">node2   Ready    &lt;none&gt;          179m   v1.24.2</span><br><span class="line">root@home:~# kubectl get pods -A</span><br><span class="line">NAMESPACE     NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system   coredns-6d4b75cb6d-4wxjh       1/1     Running   0          179m</span><br><span class="line">kube-system   coredns-6d4b75cb6d-7qxpv       1/1     Running   0          179m</span><br><span class="line">kube-system   etcd-home                      1/1     Running   2          3h</span><br><span class="line">kube-system   kube-apiserver-home            1/1     Running   2          3h</span><br><span class="line">kube-system   kube-controller-manager-home   1/1     Running   2          3h</span><br><span class="line">kube-system   kube-proxy-9w7mf               1/1     Running   0          179m</span><br><span class="line">kube-system   kube-proxy-hpw6c               1/1     Running   0          179m</span><br><span class="line">kube-system   kube-proxy-tbpr8               1/1     Running   0          179m</span><br><span class="line">kube-system   kube-scheduler-home            1/1     Running   2          3h</span><br></pre></td></tr></table></figure><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ol><li><p><a href="https://medium.com/nerd-for-tech/using-cri-o-as-container-runtime-for-kubernetes-b8ddf8326d38">Using CRI-O as container runtime for Kubernetes</a></p></li><li><p><a href="https://computingforgeeks.com/install-cri-o-container-runtime-on-ubuntu-linux/">Ubuntu安装cri-o</a></p></li><li><p><a href="https://computingforgeeks.com/install-cri-o-container-runtime-on-centos-linux/">Install CRI-O Container Runtime on CentOS 8 &#x2F; CentOS 7 | ComputingForGeeks</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在传统的k8s集群中，我们都是使用docker engine做为底层的容器管理软件的，而docker engine因为不是k8s亲生的解决方</summary>
      
    
    
    
    <category term="云原生" scheme="http://eryoung2.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="podman" scheme="http://eryoung2.github.io/tags/podman/"/>
    
    <category term="k8s" scheme="http://eryoung2.github.io/tags/k8s/"/>
    
    <category term="cri-o" scheme="http://eryoung2.github.io/tags/cri-o/"/>
    
  </entry>
  
  <entry>
    <title>ssh服务</title>
    <link href="http://eryoung2.github.io/2022/07/12/ssh%E6%9C%8D%E5%8A%A1/"/>
    <id>http://eryoung2.github.io/2022/07/12/ssh%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-07-11T18:02:11.000Z</published>
    <updated>2022-07-11T18:04:18.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念、定义："><a href="#概念、定义：" class="headerlink" title="概念、定义："></a>概念、定义：</h2><ul><li>SSH是Secure Shell Protocol的简写，由IETF网络工作小组（Network Working Group）制定。</li><li>SSH在数据传输之前，将联机数据包进行加密处理，才会发出给服务端。</li><li>SSH是unix&#x2F;linux进行远程控制或者传输文件的一种协议。</li><li>SSH包括两部分，SSH客户端和SSHD服务端。</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>SSH是密文传输，较明文传输的telnet安全。</li><li>SSH是基于TCP传输协议的，所以是可靠传输。</li><li>SSH的默认端口是22，如要改变端口号，需在修改配置文件之后，加-p参数指定新端口进行ssh连接。</li></ul><h2 id="连接过程："><a href="#连接过程：" class="headerlink" title="连接过程："></a>连接过程：</h2><p>基于账户密码的连接方式：</p><ol><li>客户端用会话密钥加密用户名、认证方法、密码并将加密后的结果发至服务器端。</li><li>服务器端使用会话密钥解密得到用户名、密码，进行核对。若正确，则通过连接；若失败，则返回认证失败报文给客户端。客户端循环第一步，<br>直至达到最大连接次数，TCP连接关闭。<br>基于公钥私钥的连接方式：<ol><li>客户端使用ssh-keygen生成一对公钥和私钥。</li><li>客户端将公钥推送至服务端。ssh-copy-id -i <del>&#x2F;.ssh&#x2F;id_rsa.pub server,即将本机的公钥推送至server机的</del>&#x2F;.ssh&#x2F;authorized_keys里。</li><li>客户端用会话密钥加密用户名、认证方法、公钥并将加密后的结果发至服务器端。</li><li>服务器端进行解密后，对比此公钥是否存在于server机的~&#x2F;.ssh&#x2F;authorized_keys里。若存在，通过验证，进行下一步；若不存在，<br>则返回失败信息。</li><li>服务器端生成质询码，用客户端公钥进行一次加密，用会话密钥进行二次加密，推送给客户端。</li><li>客户端使用会话密钥进行一次解密，用公钥进行二次解密得到质询码。将质询码用会话密钥加密后重新发送给服务器端。</li><li>服务器端使用会话密钥解密后，判断是否是自己的质询码。如果是，则免密登录；若不是，则返回连接失败的信息。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念、定义：&quot;&gt;&lt;a href=&quot;#概念、定义：&quot; class=&quot;headerlink&quot; title=&quot;概念、定义：&quot;&gt;&lt;/a&gt;概念、定义：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SSH是Secure Shell Protocol的简写，由IETF网络工作小组（Network</summary>
      
    
    
    
    <category term="服务" scheme="http://eryoung2.github.io/categories/%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="ssh" scheme="http://eryoung2.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>git创建空白分支</title>
    <link href="http://eryoung2.github.io/2022/07/08/git%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BD%E5%88%86%E6%94%AF/"/>
    <id>http://eryoung2.github.io/2022/07/08/git%E5%88%9B%E5%BB%BA%E7%A9%BA%E7%99%BD%E5%88%86%E6%94%AF/</id>
    <published>2022-07-08T14:59:56.000Z</published>
    <updated>2022-07-27T07:32:21.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在github上创建一些新的分支，发现默认会从某一个分支拉过来成立一个新的分支，.git文件下会有前一分支的提交信息，例如head、ref、logs等。</p><p>那我们能不能创建一个新的分支，让它成为一个空白的分支，不带其他分支的head、ref、logs呢？</p><p>答案是可以的，可以使用orphan参数。</p><h2 id="git-orphan"><a href="#git-orphan" class="headerlink" title="git orphan"></a>git orphan</h2><p>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan branch-name</span><br></pre></td></tr></table></figure><p>首先我们在github创建一个test仓库，克隆到本地，写入一些东西进行提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) ls</span><br><span class="line">➜  test git:(master) git logs</span><br><span class="line">git：&#x27;logs&#x27; 不是一个 git 命令。参见 &#x27;git --help&#x27;。</span><br><span class="line"></span><br><span class="line">最相似的命令是</span><br><span class="line">    log</span><br><span class="line">➜  test git:(master) git log</span><br><span class="line">fatal: 您的当前分支 &#x27;master&#x27; 尚无任何提交</span><br><span class="line">➜  test git:(master) echo &quot;init test&quot; &gt; test1.txt</span><br><span class="line">➜  test git:(master) ✗ git add test1.txt</span><br><span class="line">➜  test git:(master) ✗ git commit -m &quot;test1&quot;</span><br><span class="line">[master（根提交） 80674b3] test1</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test1.txt</span><br><span class="line">➜  test git:(master) git push -u</span><br><span class="line">枚举对象中: 3, 完成.</span><br><span class="line">对象计数中: 100% (3/3), 完成.</span><br><span class="line">写入对象中: 100% (3/3), 216 字节 | 216.00 KiB/s, 完成.</span><br><span class="line">总共 3（差异 0），复用 0（差异 0），包复用 0</span><br><span class="line">To github.com:ErYoung2/test.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">分支 &#x27;master&#x27; 设置为跟踪来自 &#x27;origin&#x27; 的远程分支 &#x27;master&#x27;。</span><br><span class="line">➜  test git:(master) git log</span><br><span class="line">commit 80674b32438bd3bfe0de6d6183b91ea8bdfca129 (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: ErYoung2 </span><br><span class="line">Date:   Fri Jul 8 22:35:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    test1</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>可以看到，我们有一条提交记录。我们创建一个新的branch，先不使用orphan参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(master) git branch test master</span><br><span class="line">➜  test git:(master) git checkout test</span><br><span class="line">切换到分支 &#x27;test&#x27;</span><br><span class="line">➜  test git:(test) git log</span><br><span class="line">commit 80674b32438bd3bfe0de6d6183b91ea8bdfca129 (HEAD -&gt; test, origin/master, master)</span><br><span class="line">Author: ErYoung2 </span><br><span class="line">Date:   Fri Jul 8 22:35:21 2022 +0800</span><br><span class="line"></span><br><span class="line">    test1</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>我们再使用orphan参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test git:(test) git checkout --orphan test2</span><br><span class="line">切换到一个新分支 &#x27;test2&#x27;</span><br><span class="line">➜  test git:(test2) ✗ git log</span><br><span class="line">fatal: 您的当前分支 &#x27;test2&#x27; 尚无任何提交</span><br></pre></td></tr></table></figure><p>就可以发现，新建的分支test2是没有提交记录的。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>这个主要两个作用：</p><ol><li><p>减少仓库数量，我们可以直接切换就好</p></li><li><p>减少新分支对于原分支的依赖，可以不受原分支.git历史文件的干扰，从而可以达到在旧仓库达到git init的效果，进而方便自己的管理。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在github上创建一些新的分支，发现默认会从某一个分支拉过来成立一个新的分支，.git文件下会有前一分支的提交信息，例如head、re</summary>
      
    
    
    
    <category term="版本控制" scheme="http://eryoung2.github.io/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="git" scheme="http://eryoung2.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>linux-dd命令</title>
    <link href="http://eryoung2.github.io/2022/07/05/linux-dd%E5%91%BD%E4%BB%A4/"/>
    <id>http://eryoung2.github.io/2022/07/05/linux-dd%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-05T09:36:57.000Z</published>
    <updated>2022-07-05T09:39:51.222Z</updated>
    
    <content type="html"><![CDATA[<p>dd命令可以轻易实现创建指定大小的文件，如：</p><p><strong><font color="red">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test bs&#x3D;1M count&#x3D;1000</font></strong></p><p>会生成一个1000M的test文件，文件内容为全0（因从&#x2F;dev&#x2F;zero中读取，&#x2F;dev&#x2F;zero为0源）。<br>但是这样为实际写入硬盘，文件产生速度取决于硬盘读写速度，如果欲产生超大文件，速度很慢。</p><p>在某种场景下，我们只想让文件系统认为存在一个超大文件在此，但是并不实际写入硬盘。<br>则可以：</p><p><strong><font color="red">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test bs&#x3D;1M count&#x3D;0 seek&#x3D;100000</font></strong></p><p>此时创建的文件在文件系统中的显示大小为100000MB，但是并不实际占用block，因此创建速度与内存速度相当。<br>seek的作用是跳过输出文件中指定大小的部分，这就达到了创建大文件，但是并不实际写入的目的。</p><p>当然，因为不实际写入硬盘，所以你在容量只有10G的硬盘上创建100G的此类文件都是可以的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;dd命令可以轻易实现创建指定大小的文件，如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=&quot;red&quot;&gt;dd if&amp;#x3D;&amp;#x2F;dev&amp;#x2F;zero of&amp;#x3D;test bs&amp;#x3D;1M count&amp;#x3D;1000&lt;/font&gt;&lt;/st</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>docker的平替--podman</title>
    <link href="http://eryoung2.github.io/2022/07/03/docker%E7%9A%84%E5%B9%B3%E6%9B%BF-podman/"/>
    <id>http://eryoung2.github.io/2022/07/03/docker%E7%9A%84%E5%B9%B3%E6%9B%BF-podman/</id>
    <published>2022-07-03T05:01:14.000Z</published>
    <updated>2022-07-04T06:51:26.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，docker这个东西，是CaaS(Container as a Service，容器即服务)的通常解法。我们使用docker来管理容器的生命周期，比如镜像的生成、容器的管理和定制(Dockerfile)、仓库的上传和下载等。</p><p>但是docker存在很多不方便使用的地方，所以我们可以使用podman来做平替。</p><h2 id="podman介绍"><a href="#podman介绍" class="headerlink" title="podman介绍"></a>podman介绍</h2><p>Podman(Pod Manager), 是由RedHat公司推出的容器管理工具。它可以做为docker的平替，使用上也非常相似。但其实二者之间也存在非常显著的差别，相比起来podman会比docker更加完善一些。</p><h2 id="podman与docker的差异"><a href="#podman与docker的差异" class="headerlink" title="podman与docker的差异"></a>podman与docker的差异</h2><h3 id="1-底层CRI"><a href="#1-底层CRI" class="headerlink" title="1. 底层CRI"></a>1. 底层CRI</h3><ul><li><p>docker：使用的是docker-shim, 这个CRI(Container Runtime Interface, 容器运行接口)并不是docker实现的，而是kubernetes帮它实现的。由于早期没有docker平替工具，故kubernetes开发了一个api调用docker管理下的容器资源。后来由于有了其他的平替工具，所以kubernetes在1.20版本正式停止维护docker-shim这个CRI，使用其余CRI(可以由其他容器管理工具实现，例如CRI-O等)。这也就是当时讲的“kubernetes停止对docker维护”的意思。</p></li><li><p>podman：使用的是CRI-O，该接口来自于开放容器计划(OCI), 可以让kubelet来调用下层的容器资源，而不需要人为管理，如图所示。</p><p>其余比较知名的CRI还有containerd、lxd等。</p><p><img src="https://pic4.zhimg.com/v2-1d3b4a0f70fd5fb472d6d26c589f0763_r.jpg" alt="preview"></p></li></ul><h3 id="2-守护进程"><a href="#2-守护进程" class="headerlink" title="2. 守护进程"></a>2. 守护进程</h3><ul><li><p>docker：后台有docker-daemon，需要root权限</p></li><li><p>podman：没有daemon，不需要root权限</p></li></ul><h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h3><ul><li><p>docker：如果你在容器外有一些文件无法访问，在启动镜像映射文件的时候，你将此文件映射到容器中时，使用docker exec进入容器后，就可以编辑了。</p></li><li><p>podman：即使你将容器外无法访问的文件映射到容器中时，也无法编辑此文件。</p><p>因此，podman比docker安全性更好。</p></li></ul><h2 id="podman安装"><a href="#podman安装" class="headerlink" title="podman安装"></a>podman安装</h2><h3 id="1-ubuntu"><a href="#1-ubuntu" class="headerlink" title="1. ubuntu"></a>1. ubuntu</h3><p>1） ubuntu22.04，可直接apt安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y podman</span><br></pre></td></tr></table></figure><p>2）ubuntu18.04和20.04，需要添加源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">. /etc/os-release</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_<span class="variable">$&#123;VERSION_ID&#125;</span>/ /&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class="line"></span><br><span class="line">curl -L <span class="string">&quot;https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_<span class="variable">$&#123;VERSION_ID&#125;</span>/Release.key&quot;</span> | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">apt install -y podman</span><br></pre></td></tr></table></figure><h3 id="2-centos"><a href="#2-centos" class="headerlink" title="2. centos"></a>2. centos</h3><p>1）cent8可以直接yum安装docker，默认装的是podman</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure><p>2）cent7，可以安装epel-release, 然后yum安装podman</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y podman</span><br></pre></td></tr></table></figure><p>如果非root用户来使用podman，可能会遇到namespace没权限的问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user namespaces are not enabled <span class="keyword">in</span> /proc/sys/user/max_user_namespaces</span><br></pre></td></tr></table></figure><p>此功能是Centos3.8添加进去的，默认关闭，需要打开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># cat /proc/sys/user/max_user_namespaces</span></span><br><span class="line">0</span><br><span class="line"><span class="comment"># 临时打开</span></span><br><span class="line"></span><br><span class="line">[root@node2 ~]<span class="comment"># echo 200 &gt; /proc/sys/user/max_user_namespaces  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel 设置</span></span><br><span class="line">[root@node2 ~]<span class="comment"># grubby --args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</span></span><br><span class="line"><span class="comment"># 写入配置文件</span></span><br><span class="line">[root@node2 ~]<span class="comment"># echo &quot;user.max_user_namespaces=200&quot; &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># 生效</span></span><br><span class="line">[root@node2 ~]<span class="comment"># sysctl -p</span></span><br><span class="line"><span class="comment"># 关闭namespace</span></span><br><span class="line">[root@node2 ~]<span class="comment"># grubby --remove-args=&quot;user_namespace.enable=1&quot; --update-kernel=&quot;$(grubby --default-kernel)&quot;</span></span><br></pre></td></tr></table></figure><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>当然，如果你敲docker上瘾，也可以使用alias修改别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;alias docker=podman&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="仓库源"><a href="#仓库源" class="headerlink" title="仓库源"></a>仓库源</h2><p>如果podman使用默认的仓库源，可能会pull不下来，所以需要修改仓库源。</p><p>由于podman不需要root权限，任何人都可以使用，所以每个人可以设置自己的源，就像环境变量一样，每人一个。</p><p>全局配置: &#x2F;etc&#x2F;containers&#x2F;registries.conf</p><p>个人配置: ~&#x2F;.config&#x2F;containers&#x2F;registries.conf</p><p>配置方法：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">unqualified-search-registries</span> = <span class="string">[&quot;docker.io&quot;, &quot;registry.access.redhat.com&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[[registry]]</span></span><br><span class="line"><span class="attr">prefix</span> = <span class="string">&quot;docker.io&quot;</span></span><br><span class="line"><span class="attr">location</span> = <span class="string">&quot;docker.io&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[[registry.mirror]]</span></span><br><span class="line"><span class="attr">location</span> = <span class="string">&quot;docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line"><span class="attr">[[registry.mirror]]</span></span><br><span class="line"><span class="attr">location</span> = <span class="string">&quot;registry.docker-cn.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>podman pull的时候，比docker多了一个镜像选择的过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">young@home:/opt$ podman pull nginx</span><br><span class="line">✔ docker.io/library/nginx:latest</span><br><span class="line">Trying to pull docker.io/library/nginx:latest...</span><br><span class="line">Getting image <span class="built_in">source</span> signatures</span><br><span class="line">Copying blob 589b7251471a <span class="keyword">done</span>  </span><br><span class="line">Copying blob 186b1aaa4aa6 <span class="keyword">done</span>  </span><br><span class="line">Copying blob a0bcbecc962e <span class="keyword">done</span>  </span><br><span class="line">Copying blob b4df32aa5a72 <span class="keyword">done</span>  </span><br><span class="line">Copying blob a9edb18cadd1 <span class="keyword">done</span>  </span><br><span class="line">Copying blob a2abf6c4d29d <span class="keyword">done</span>  </span><br><span class="line">Copying config 605c77e624 <span class="keyword">done</span>  </span><br><span class="line">Writing manifest to image destination</span><br><span class="line">Storing signatures</span><br><span class="line">605c77e624ddb75e6110f997c58876baa13f8754486b461117934b24a9dc3a85</span><br><span class="line">young@home:/opt$ podman images</span><br><span class="line">REPOSITORY                 TAG         IMAGE ID      CREATED       SIZE</span><br><span class="line"></span><br><span class="line">docker.io/library/nginx    latest      605c77e624dd  6 months ago  146 MB</span><br><span class="line">young@home:/opt$ podman run -d -p 8000:80 docker.io/library/nginx </span><br><span class="line"></span><br><span class="line">6e898573edec454699c760b9d5f23091cb22143563e038e8d2cdf0d5277c03dc</span><br><span class="line">young@home:/opt$ </span><br><span class="line">young@home:/opt$ docker container ps -a</span><br><span class="line">CONTAINER ID  IMAGE                             COMMAND               CREATED        STATUS            PORTS                                             NAMES</span><br><span class="line"></span><br><span class="line">6e898573edec  docker.io/library/nginx:latest    nginx -g daemon o...  4 seconds ago  Up 5 seconds ago  0.0.0.0:8000-&gt;80/tcp                              hopeful_brattain</span><br></pre></td></tr></table></figure><p>然后访问ip:8000, 发现run起来了。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/07/03-13-07-51-%E6%88%AA%E5%B1%8F2022-07-03%2013.06.20.png" alt="nginx"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，docker这个东西，是CaaS(Container as a Service，容器即服务)的通常解法。我们使用docker来管</summary>
      
    
    
    
    <category term="容器" scheme="http://eryoung2.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="podman" scheme="http://eryoung2.github.io/tags/podman/"/>
    
  </entry>
  
  <entry>
    <title>清理缓存</title>
    <link href="http://eryoung2.github.io/2022/07/03/%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/"/>
    <id>http://eryoung2.github.io/2022/07/03/%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98/</id>
    <published>2022-07-02T17:19:41.000Z</published>
    <updated>2022-07-04T06:51:54.420Z</updated>
    
    <content type="html"><![CDATA[<p>释放缓存区内存的方法</p><p><strong>1）清理pagecache（页面缓存）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># echo 1 &gt; /proc/sys/vm/drop_caches 或者 # sysctl -w vm.drop_caches=1</span></span><br></pre></td></tr></table></figure><p><strong>2）清理dentries（目录缓存）和inodes</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># echo 2 &gt; /proc/sys/vm/drop_caches 或者 # sysctl -w vm.drop_caches=2</span></span><br></pre></td></tr></table></figure><p><strong>3）清理pagecache、dentries和inodes</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches 或者 # sysctl -w vm.drop_caches=3</span></span><br></pre></td></tr></table></figure><p>上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在&#x2F;etc&#x2F;sysctl.conf文件中配置：vm.drop_caches&#x3D;1&#x2F;2&#x2F;3，然后sysctl -p生效即可！</p><p>另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@homeserver:~<span class="comment"># sync</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;释放缓存区内存的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）清理pagecache（页面缓存）&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
    <category term="内核" scheme="http://eryoung2.github.io/tags/%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>linux ACL权限控制</title>
    <link href="http://eryoung2.github.io/2022/06/27/linux-ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://eryoung2.github.io/2022/06/27/linux-ACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</id>
    <published>2022-06-27T15:48:24.000Z</published>
    <updated>2022-06-27T15:50:03.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ACL是Access Control List（访问控制列表）的缩写，用于linux复杂的用户权限控制当中。</p><p>Cent7系统之前，只有系统安装时创建的文件系统支持ACL，后来创建的文件系统则不支持。</p><p>Cent7系统后，不管文件系统是否在安装系统时被建立，都支持ACL。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong><font color="red">getfacl：用于查看ACL权限。</font></strong></p><p><strong><font color="red">setfacl：用于设置ACL权限。</font></strong></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="1-查看文件或目录权限"><a href="#1-查看文件或目录权限" class="headerlink" title="1. 查看文件或目录权限"></a>1. 查看文件或目录权限</h4><p><strong><font color="red">getfacl 文件&#x2F;文件夹名</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# getfacl ~</span><br><span class="line">getfacl: Removing leading &#x27;/&#x27; from absolute path names</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::r-x</span><br><span class="line">group::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h4 id="2-修改用户对文件或目录的权限"><a href="#2-修改用户对文件或目录的权限" class="headerlink" title="2. 修改用户对文件或目录的权限"></a>2. 修改用户对文件或目录的权限</h4><p><strong><font color="red">setfacl -m u:uname:access 文件&#x2F;文件夹名</font></strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# setfacl -m u:young:rwx -R ~   #将/root的权限赋予young</span><br><span class="line">[root@vm1 ~]# getfacl ~</span><br><span class="line">getfacl: Removing leading &#x27;/&#x27; from absolute path names</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::r-x</span><br><span class="line">user:young:rwx</span><br><span class="line">group::r-x</span><br><span class="line">mask::rwx</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><p>我将我个人对&#x2F;root文件夹的访问权限改成了可读可写，而组内用户有读权限，组外用户无任何权限。</p><p>接下来进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[young@vm1 root]$ dd if=/dev/zero of=/root/testfile bs=1M count=20 #创建一个测试文件</span><br><span class="line">记录了20+0 的读入</span><br><span class="line">记录了20+0 的写出</span><br><span class="line">20971520字节(21 MB)已复制，0.0154888 秒，1.4 GB/秒</span><br><span class="line">[young@vm1 root]$ ll|grep testfile </span><br><span class="line">-rw-rw-r--  1 young young 20971520 8月  30 01:49 testfile</span><br><span class="line">[young@vm1 root]$ id nobody</span><br><span class="line">uid=99(nobody) gid=99(nobody) 组=99(nobody)</span><br></pre></td></tr></table></figure><p>的确，young用户由于被赋权。所以可以在&#x2F;root目录下进行读写；而nobody用户由于未被赋权，且不在root组内，故什么权限都没有。</p><p>测试完毕后，我们使用setfacl -b &#x2F;root取消刚才添加的ACL权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@vm1 ~]# setfacl -b /root</span><br><span class="line">[root@vm1 ~]# getfacl ~</span><br><span class="line">getfacl: Removing leading &#x27;/&#x27; from absolute path names</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::r-x</span><br><span class="line">group::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure><h4 id="3-修改组对文件或目录的权限："><a href="#3-修改组对文件或目录的权限：" class="headerlink" title="3. 修改组对文件或目录的权限："></a>3. 修改组对文件或目录的权限：</h4><p>**<font color="red">setfacl g:gid:access 文件&#x2F;目录路径</font>**，用法与给用户赋权一致，故不再赘述。</p><h4 id="4-移动-x2F-复制文件或目录时需要注意的点："><a href="#4-移动-x2F-复制文件或目录时需要注意的点：" class="headerlink" title="4. 移动&#x2F;复制文件或目录时需要注意的点："></a>4. 移动&#x2F;复制文件或目录时需要注意的点：</h4><p>移动文件&#x2F;目录时，默认连带ACL权限一起移动。</p><p>复制文件时，默认不保留权限；需要加使用**<font color="red">cp -p</font>**命令，才保留权限。</p><h4 id="5-挂载时需要注意的点："><a href="#5-挂载时需要注意的点：" class="headerlink" title="5. 挂载时需要注意的点："></a>5. 挂载时需要注意的点：</h4><p>如原来的文件系统不支持ACL权限，我们可以将其重新挂载。</p><p><strong><font color="red">mount -o remount, acl 挂载点</font></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;ACL是Access Control List（访问控制列表）的缩写，用于linux复杂的用户权限控制当中。&lt;/p&gt;
&lt;p&gt;Cent7系统之</summary>
      
    
    
    
    <category term="权限管理" scheme="http://eryoung2.github.io/categories/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux安装jdk8</title>
    <link href="http://eryoung2.github.io/2022/06/25/linux%E5%AE%89%E8%A3%85jdk8/"/>
    <id>http://eryoung2.github.io/2022/06/25/linux%E5%AE%89%E8%A3%85jdk8/</id>
    <published>2022-06-25T14:56:03.000Z</published>
    <updated>2022-07-27T07:32:10.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="1-下载安装包并上传"><a href="#1-下载安装包并上传" class="headerlink" title="1. 下载安装包并上传"></a>1. 下载安装包并上传</h4><h4 id="2-解压"><a href="#2-解压" class="headerlink" title="2.  解压"></a>2.  解压</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@home:/home/young# tar zxf jdk-8u131-linux-x64.tar.gz -C /usr/local/</span><br><span class="line">root@home:/home/young# mv /usr/local/jdk1.8.0_131/ /usr/local/java8</span><br></pre></td></tr></table></figure><h4 id="3-在-x2F-etc-x2F-profile添加项目"><a href="#3-在-x2F-etc-x2F-profile添加项目" class="headerlink" title="3. 在&#x2F;etc&#x2F;profile添加项目"></a>3. 在&#x2F;etc&#x2F;profile添加项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java8/</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="4-使-x2F-etc-x2F-profile生效"><a href="#4-使-x2F-etc-x2F-profile生效" class="headerlink" title="4. 使&#x2F;etc&#x2F;profile生效"></a>4. 使&#x2F;etc&#x2F;profile生效</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="5-验证jdk版本"><a href="#5-验证jdk版本" class="headerlink" title="5. 验证jdk版本"></a>5. 验证jdk版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;h4 id=&quot;1-下载安装包并上传&quot;&gt;&lt;a href=&quot;#1-下载安装包并上传&quot; class=&quot;headerlink&quot; title=&quot;1. 下载</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vim操作(第一弹)</title>
    <link href="http://eryoung2.github.io/2022/06/24/vim%E6%93%8D%E4%BD%9C-%E7%AC%AC%E4%B8%80%E5%BC%B9/"/>
    <id>http://eryoung2.github.io/2022/06/24/vim%E6%93%8D%E4%BD%9C-%E7%AC%AC%E4%B8%80%E5%BC%B9/</id>
    <published>2022-06-23T17:52:40.000Z</published>
    <updated>2022-06-23T17:54:51.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vi&#x2F;vim是unix&#x2F;linux操作系统下的文本编辑器。<br>由于unix&#x2F;linux万物届文件的特性，vi&#x2F;vim可以编辑任何格式的文件。<br>下面是常见的知识点，仅供参考。</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h4 id="编辑方式"><a href="#编辑方式" class="headerlink" title="编辑方式"></a>编辑方式</h4><p>vi&#x2F;vim + 文件路径。其中，文件路径可以是绝对路径，也可以是相对路径。如果这个文件不存在，就会新建一个文件。</p><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>vi&#x2F;vim常用的模式有两种：命令行模式和输入模式。</p><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p>由命令行模式切换到输入模式的命令：</p><ul><li><p>新增 (append)<br>a ：从光标所在位置後面开始新增资料，光标後的资料随新增资料向後移动。<br>A： 从光标所在列最後面的地方开始新增资料。</p></li><li><p>插入（insert）<br>i： 从光标所在位置前面开始插入资料，光标後的资料随新增资料向後移动。<br>I ：从光标所在列的第一个非空白字元前面开始插入资料。</p></li><li><p>开始(open)<br>o ：在光标所在列下新增一列并进入输入模式。<br>O: 在光标所在列上方新增一列并进入输入模式。</p></li><li><p>保存&#x2F;退出<br>在指令模式下键入:q,:q!,:wq或:x(注意:号），就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出，如果文件已有新的变化，vi会提示你保存文件而:q命令也会失效，这时你可以用:w命令保存文件后再用:q退出，或用:wq或:x命令退出，如果你不想保存改变后的文件，你就需要用:q!命令，这个命令将不保存文件而直接退出vi。</p></li><li><p>常用操作(命令行模式下)：<br>Ctrl+F：下翻一页<br>Ctrl+B:上翻一页<br>&#x2F;+单词：查找<br>dd：删除一行</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;vi&amp;#x2F;vim是unix&amp;#x2F;linux操作系统下的文本编辑器。&lt;br&gt;由于unix&amp;#x2F;linux万物届文件的特性，v</summary>
      
    
    
    
    <category term="编辑器" scheme="http://eryoung2.github.io/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
    <category term="vim" scheme="http://eryoung2.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从架构</title>
    <link href="http://eryoung2.github.io/2022/06/21/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"/>
    <id>http://eryoung2.github.io/2022/06/21/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/</id>
    <published>2022-06-21T01:39:46.000Z</published>
    <updated>2022-06-21T06:43:31.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mysql是我们经常使用的关系型数据库，在实际使用中，我们会使用单数据库，也会使用各种集群技术。其中最常用的是主从集群。</p><p>主从分很多种，一主一丛、双主、一主多从、多主多从等。其中主数据库可读可写，从机只读不写。</p><p>本文主要介绍前两种，主写从读和双主互备。</p><p>而这些方案实现的原理，则是binlog复制。</p><h2 id="Binlog复制"><a href="#Binlog复制" class="headerlink" title="Binlog复制"></a>Binlog复制</h2><p>Mysql有很多log，binlog是其中一种。当mysql执行了改动语句时，改动会被记录在binlog中，所以主从复制主要复制的就是这个binlog。</p><p>但具体来讲，Mysql主从复制涉及到三个线程：</p><p>1）主节点的log dump thread，给从库I&#x2F;O线程传Binlog数据</p><p>2）从节点的I&#x2F;O线程，会请求主库并将得到的Binlog写到本地的relay log中</p><p>3）从节点的SQL线程，会读取relay log中的日志，并解析成SQL语句进行同步</p><p>如下图所示：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/21-14-42-59-mysql-arch.png"></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>针对主从架构，我们准备两台机，并各自安装mysql server，端口3306.</p><table><thead><tr><th></th><th>主机</th><th>从机</th></tr></thead><tbody><tr><td>IP地址</td><td>192.168.1.150</td><td>192.168.1.113</td></tr><tr><td>用户</td><td>repl</td><td>repl</td></tr><tr><td>数据库</td><td>Test_DB</td><td>Test_DB</td></tr><tr><td>数据表</td><td>STUDENTS</td><td>STUDENTS</td></tr></tbody></table><p>由于这两台机是不同的系统，所以安装mysql这里就不展示了，我们直接开始数据库设置。</p><p>1）在两台数据库都创建Test_DB数据库和STUDENTS表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE Test_DB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> STUDENTS (  </span><br><span class="line">ID <span class="type">INT</span>                           <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">NAME <span class="type">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">AGE <span class="type">INT</span>                         <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">ADDRESS <span class="type">CHAR</span> (<span class="number">25</span>),  </span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (ID)  </span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>2）在两台数据库都创建复制用户，并赋权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;repl123&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>. <span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>3）在两台数据库打开binlog，在配置文件中添加，并添加bind-address，然后重启数据库</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log_bin</span>                 = <span class="string">mysql-bin</span></span><br><span class="line"><span class="attr">binlog_format</span>           = <span class="string">ROW</span></span><br><span class="line"><span class="attr">bind-address</span>            = <span class="string">0.0.0.0</span></span><br></pre></td></tr></table></figure><h2 id="互为主备or主写从读？"><a href="#互为主备or主写从读？" class="headerlink" title="互为主备or主写从读？"></a>互为主备or主写从读？</h2><h3 id="主写从读"><a href="#主写从读" class="headerlink" title="主写从读"></a>主写从读</h3><p>顾名思义，主写从读就是主库写，从库读取主库的binlog并备份。在对外提供服务的时候，应用向主库写入信息，可以从主库或从库读取。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/21-14-43-12-master-slave.png"></p><p>需要在从库的配置中添加只读选项，然后重启从库。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">read-only</span></span><br><span class="line"><span class="attr">super_read_only</span></span><br></pre></td></tr></table></figure><h3 id="互为主备"><a href="#互为主备" class="headerlink" title="互为主备"></a>互为主备</h3><p>不需要添加什么配置。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/21-14-43-24-master-master.png"></p><h2 id="binlog复制"><a href="#binlog复制" class="headerlink" title="binlog复制"></a>binlog复制</h2><h3 id="主写从读-1"><a href="#主写从读-1" class="headerlink" title="主写从读"></a>主写从读</h3><p>顾名思义，我们需要在从库同步主库的binlog状态，并开启同步。</p><p>1）首先，查询主库的binlog状态，找到file和position，这里file是mysql-bin.000009，Position是3205，代表主库目前的binlog位置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> master status\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">             File: mysql<span class="operator">-</span>bin<span class="number">.000009</span></span><br><span class="line">         Position: <span class="number">3205</span></span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>2）从库同步主库，并启动同步。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.150&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repl&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;repl123&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000009&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">3205</span>;</span><br><span class="line"><span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure><p>如果成功的话，查询slave状态如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave status\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> source <span class="keyword">to</span> send event</span><br><span class="line">                  Master_Host: <span class="number">192.168</span><span class="number">.1</span><span class="number">.150</span></span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: <span class="number">3306</span></span><br><span class="line">                Connect_Retry: <span class="number">60</span></span><br><span class="line">              Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000009</span></span><br><span class="line">          Read_Master_Log_Pos: <span class="number">3205</span></span><br><span class="line">               Relay_Log_File: node3<span class="operator">-</span>relay<span class="operator">-</span>bin<span class="number">.000002</span></span><br><span class="line">                Relay_Log_Pos: <span class="number">960</span></span><br><span class="line">        Relay_Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000009</span></span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>Slave_IO_Running和Slave_SQL_Running都是Yes，说明同步成功。</p><p>如果不成功的话，可以找找哪里出了问题，并停止同步，重新定位主库的binlog。</p><h3 id="互为主备-1"><a href="#互为主备-1" class="headerlink" title="互为主备"></a>互为主备</h3><p>其实互为主备比主写从读多一步，就是主库也要同步从库。</p><p>在主机上跑同步，file和position是从库的master状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.113&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repl&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;repl123&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000012&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">2920</span>;</span><br><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><p>在从库上也跑同步，file和position是主库的master状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.150&#x27;</span>,master_port<span class="operator">=</span><span class="number">3306</span>,master_user<span class="operator">=</span><span class="string">&#x27;repl&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;repl123&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000009&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">3205</span>;</span><br><span class="line"><span class="keyword">start</span> slave; </span><br></pre></td></tr></table></figure><p>这样互为主备就做好了。我们插入一条信息时，另外一库也会同步。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然，互为主备肯定有问题，那就是如果各种原因导致的主从复制失效，导致两个库的数据不同步、binlog不同步，这时候我们只有祭出恢复的方法了，比如把主库导入从库，或者从备份进行恢复且重新做同步，这就是另一个问题了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Mysql是我们经常使用的关系型数据库，在实际使用中，我们会使用单数据库，也会使用各种集群技术。其中最常用的是主从集群。&lt;/p&gt;
&lt;p&gt;主从</summary>
      
    
    
    
    <category term="数据库" scheme="http://eryoung2.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="http://eryoung2.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>hexo添加图床</title>
    <link href="http://eryoung2.github.io/2022/06/16/hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%BA%8A/"/>
    <id>http://eryoung2.github.io/2022/06/16/hexo%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%BA%8A/</id>
    <published>2022-06-16T15:10:16.000Z</published>
    <updated>2022-06-21T01:41:01.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果大家用过Markdown的话，就会知道在markdown里边插入图片时非常蛋疼，但凡换个地方来发布，图片就会404.</p><p>由于我最近在github pages上建了一个blog，我也遇到了这个问题，这时候就得找找办法。经过查询资料，我发现可以通过github创建图床来解决，效果不错。</p><p>当然，需要我们提前打开一个功能，在_config.yml中打开<strong>post_asset_folder</strong>, 将其置为true。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>顾名思义，图床就是对博客图片的集中管理。目前比较好用的应用有SM.MS、iPic、Picgo等。由于我这里使用MarkText来写博客，而MarkText也支持了创建图床的功能，故直接使用此功能来做图床。</p><h2 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h2><h3 id="1-在github上创建一个git仓库"><a href="#1-在github上创建一个git仓库" class="headerlink" title="1. 在github上创建一个git仓库"></a>1. 在github上创建一个git仓库</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-34-48-git.png"></p><h3 id="2-创建一个Access-token"><a href="#2-创建一个Access-token" class="headerlink" title="2. 创建一个Access token"></a>2. 创建一个Access token</h3><p>在”<strong>用户-Setting-Developer Settings</strong>“下建立一个access token，创建之后有一串密文，将其保存下来。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-35-02-token.png"></p><h3 id="3-在MarkText设置图床"><a href="#3-在MarkText设置图床" class="headerlink" title="3. 在MarkText设置图床"></a>3. 在MarkText设置图床</h3><p>打开MarkText的<strong>reference-image</strong>, 按如下内容做设置</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/06/16-23-35-24-setup.png"></p><p>然后就可以了。不得不说，挺好用的哈哈。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果大家用过Markdown的话，就会知道在markdown里边插入图片时非常蛋疼，但凡换个地方来发布，图片就会404.&lt;/p&gt;
&lt;p&gt;由于</summary>
      
    
    
    
    <category term="博客优化" scheme="http://eryoung2.github.io/categories/%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="hexo" scheme="http://eryoung2.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
