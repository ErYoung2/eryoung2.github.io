<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eryoung2的个人博客</title>
  
  <subtitle>ErYoung2写字的地方</subtitle>
  <link href="http://eryoung2.github.io/atom.xml" rel="self"/>
  
  <link href="http://eryoung2.github.io/"/>
  <updated>2023-03-11T09:23:00.624Z</updated>
  <id>http://eryoung2.github.io/</id>
  
  <author>
    <name>ErYoung2</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ACP云原生容器工程师 - ASK概述与产品介绍</title>
    <link href="http://eryoung2.github.io/2023/03/11/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ASK%E6%A6%82%E8%BF%B0%E4%B8%8E%E4%BA%A7%E5%93%81%E4%BB%8B%E7%BB%8D/"/>
    <id>http://eryoung2.github.io/2023/03/11/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ASK%E6%A6%82%E8%BF%B0%E4%B8%8E%E4%BA%A7%E5%93%81%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-03-11T07:35:23.000Z</published>
    <updated>2023-03-11T09:23:00.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Serverless基本概念"><a href="#Serverless基本概念" class="headerlink" title="Serverless基本概念"></a>Serverless基本概念</h3><p>对于传统云服务来说，我们需要购买的基础设施是服务器节点ECS，然后在ECS上自行部署应用或者部署其余付费应用，但是我们为了更好地适应应用的使用情况，有时并不需要ECS支持，这样可以更轻量地部署应用，成本也会更低。这就是阿里云无服务Kubernetes(ASK)的基本概念。</p><ul><li><p>特点：</p><ul><li><p>用户无需购买和管理服务器</p></li><li><p>直接部署容器应用</p></li><li><p>提高容器应用部署的敏捷度和弹性能力</p></li><li><p>降低用户计算成本</p></li><li><p>让用户聚焦业务应用</p></li></ul></li><li><p>优势：</p><ul><li><p>敏捷部署、安全隔离、生态链接、高移植性</p></li><li><p>无需节点容量规划</p></li><li><p>无需OS和系统软件维护</p></li><li><p>零基础设施运维</p></li><li><p>“无限”容量、秒级扩容、基于容器扩容</p></li><li><p>更高的资源利用率、更低计算成本</p></li></ul></li></ul><h3 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h3><ul><li><p>两种技术趋势的整合</p><ul><li><p>云平台托管的后台服务BaaS</p></li><li><p>无状态计算模型：函数服务FaaS</p></li></ul></li><li><p>Gartner</p><ul><li>到2023年，70% AI任务会通过容器、Serverless等计算模型构建</li></ul></li><li><p>AWS</p><ul><li>在2019年 40%的ECS新客户采用Serverless Container</li></ul></li><li><p>采纳Serverless技术的行业广泛</p><ul><li>外包经济、金融业、服务业</li></ul></li><li><p>Serverless是云计算必经的一场革命，会越来越流行</p></li></ul><h3 id="架构思考"><a href="#架构思考" class="headerlink" title="架构思考"></a>架构思考</h3><ul><li><p>Serverless场景的容器不是部署在传统的ECS上，而是部署在ECI上。然而ECS和ECI并不冲突，可以混合使用</p></li><li><p>不同于标准K8s，Serverless K8s与IaaS基础设施深度融合，其产品模式更利于公有云厂商通过技术创新，提升规模、效率和能力</p></li><li><p>Serverless也分成容器编排和计算资源池两层。</p></li><li><p>Serverless的几个技术要点：声明式API、可扩展性架构、可移植性</p></li></ul><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul><li><p>Serverless并不是一个单独的技术，必须兼容Kuubernetes生态，提供K8s的核心价值，此外要能和云的能力深度整合。</p></li><li><p>用户可以直接使用Kubernetes的声明式API，Deployment、StatefulSet、Job、Service等无需修改</p></li><li><p>全兼容Kuberenetes的扩展机制，这样才能让Serverless Kubernetes支持更多的工作负载，此外Serverless K8s自身的组件也是严格遵守K8s的状态逼近的控制模式</p></li><li><p>Kubernetes的能力尽可能充分利用云的能力来实现，比如资源的调度、负载均衡、服务发现等。根本性简化容器平台的设计，提升规模，降低用户运维复杂性</p></li><li><p>这些实现应该对用户透明，保证可移植性，让用户现有应用可以平滑部署在Serverless K8s之上，也应该允许用户应用混合部署在传统容器和Serverless容器之上</p></li></ul><h3 id="Nodeless"><a href="#Nodeless" class="headerlink" title="Nodeless"></a>Nodeless</h3><ul><li><p>对于传统的Kubernetes来说，采用以节点为中心的架构设计：</p><ul><li><p>节点是Pod的运行载体，Kubernetes调度器在工作节点池中选择合适的node来运行pod，并利用kubelet完成对pod进行生命周期管理和自动化运维</p></li><li><p>当节电池资源不够时，需要对节点池进行扩容，再对容器化应用进行扩容</p></li></ul></li><li><p>对于Serverless Kubernetes来说</p><ul><li><p>没有节点这个概念</p></li><li><p>容器化应用是一等公民</p></li><li><p>极大简化容器弹性实现，无需按照容量规划，按需创建容器应用pod即可</p></li><li><p>Serverless容器运行时可以被整个晕弹性计算基础设施所支撑，保障整体弹性的成本和规模</p></li></ul></li></ul><h3 id="现有产品的架构"><a href="#现有产品的架构" class="headerlink" title="现有产品的架构"></a>现有产品的架构</h3><h4 id="初始架构-Viking"><a href="#初始架构-Viking" class="headerlink" title="初始架构-Viking"></a>初始架构-Viking</h4><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/11-16-21-12-%E6%88%AA%E5%B1%8F2023-03-11%2016.20.47.png"></p><h4 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h4><ol><li><p>可伸缩性 - ECI</p></li><li><p>基于云的控制器实现 - PrivateZone、SLB、SLB&#x2F;ALB</p></li><li><p>面向负载的深度优化 - Knative、垂直优化</p></li></ol><h2 id="ASK产品介绍"><a href="#ASK产品介绍" class="headerlink" title="ASK产品介绍"></a>ASK产品介绍</h2><ul><li><p>是阿里云推出的无服务器Kubernetes容器服务</p></li><li><p>无需购买节点即可直接部署容器应用，无需对集群进行节点维护和容量规划，并且饿根据应用配置的CPU和内存资源量进行按需付费（非包年包月，因为没有制程规格的节点）</p></li><li><p>提供完善的Kubernetes兼容能力，同时降低了Kubernetes使用门槛，更专注于应用本身，而不是基础设施</p></li><li><p>ASK集群中的Pod给予阿里云弹性容器实例ECI运行在安全隔离的容器运行环境中</p></li><li><p>每个Pod容器实例底层通过轻量级虚拟化安全沙箱技术完全抢格力，容器实例间互不影响。</p></li></ul><h3 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h3><ol><li><p>简单易用：无门槛，秒级部署容器应用</p></li><li><p>秒级伸缩：无需担心集群容量规划</p></li><li><p>安全隔离：通敌底层沙箱进行强安全隔离</p></li><li><p>降低成本：按需计费，无资源闲置费用</p></li><li><p>原生兼容：支持原生k8s应用和生态，service、helm、ingress等</p></li><li><p>服务集成：支持与其他云组件(数据库、vpc中现有应用直接交汇)</p></li></ol><h3 id="无节点管理-nodeless"><a href="#无节点管理-nodeless" class="headerlink" title="无节点管理(nodeless)"></a>无节点管理(nodeless)</h3><ul><li><p>更多专注于应用的开发，而不是基础设施的维护。更多关注pod&#x2F;service&#x2F;ingress&#x2F;job等应用编排语义上，更少对底层node进行关注。</p></li><li><p>无需管理节点也可以显著降低集群的运维管理成本，比如node的安全管理、监控&#x2F;日志管理、基础系统软件的升级和维护</p></li><li><p>在ASK集群中，我们使用虚拟节点virtual-kubelet代替ECS节点，此virtual-kubelet节点的容量可以认为是“无限大”，用户无需为集群的容量担忧，无需预先做容量规划</p></li></ul><h3 id="Serverless-kubernetes-vs-Classic-Kubernetes"><a href="#Serverless-kubernetes-vs-Classic-Kubernetes" class="headerlink" title="Serverless kubernetes vs Classic Kubernetes"></a>Serverless kubernetes vs Classic Kubernetes</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/11-16-38-33-%E6%88%AA%E5%B1%8F2023-03-11%2016.38.25.png"></p><h3 id="无Master管理与极简的K8s"><a href="#无Master管理与极简的K8s" class="headerlink" title="无Master管理与极简的K8s"></a>无Master管理与极简的K8s</h3><ul><li><p>与ACK托管版一样，ASK的Master等资源(apiserver, ccm, kcm等)被容器服务平台托管，用户无需管理这些核心组件的升级和运维，也不需要成本</p></li><li><p>ASK对Kubernetes进行大量简化，包括默认托管很多addon，用户无需在管理一些基础的addon，也不需要对此付费</p></li><li><p>依赖阿里元原生的网络和存储等能力，以及独特的托管架构设计，ASK提供了极简但功能完备的Kubernetes基础运行环境</p></li></ul><h3 id="简化弹性伸缩"><a href="#简化弹性伸缩" class="headerlink" title="简化弹性伸缩"></a>简化弹性伸缩</h3><ul><li><p>因为无需管理节点和容量规划，当集群需要扩容时也就不需要考虑节点层面的扩容，只需要关注pod的扩容，这对于扩容的速度和效率都是极大的提升</p></li><li><p>ASK&#x2F;ECI的方式被刻意用来快速应对业务流量高峰</p></li><li><p>当前ASK&#x2F;ECI支持30s完全启动500个pod，单个pod启动可以达到10s以内</p></li></ul><h3 id="更低的成本"><a href="#更低的成本" class="headerlink" title="更低的成本"></a>更低的成本</h3><ul><li><p>除去ASK集群本身的低成本创建外，pod的按需使用也让很多场景下资源利用率达到最优。对于很多Jobs或者数据计算场景而言，用户并不需要长期维护一个固定的资源池，这时ASK&#x2F;ECI可以很好地支持这些诉求</p></li><li><p>若pod一天运行少于16小时，使用ASK更加经济实惠；若超过16小时，使用ACK更加经济实惠。</p></li></ul><h3 id="ECI-快速交付容器资源的弹性计算服务"><a href="#ECI-快速交付容器资源的弹性计算服务" class="headerlink" title="ECI: 快速交付容器资源的弹性计算服务"></a>ECI: 快速交付容器资源的弹性计算服务</h3><ul><li><p>ECI是阿里云基于ECS IaaS资源池提供的稳定、高效、高弹性容器实例服务</p></li><li><p>ECI让容器成为了公有云的一等公民，用户无需购买和管理ECS就可以直接部署容器应用，这种假话的容器实例产品形态和ASK形成了一个完美地组合</p></li><li><p>用户可以直接使用ECI Open API创建容器资源实例，但在容器场景中用户普遍需要一个编排系统，来负责容器的调度、高可用编排等能力，而ASK正式这样的Kubernetes编排层。</p></li><li><p>对于ASK而言</p><ul><li><p>ECI让ASK容器服务免去了搭建后台计算资源池的必要，更不用为底层计算资源池的容量而担忧</p></li><li><p>基于ECI就意味着基于整个阿里云IaaS规模化资源池，天然拥有了库存和弹性优势</p></li><li><p>另外ECI和ECS复用资源池意味着 我们可以最大化释放规模化红利，给用户提供更低成本的计算服务</p></li></ul></li></ul><h3 id="容器生态支持"><a href="#容器生态支持" class="headerlink" title="容器生态支持"></a>容器生态支持</h3><ul><li><p>ASK比较适合的场景：</p><ul><li><p>CI&#x2F;CD</p></li><li><p>数据计算</p></li><li><p>AI</p></li><li><p>ServiceMesh</p></li><li><p>测试</p></li></ul></li><li><p>ASK集群不支持Helm v2，近期ACK&#x2F;ASK会发布Helm v3的支持，之后用户可以非常方便地在ASK集群中部署Charts</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>ASK基本概念</p></li><li><p>ASK产品介绍</p></li><li><p>ASK优势</p></li><li><p>ASK架构介绍与思考</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;Serverless基本概念&quot;&gt;&lt;a href=&quot;#Serverless基本概念&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - ACK应用与发布管理</title>
    <link href="http://eryoung2.github.io/2023/03/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8F%91%E5%B8%83%E7%AE%A1%E7%90%86/"/>
    <id>http://eryoung2.github.io/2023/03/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E5%BA%94%E7%94%A8%E4%B8%8E%E5%8F%91%E5%B8%83%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-10T06:44:25.000Z</published>
    <updated>2023-03-10T07:28:35.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ACK应用与发布管理包括4种方式：</p><ul><li><p>灰度发布</p></li><li><p>手动发布</p></li><li><p>自动发布</p></li><li><p>Helm发布</p></li></ul><h2 id="灰度发布-又名金丝雀发布"><a href="#灰度发布-又名金丝雀发布" class="headerlink" title="灰度发布(又名金丝雀发布)"></a>灰度发布(又名金丝雀发布)</h2><h3 id="灰度发布概念"><a href="#灰度发布概念" class="headerlink" title="灰度发布概念"></a>灰度发布概念</h3><ul><li><p>灰度发布是将应用的旧版本A与新版本B同时部署在环境中，业务请求可能会被路由到版本A或者版本B的后端上，您可以自定义灰度发布策略，快速调整版本A和版本B的流量占比。</p></li><li><p>灰度发布可以再发布新版本应用时：</p><ul><li><p>自定义控制新版本应用流量比重</p></li><li><p>渐进式完成新版本应用的全量上线</p></li><li><p>最大限度地控制新版本发布带来的业务风险，降低故障带来的影响</p></li><li><p>同时支持快速回滚</p></li></ul></li></ul><h3 id="灰度发布实现"><a href="#灰度发布实现" class="headerlink" title="灰度发布实现"></a>灰度发布实现</h3><p>灰度发布是可以帮助您渐进式更新Deployment的工具</p><ul><li><p>他能结合路由控制器Ingress Controller实现多版本并存，发布暂停、流量百分比切换、健康检查等功能</p></li><li><p>极大解放灰度发布过程中的手动操作，全自动化实现线上灰度流量切换</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/10-15-07-11-%E6%88%AA%E5%B1%8F2023-03-10%2015.06.34.png"></p><h3 id="安装灰度发布组件"><a href="#安装灰度发布组件" class="headerlink" title="安装灰度发布组件"></a>安装灰度发布组件</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/10-15-07-22-%E6%88%AA%E5%B1%8F2023-03-10%2015.06.51.png"></p><h2 id="手动发布"><a href="#手动发布" class="headerlink" title="手动发布"></a>手动发布</h2><ul><li><p>在使用灰度发布的手动发布方式的时候，您需要创建一个Ingress、Service和Deployment结构的应用。</p></li><li><p>目前灰度发布只支持基于Deployment和Ingress的灰度发布流程。</p></li></ul><h3 id="手动发布流程"><a href="#手动发布流程" class="headerlink" title="手动发布流程"></a>手动发布流程</h3><ol><li><p>创建测试应用：可使用YAML文件来创建Deployment、Ingress向外暴露服务</p></li><li><p>创建灰度发布：创建灰度发布时，设置上述创建的Deployment、Service、Ingress，然后设置发布方式为手动发布</p></li><li><p>执行灰度发布：</p><ul><li><p>初始化完毕后，就可以进行灰度发布</p></li><li><p>开始灰度发布前，您需要更新应用</p></li></ul></li><li><p>查看历史记录：在灰度发布页面的历史记录区域，您可以查看所有创建的灰度发布的发布记录，在每个创建的灰度发布详情页面下方的发布日志区域，查看发布过程。</p></li></ol><h2 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h2><p>自动发布模式可以让您全自动化地完成灰度发布流程。</p><h3 id="自动发布流程"><a href="#自动发布流程" class="headerlink" title="自动发布流程"></a>自动发布流程</h3><ol><li><p>创建测试应用：可使用YAML文件来创建Deployment、Ingress向外暴露服务</p></li><li><p>创建灰度发布：创建灰度发布时，设置上述创建的Deployment、Service、Ingress，然后设置发布方式为自动发布，然后灰度发布即可自动运行。</p></li><li><p>查看历史记录：在灰度发布页面的历史记录区域，您可以查看所有创建的灰度发布的发布记录，在每个创建的灰度发布详情页面下方的发布日志区域，查看发布过程。</p></li></ol><h2 id="基于Helm的发布管理"><a href="#基于Helm的发布管理" class="headerlink" title="基于Helm的发布管理"></a>基于Helm的发布管理</h2><ul><li><p>阿里云Kubernetes服务集成了Helm包管理工具，帮助您快速构建云上应用，因为chart可以多次发布，这就带来一个发布版本管理的问题</p></li><li><p>因此，阿里云Kubernetes提供了发布功能，通过Web界面的方式对通过Helm发布的应用进行管理。</p></li></ul><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li><p>已经成功创建一个Kubernetes集群</p></li><li><p>已开通了应用目录或者服务目录功能，安装了Helm应用</p></li></ul><h3 id="查看发布详情"><a href="#查看发布详情" class="headerlink" title="查看发布详情"></a>查看发布详情</h3><ol><li><p>登录容器服务管理控制台</p></li><li><p>在控制台左侧导航栏中，单击集群</p></li><li><p>在集群列表页面中，单击目标集群名称或者目标集群右侧操作栏下的详情</p></li><li><p>在集群管理业左侧导航栏中，单击应用</p></li><li><p>单击Helm页签，进入发布列表页面</p></li><li><p>查看发布的详情信息，单击右侧的详情，进入该发布的详情页面</p></li><li><p>单击参数页签，您可查看该Helm包的参数设置</p></li></ol><h3 id="发布更新的版本"><a href="#发布更新的版本" class="headerlink" title="发布更新的版本"></a>发布更新的版本</h3><ol><li><p>在控制台左侧导航栏中，单击集群</p></li><li><p>在集群列表页面中，单击目标集群名称或者目标集群右侧操作栏下的详情</p></li><li><p>在集群管理业左侧导航栏中，单击应用</p></li><li><p>单击Helm页签，进入发布列表页面</p></li><li><p>您可更新该发布，单击右侧的更新，弹性更新发布对话框</p></li><li><p>在更新发布对话框中修改相关参数，随后单击更新，可对该发布进行更新</p></li></ol><h3 id="发布回滚"><a href="#发布回滚" class="headerlink" title="发布回滚"></a>发布回滚</h3><ol><li><p>单击Helm页签，进入发布列表页面</p></li><li><p>您可删除该发布，单击右侧的删除</p></li><li><p>在删除应用对话框中，勾选是否清楚发布记录，然后单击确定，可将应用、服务、部署一并删除。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ACK应用与发布管理包括4种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;灰度发布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手动发布&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - 安全管理</title>
    <link href="http://eryoung2.github.io/2023/03/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://eryoung2.github.io/2023/03/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-10T05:25:49.000Z</published>
    <updated>2023-03-10T05:44:18.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阿里云容器服务ACK安全体系"><a href="#阿里云容器服务ACK安全体系" class="headerlink" title="阿里云容器服务ACK安全体系"></a>阿里云容器服务ACK安全体系</h2><ul><li><p>阿里云容器服务Kubernetes版安全体系</p><ul><li><p>提供从基础设施到上层用户业务应用全链条安全体系支撑</p></li><li><p>支持运行时刻的安全策略管理，应用安全配置巡检和运行时刻的安全监控和告警</p></li><li><p>提升容器安全整体纵深防御能力</p></li></ul></li><li><p>主要分为3个层级：运行时安全、可信软件供应链、基础架构安全</p></li></ul><h2 id="基础架构安全"><a href="#基础架构安全" class="headerlink" title="基础架构安全"></a>基础架构安全</h2><ul><li><p>从公有云、专有云、混合云等多角度覆盖</p></li><li><p>通过集群安全加固、身份验证管理、细粒度安全访问控制、集群日志审计、敏感数据加密等多个环节保障集群基础设施安全稳定高效运行</p></li><li><p>与ACK&#x2F;SLS深度绑定，可查询多维度的日志信息，以进行审计</p></li><li><p>KMS保证敏感数据安全加密</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/10-13-42-58-%E6%88%AA%E5%B1%8F2023-03-10%2013.42.46.png"></p><h2 id="可信软件供应链"><a href="#可信软件供应链" class="headerlink" title="可信软件供应链"></a>可信软件供应链</h2><ul><li><p>安全是企业在应用容器技术时最大的顾虑之一</p></li><li><p>为了系统化提升容器平台的安全性，就需要全方位进行安全防护</p></li><li><p>阿里云的做法是：</p><ul><li><p>将DevOps升级为DevSecOps</p></li><li><p>将安全概念融入整个软件生命周期之中</p></li><li><p>将安全防护能力转移到开发和交互阶段</p></li></ul></li><li><p>安全措施包括：镜像扫描、镜像签名、云原生应用交付链</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/10-13-42-23-%E6%88%AA%E5%B1%8F2023-03-10%2013.38.02.png"></p><h2 id="运行时安全"><a href="#运行时安全" class="headerlink" title="运行时安全"></a>运行时安全</h2><ul><li><p>安全巡检：ACK集群提供了应用运行时刻的安全配置巡检能力，帮您实时了解当前转台下运行应用的配置是否存在安全隐患</p></li><li><p>策略管理：安全策略PSP时Kubernetes中Pod部署时重要的安全校验手段，能够有效地约束应用运行时的行为安全</p></li><li><p>运行时监控和告警：阿里云容器服务和云安全中心深度集成了告警处理和漏洞检测能力，在应用运行时提供监控和告警能力</p></li><li><p>安全沙箱管理：安全沙箱为您提供一种新的容器运行时选项，可以让您的应用运行在一个轻量虚拟机沙箱环境中，拥有独立的内核、具备更好的安全隔离能力</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阿里云容器服务ACK安全体系&quot;&gt;&lt;a href=&quot;#阿里云容器服务ACK安全体系&quot; class=&quot;headerlink&quot; title=&quot;阿里云容器服务ACK安全体系&quot;&gt;&lt;/a&gt;阿里云容器服务ACK安全体系&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;阿里云容器服务Kubern</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - 集群管理</title>
    <link href="http://eryoung2.github.io/2023/03/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/"/>
    <id>http://eryoung2.github.io/2023/03/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-09T16:48:39.000Z</published>
    <updated>2023-03-10T06:43:28.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集群升级"><a href="#集群升级" class="headerlink" title="集群升级"></a>集群升级</h2><ul><li><p>可以通过容器服务控制台，可视化升级集群的Kubernetes版本</p></li><li><p>可以在kuberenetes集群列表页面查看集群的Kubernetes版本，以及当前是否有新的版本可供升级。升级集群的过程包含前置检查、升级Master、升级Node</p></li><li><p>集群升级策略：</p><ul><li><p>定义了您将使用怎样的策略对集群进行升级</p></li><li><p>默认策略为分批升级</p></li><li><p>升级Node阶段对集群内的节点进行分批升级，具体策略为：</p><ol><li><p>第一批升级的节点数为1，后续的批次为2的幂数进行增长。暂停后重新恢复升级的第一批次为1，后续也是以2的幂数进行增长。</p></li><li><p>每一批节点的最大数量不会超过节点总数的10%</p></li></ol></li></ul></li><li><p>集群升级前置检查在您开始集群升级之后，ACK会为您自动启动集群升级前置检查</p></li><li><p>该检查会对集群进行多项健康检查，以确保您的集群可以顺利的完成此次升级</p></li><li><p>如果您的集群存在不合理配置或潜在风险，将无法通过前置检查。</p></li><li><p>集群可以升级暂停或者升级停止，已完成的节点就升级完毕了，未升级的节点不升级。</p></li></ul><h2 id="管理维护组件步骤"><a href="#管理维护组件步骤" class="headerlink" title="管理维护组件步骤"></a>管理维护组件步骤</h2><ol><li><p>登录容器管理控制台</p></li><li><p>在控制台左侧导航栏中，单击集群</p></li><li><p>在集群列表页面，选择目标肌群，并在目标集群右侧操作列下，选择更多-系统组件管理</p></li><li><p>在组件管理页面，您可以：</p><ul><li><p>选择需要安装的组件，单击安装</p></li><li><p>选择需要卸载的组件，单击卸载</p></li><li><p>选择需要升级的组件，单击升级</p></li></ul></li></ol><p>组件主要包含：核心组件、存储组件、应用管理组件、网络组件、日志与监控组件、安全组件、其他组件</p><ul><li>核心组件无法卸载！</li></ul><h2 id="扩容集群步骤"><a href="#扩容集群步骤" class="headerlink" title="扩容集群步骤"></a>扩容集群步骤</h2><ol><li><p>登录容器服务管理控制台</p></li><li><p>在控制台左侧导航栏中，单击集群</p></li><li><p>在集群列表页面，选择目标集群，并在目标集群右侧操作列下，选择更多-集群扩容</p></li><li><p>在集群扩容页面进行扩容配置</p></li><li><p>根据业务需求扩容所需要的节点配置</p></li><li><p>配置内容与Worker节点配置一致</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集群升级&quot;&gt;&lt;a href=&quot;#集群升级&quot; class=&quot;headerlink&quot; title=&quot;集群升级&quot;&gt;&lt;/a&gt;集群升级&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以通过容器服务控制台，可视化升级集群的Kubernetes版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以在</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - ACK自动伸缩</title>
    <link href="http://eryoung2.github.io/2023/03/09/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E8%87%AA%E5%8A%A8%E4%BC%B8%E7%BC%A9/"/>
    <id>http://eryoung2.github.io/2023/03/09/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E8%87%AA%E5%8A%A8%E4%BC%B8%E7%BC%A9/</id>
    <published>2023-03-09T05:59:48.000Z</published>
    <updated>2023-03-09T06:22:18.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>弹性伸缩是ACK特点功能之一，典型的场景包括：</p><ul><li><p>在线业务弹性</p></li><li><p>大规模计算训练</p></li><li><p>定时周期性负载变化等</p></li></ul><p>弹性伸缩分为两个维度：</p><ul><li><p>弹性调度层：主要负责修改负载的调度容量变化，在已有资源条件下进行pod调度</p></li><li><p>资源弹性层：主要负责扩充资源的方式调度容量的补充，对资源本社进行调度</p></li></ul><h2 id="资源层阶段弹性提供"><a href="#资源层阶段弹性提供" class="headerlink" title="资源层阶段弹性提供"></a>资源层阶段弹性提供</h2><ul><li><p>阿里云Kubernetes集群的一个重要特性，是集群的节点可以动态的增加或减少</p></li><li><p>有了这个特性，集群才能在计算资源不足的情况下扩充新的节点</p></li><li><p>同时，也可以在资源利用率降低的时候，释放节点以节省费用</p></li><li><p>资源层扩缩容可以分为：手动扩缩容、自动扩缩容</p></li></ul><h3 id="资源层弹性插件"><a href="#资源层弹性插件" class="headerlink" title="资源层弹性插件"></a>资源层弹性插件</h3><ul><li><p>Cluster-autoscaler: Kubernetes社区开源组件，节点水平伸缩软件，阿里云提供了独有的调度、弹性优化、成本优化的功能。</p></li><li><p>Virtual-node: ACK开源插件，提供无服务器运行时环境，开发者无需挂心节点资源，只需针对Pod按量付费即可。</p></li><li><p>Virtual-kubelet-autoscaler: ACK服务组件，提供无服务弹性伸缩能力</p></li></ul><h2 id="节点自动伸缩"><a href="#节点自动伸缩" class="headerlink" title="节点自动伸缩"></a>节点自动伸缩</h2><h3 id="节点自动伸缩机制"><a href="#节点自动伸缩机制" class="headerlink" title="节点自动伸缩机制"></a>节点自动伸缩机制</h3><p>定期检测集群中应用pod的状态，如果处于pending状态且日志中出现调度原因不足时，会触发cluster-autoscaler的模拟调度，会在各node中查询哪台机可以负载新的pod，如果有就分配；如果没有就触发资源调度，实现资源级别的自动伸缩。</p><h3 id="节点自动伸缩实现原理"><a href="#节点自动伸缩实现原理" class="headerlink" title="节点自动伸缩实现原理"></a>节点自动伸缩实现原理</h3><ul><li><p>阿里云容器服务ACK的自动伸缩能力，是通过节点自动伸缩组件(cluster-autoscaler)实现的。</p></li><li><p>可以按需弹出普通实例、GPU实例、竞价付费实例、支持多可用区、多实例规格、多种伸缩模式、满足不同的节点伸缩场景。</p><ul><li><p>伸缩配置：通过控制台配置伸缩节点的规格属性</p></li><li><p>自动伸缩组件监听：自动伸缩组件cluster-autoscaler，它以Pod的形式运行在K8S集群中、监听Pod状态，在Pod因为节点资源不足而不能被调度的状态时，启动自动伸缩规则</p></li><li><p>伸缩规则启动：根据伸缩配置的内容，启动ESS弹性伸缩服务</p></li><li><p>ESS弹性伸缩服务创建实例：通过ESS他行设所服务按照配置创建实例后，继续进行集群监听</p></li></ul></li></ul><h3 id="节点自动伸缩操作"><a href="#节点自动伸缩操作" class="headerlink" title="节点自动伸缩操作"></a>节点自动伸缩操作</h3><p>可分为3个步骤：</p><ul><li>执行自动伸缩</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-20-58-%E6%88%AA%E5%B1%8F2023-03-09%2014.03.14.png"></p><ul><li>弹性伸缩服务ESS授权</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-21-12-%E6%88%AA%E5%B1%8F2023-03-09%2014.03.33.png"></p><ul><li>配置自动伸缩</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-21-29-%E6%88%AA%E5%B1%8F2023-03-09%2014.08.32.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-21-40-%E6%88%AA%E5%B1%8F2023-03-09%2014.04.24.png"></p><ul><li>查看结果</li></ul><h2 id="调度层弹性伸缩"><a href="#调度层弹性伸缩" class="headerlink" title="调度层弹性伸缩"></a>调度层弹性伸缩</h2><h3 id="调度层弹性介绍"><a href="#调度层弹性介绍" class="headerlink" title="调度层弹性介绍"></a>调度层弹性介绍</h3><ul><li><p>调度层弹性组件是指所有的弹性动作都是和pod相关的，并不关心具体的资源情况。</p></li><li><p>调度层弹性组件包括：容器水平伸缩(HPA)，容器垂直伸缩(VPA)，容器定时伸缩(CronHPA)</p></li></ul><h3 id="调度层弹性组件"><a href="#调度层弹性组件" class="headerlink" title="调度层弹性组件"></a>调度层弹性组件</h3><ul><li><p>HPA: Pod水平伸缩的组件</p><ul><li><p>除了社区支持的Resource Metrics和CustomMetrics，阿里云容器服务Kuberenetes还提供了external-metrics-adapter</p></li><li><p>支持云服务的指标作为弹性伸缩的判断条件</p></li><li><p>目前已经支持例如Ingress的QPS、RT等监控指标</p></li></ul></li><li><p>VPA：Pod的纵向伸缩的最贱，主要面向有状态服务的扩容和升级场景，用于大型单体应用</p></li><li><p>CronHPA：定时伸缩组件，主要面向的是周期性负载，通过资源画像可以预测有规律的负载周期，并通过周期性伸缩，实现资源成本的节约</p></li></ul><h3 id="调度层弹性组件使用场景及限制"><a href="#调度层弹性组件使用场景及限制" class="headerlink" title="调度层弹性组件使用场景及限制"></a>调度层弹性组件使用场景及限制</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-21-52-%E6%88%AA%E5%B1%8F2023-03-09%2014.04.24.png"></p><p>通常使用HPA+AutoScaler进行两层扩容，HPA负载容量管理，AutoScaler负责资源池的所扩容</p><h2 id="ACK开启HPA"><a href="#ACK开启HPA" class="headerlink" title="ACK开启HPA"></a>ACK开启HPA</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-22-05-%E6%88%AA%E5%B1%8F2023-03-09%2014.04.32.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/03/09-14-22-13-%E6%88%AA%E5%B1%8F2023-03-09%2014.04.38.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>阿里云容器服务ACK弹性伸缩分为两个维度：</p><ul><li><p>调度层弹性：主要负责修改负载的调度容量变化</p></li><li><p>资源层调度：主要是集群的容量规划不能满足集群调度容量时，会通过扩充资源的方式进行调度容量的补充</p></li></ul></li><li><p>阿里云容器服务Kubernetes弹性调度资源：</p><p>通过调度与资源解耦的两层弹性模型来解决的，当集群的调度水位达到设置的阈值时会触发资源蹭的弹性扩容，当资源弹出后，无法调度的单元会自动调度到新弹出的节点上，从而降低整个应用的负载情况</p></li><li><p>阿里云容器服务ACK集群调度层弹性组件：</p><ul><li><p>容器水平伸缩(HPA)</p></li><li><p>容器垂直伸缩(VPA)</p></li><li><p>容器定时伸缩(CronHPA)</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;弹性伸缩是ACK特点功能之一，典型的场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在线业务弹性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大规模计算训</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客迁移 from mac to mac</title>
    <link href="http://eryoung2.github.io/2023/03/08/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB-from-mac-to-mac/"/>
    <id>http://eryoung2.github.io/2023/03/08/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB-from-mac-to-mac/</id>
    <published>2023-03-08T15:34:54.000Z</published>
    <updated>2023-03-08T15:49:44.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>前段时间我的MBP15留在家里给老妈做视频播放器了，这段时间重新收了一台Mac mini来使用。由于前一台电脑大部分内容均已备份，剩余的东西也就是此博客，所以我就把它放在iCloud里边，一并同步过来了。</p><p>但是我发现这个迁移也会遇到些蛋疼的问题，我们一个一个来说。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-node-modules依赖太多"><a href="#1-node-modules依赖太多" class="headerlink" title="1. node_modules依赖太多"></a>1. node_modules依赖太多</h3><p>我们都知道，对于hexo来说，它是用nodejs来搭建的，所以会有超多的小文件在node_modules下面。而我遇到的第一个问题则是，iCloud同步小文件时非常、非常、非常慢。</p><p>这个问题也好解决，把博客打个包然后拷贝出来就行了。可以直接使用Mac的实用工具进行打包，做完以后是一个zip文件，然后将其拷贝出来即可。</p><h3 id="2-node没安装"><a href="#2-node没安装" class="headerlink" title="2. node没安装"></a>2. node没安装</h3><p>由于我只是备份了文档，应用并未安装，所以需要重新安装nodejs。</p><p>这里可以移步官网，自行下载相应版本并进行安装，安装之后在terminal输入<strong>node -v</strong>进行验证。</p><h3 id="3-hexo组件未安装"><a href="#3-hexo组件未安装" class="headerlink" title="3. hexo组件未安装"></a>3. hexo组件未安装</h3><p>在解压并进入博客目录后，会发现大部分的内容是在的，只是hexo相关组件还未安装。</p><p>可以删除掉node_modules文件夹和package-lock.json文件，并重新安装hexo插件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules package-lock.json</span><br><span class="line">sudo npm install --unsafe-perm --verbose -g hexo  </span><br></pre></td></tr></table></figure><p>安装完毕之后，可使用hexo g或者hexo s进行测试，一般就ok的了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>此法用于Mac-&gt;Mac迁移，Mac-&gt;Windows会麻烦一些，之前我也做过一次，太蛋疼了，虽然成功了，但是还是不推荐这么迁移。</p><h2 id="引用与鸣谢"><a href="#引用与鸣谢" class="headerlink" title="引用与鸣谢"></a>引用与鸣谢</h2><blockquote><p>nodejs官网 <a href="https://nodejs.org/en/">Node.js</a></p><p><a href="https://gwang-cv.github.io/2017/08/25/%E5%AE%89%E8%A3%85Hexo%E7%9A%84%E9%97%AE%E9%A2%98/">安装Hexo的问题 | my lab</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;前段时间我的MBP15留在家里给老妈做视频播放器了，这段时间重新收了一台Mac mini来使用。由于前一台电脑大部分内容均已备份，剩余的东西</summary>
      
    
    
    
    <category term="博客迁移" scheme="http://eryoung2.github.io/categories/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    
    
    <category term="hexo" scheme="http://eryoung2.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - 日志与监控</title>
    <link href="http://eryoung2.github.io/2023/03/08/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E6%97%A5%E5%BF%97%E4%B8%8E%E7%9B%91%E6%8E%A7/"/>
    <id>http://eryoung2.github.io/2023/03/08/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E6%97%A5%E5%BF%97%E4%B8%8E%E7%9B%91%E6%8E%A7/</id>
    <published>2023-03-08T04:34:04.000Z</published>
    <updated>2023-03-08T04:35:24.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阿里云的可观测性体系： 日志管理、监控管理</p><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="Kubernetes可观测性体系概述"><a href="#Kubernetes可观测性体系概述" class="headerlink" title="Kubernetes可观测性体系概述"></a>Kubernetes可观测性体系概述</h3><ul><li><p>可观测性指如何从外部输出推测及衡量体系内部状态</p></li><li><p>Kubernetes可观测性体系包括：监控和日志，是大型分布式系统的重要基础设施</p><ul><li>监控可以帮助开发者插卡系统的运行状态</li><li>日志可以协助问题的排查和诊断</li><li>在Kubernetes中，监控和日志属于生态的一部分，他并不是核心组件，因此大部分的能力依赖上层的云厂商的适配。</li><li>Kubernetes定义了介入的接口标准和规范，任何符合接口的组件都可以快速集成。</li></ul></li><li><p>Logging-日志</p><ul><li>基于阿里云日志服务SLS提供了完整的日志方案，可以对应用日志进行收集、处理，并提供了操作审计，kubernetes事件中心等能力。</li></ul></li><li><p>Metrics-监控指标</p><ul><li>对基础设施服务(比如ECS、存储、网络)，云监控提供了全面的监控。</li><li>对于业务应用的性能指标，ARMS无需修改业务代码即可对Java和PHP应用提供全方位的性能监控。</li></ul></li><li><p>Tracing-全链路追踪</p><ul><li>Tracing Analysis为开发者提供了完整的分布式应用调用链路统计、拓扑分析等工具。</li><li>能够帮助开发者快速发现和诊断分布式应用中的性能瓶颈，提升微服务应用的性能和稳定性。</li></ul></li></ul><h3 id="Kubernetes日志使用场景"><a href="#Kubernetes日志使用场景" class="headerlink" title="Kubernetes日志使用场景"></a>Kubernetes日志使用场景</h3><p>Kubernetes日志使用场景主要分为四个大的场景：</p><ul><li>主机内核的日志： 协助开发者进行一些常见的问题与诊断：网络栈异常、驱动异常、文件系统异常、影像节点（内核）稳定的异常。</li><li>Runtime日志：主要包括Docker日志</li><li>核心组件的日志：APIServer日志可以用来审计，Scheduler日志可以诊断调度，etcd日志可以查看存储状态，Ingress日志可以分析接入层流量</li><li>部署应用的日志：可以通过应用日志分析插卡业务层的状态，状态异常。</li></ul><h3 id="Kubernetes日志的采集"><a href="#Kubernetes日志的采集" class="headerlink" title="Kubernetes日志的采集"></a>Kubernetes日志的采集</h3><p>从采集位置上划分，主要分为三种：</p><ul><li>宿主机文件</li><li>容器内文件</li><li>容器标准&#x2F;错误输出</li></ul><h3 id="阿里云ACK日志服务"><a href="#阿里云ACK日志服务" class="headerlink" title="阿里云ACK日志服务"></a>阿里云ACK日志服务</h3><p>可创建两种日志：</p><ul><li>集群日志服务</li><li>应用配置日志服务</li></ul><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="监控类型"><a href="#监控类型" class="headerlink" title="监控类型"></a>监控类型</h3><p>从监控类型上划分，在Kubernetes中可以分成4个不同的类型:</p><ul><li>资源监控：主要监控CPU、内存、网络等常规指标</li><li>性能监控：应用的内部监控，通常是通过Hook的机制在虚拟机层、字节码执行层通过隐式调用，或者是在应用层显示注入，获得更深层次的一个监控指标，一般是用来应用的调优和诊断的。</li><li>安全监控：安全监控主要是对安全进行的一系列的监控监控，类似像越权管理、安全漏洞扫描等。</li><li>事件监控：事件监控紧密贴合Kubernetes的设计理念，补充常规监控方案的欠缺和弊端。</li></ul><h3 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h3><ul><li>Cloud Monitor: 基础资源监控</li><li>SLS: 阿里云日志服务</li><li>AHAS: 架构感知监控，应用高可用服务AHAS</li><li>ARMS APM：阿里云应用性能监控ARMS</li><li>ARMS Prometheus：阿里云托管版Prometheus</li><li>XTrace：链路追踪Tracing Analysis</li></ul><h4 id="基础资源监控Cloud-Monitor"><a href="#基础资源监控Cloud-Monitor" class="headerlink" title="基础资源监控Cloud Monitor"></a>基础资源监控Cloud Monitor</h4><ul><li><p>云监控</p><ul><li>是一项针对阿里云资源和互联网应用进行监控的服务</li><li>云监控用于监控各云服务资源的监控指标，探测云服务ECS和运营商站点的可用性，并针对制定监控指标设置报警。</li><li>全面了解阿里云上资源的使用情况和业务运行状况，并及时对故障资源进行处理，保证业务正常运行。</li></ul></li><li><p>查看容器监控数据</p></li><li><p>管理报警规则</p></li></ul><h4 id="日志服务SLS"><a href="#日志服务SLS" class="headerlink" title="日志服务SLS"></a>日志服务SLS</h4><ul><li><p>主要负责日志的采集、分析</p></li><li><p>可采集以下日志：</p><ul><li>APIServer等核心组件的日志</li><li>Service Mesh&#x2F;Ingress等接入层的日志</li><li>应用的标准日志</li></ul></li><li><p>提供上层的日志分析能力</p></li><li><p>默认提供了基于API Server的审计分析能力、接入层的可观测性展现，应用层的日志分析</p></li></ul><h4 id="应用实时监控服务ARMS"><a href="#应用实时监控服务ARMS" class="headerlink" title="应用实时监控服务ARMS"></a>应用实时监控服务ARMS</h4><ul><li>是一款阿里云应用性能管理(APM)类监控产品</li><li>可以基于前端、应用、业务自定义等维度，迅速便捷地为企业构架秒级响应的业务监控能力</li><li>ARMS提供一系列的监控定制功能，包括数据接入、数据计算、数据存储、大盘展示与报警、下游API对接等环节</li><li>用户需要关心三件事：数据从哪里来、实时计算怎么编排、数据怎么用</li></ul><h4 id="架构感知监控AHAS"><a href="#架构感知监控AHAS" class="headerlink" title="架构感知监控AHAS"></a>架构感知监控AHAS</h4><ul><li>AHAS是架构感知监控，通常在Kubernetes集群中负载的类型大部分为微服务，微服务的调用拓扑也比较复杂，因此当集群的网络链路出问题时，如何快速定位问题、发现问题、诊断问题则成为了最大的难题。</li><li>AHAS通过网络的流量和走向，将集群的拓扑进行展现，提供更高层次的问题诊断方式。</li><li>为Kubernetes应用安装AHAS探针后，AHAS能自动识别系统中的Pod、Deployment、Service和它们与其他组件的依赖关系</li><li>通过采集Kubernetes元信息，构建Kubernetes资源的物理拓扑关系，支持自建Kubernetes集群、阿里云容器服务Kubernetes集群</li></ul><h3 id="不同层次的监控解决方案"><a href="#不同层次的监控解决方案" class="headerlink" title="不同层次的监控解决方案"></a>不同层次的监控解决方案</h3><p>从可观测性的角度，以ACK为基础的系统架构可以粗略分为4个层次，自下而上分别是：</p><ul><li>基础设施层</li><li>容器性能层</li><li>应用性能层</li><li>用户业务层</li></ul><h3 id="阿里云容器服务ACK监控方案详解"><a href="#阿里云容器服务ACK监控方案详解" class="headerlink" title="阿里云容器服务ACK监控方案详解"></a>阿里云容器服务ACK监控方案详解</h3><ul><li><p>基础设施层可观测性：包括架构可视化感知方案和基础设施指标监控方向</p></li><li><p>集群、容器的性能指标监控：阿里云托管版Prometheus监控方案、开源Prometheus监控方案、事件的监控方案</p></li><li><p>应用性能可观测性：无侵入应用监控APM监控方案、侵入应用监控APM监控方案</p></li><li><p>用户业务可观测性：自定义日志监控方案</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>阿里云容器服务ACK版可观测性体系包括：</p><ul><li><p>Logging-日志</p></li><li><p>Metrics-监控指标</p></li><li><p>Tracing-全链路追踪</p></li></ul></li><li><p>阿里云容器服务ACK版集成了日志服务、在创建集群时启用日志服务、快速采集Kubernetes集群的容器日志、包括容器的标准输出以及容器内的文本文件</p></li><li><p>阿里云容器服务ACK版提供了云原生标准的监控接口</p><ul><li><p>它将监控的数据消费能力进行了标准化解耦</p></li><li><p>可以实现和不同云厂商提供的监控服务进行标准化接入</p></li><li><p>目前已经实现多个监控云服务打通接入</p></li></ul></li><li><p>阿里云容器服务ACK版监控生态解决方案分为：</p><ul><li><p>基础设施层场景的可观测性</p></li><li><p>容器性能层场景的可观测性</p></li><li><p>应用性能层场景的可观测性</p></li><li><p>用户业务层场景的可观测性</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;阿里云的可观测性体系： 日志管理、监控管理&lt;/p&gt;
&lt;h2 id=&quot;日志管理&quot;&gt;&lt;a href=&quot;#日志管理&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK存储</title>
    <link href="http://eryoung2.github.io/2023/02/14/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E5%AD%98%E5%82%A8/"/>
    <id>http://eryoung2.github.io/2023/02/14/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E5%AD%98%E5%82%A8/</id>
    <published>2023-02-14T08:00:14.000Z</published>
    <updated>2023-03-09T02:33:18.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在Kubernetes里最小的管理单元是Pod</p></li><li><p>Pod中产生的数据都是临时的，Pod销毁后默认不保存</p></li><li><p>对于有状态的服务，需要数据持久化</p></li><li><p>所以Kubernetes给定了一些数据持久化的方案</p></li></ul><h2 id="Kubernetes存储应用场景"><a href="#Kubernetes存储应用场景" class="headerlink" title="Kubernetes存储应用场景"></a>Kubernetes存储应用场景</h2><ul><li><p>服务的基本配置文件读取、密码密钥管理等</p></li><li><p>服务的存储状态、数据存储等</p></li><li><p>不同服务或应用程序间共享数据</p></li></ul><h2 id="Kubernetes存储系统核心概念"><a href="#Kubernetes存储系统核心概念" class="headerlink" title="Kubernetes存储系统核心概念"></a>Kubernetes存储系统核心概念</h2><h3 id="Volumn"><a href="#Volumn" class="headerlink" title="Volumn"></a>Volumn</h3><ul><li><p>Pod可以同时使用任意数目的卷类型</p></li><li><p>临时卷类型的生命周期与Pod相同，但持久化卷可以比Pod的存活时间长</p></li><li><p>卷的存在时间会超出Pod中所有容器，且在Pod重启时会重新加载</p></li></ul><h3 id="持久卷-PV"><a href="#持久卷-PV" class="headerlink" title="持久卷(PV)"></a>持久卷(PV)</h3><ul><li><p>是集群中管理员集中配置的一块存储</p></li><li><p>它是集群中的资源，就和节点是集群资源一样，包含存储的类型、大小和访问模式等</p></li><li><p>PV是卷插件比如Volumes等。但是它的生命周期独立于使用PV的任何Pod个体。比如，Pod销毁时，PV会得以保留。</p></li></ul><h3 id="持久卷声明-PVC"><a href="#持久卷声明-PVC" class="headerlink" title="持久卷声明(PVC)"></a>持久卷声明(PVC)</h3><ul><li><p>是用户关于存储的请求</p></li><li><p>描述对PV的一个请求，请求信息包含PV大小、访问模式等，PVC会消耗PV资源</p></li></ul><h2 id="Kubernetes存储插件"><a href="#Kubernetes存储插件" class="headerlink" title="Kubernetes存储插件"></a>Kubernetes存储插件</h2><ul><li><p>Kubernetes可以直接调用某种存储插件，对接后端存储服务，现阶段存储插件有20多种。</p></li><li><p>Kubernetes的存储插件可以分为：In-tree和Out-of-tree两大类</p><ul><li><p>In-tree: 源码放在Kubernetes内部，和Kubernetes一起发布、更迭，缺点是及时迭代速度慢、灵活性差</p></li><li><p>Out-of-tree: Volume Plugins独立于Kubernetes，它是由存储商提供实现的。主要有FlexVolume和CSI两种，ACK主要使用此类插件</p></li></ul></li></ul><h2 id="ACK存储插件"><a href="#ACK存储插件" class="headerlink" title="ACK存储插件"></a>ACK存储插件</h2><h3 id="FlexVolume"><a href="#FlexVolume" class="headerlink" title="FlexVolume"></a>FlexVolume</h3><ul><li><p>社区较早实现的存储卷扩展机制</p></li><li><p>FlexVolume运行在host空间，不能使用RBAC访问Kubernetes API，导致功能受到很大限制</p></li><li><p>由Shell部署</p></li></ul><h3 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h3><ul><li><p>社区推荐的存储卷扩展机制</p></li><li><p>ACK集群提供的CSI存储插件兼容社区的CSI特性</p></li><li><p>CSI不仅仅支持Kubernetes平台存储插件接口，而是作为云原生生态中容器存储接口的标准</p></li><li><p>CSI是容器部署的</p></li></ul><h2 id="CSI存储插件"><a href="#CSI存储插件" class="headerlink" title="CSI存储插件"></a>CSI存储插件</h2><h3 id="概念要点"><a href="#概念要点" class="headerlink" title="概念要点"></a>概念要点</h3><ul><li><p>遵循标准CSI规范，支持EBS、NAS、OSS等存储类型的挂载行为</p></li><li><p>自ACK v1.16开始，部署集群会默认安装最新版本的CSI组件，可以通过CSI存储插件使用阿里云存储服务</p></li><li><p>CSI存储插件提供了数据卷的全生命管理周期，包括数据卷的：创建、挂载、卸载、删除、扩容等服务</p></li><li><p>ACK目前只支持一种存储插件，CSI或者FlexVolume</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-04-38-sp1.png"></p><h3 id="插件特性"><a href="#插件特性" class="headerlink" title="插件特性"></a>插件特性</h3><ul><li><p>CSI是Kubernetes社区推荐的存储插件方案，CSI插件包括以下两部分：</p><ul><li><p>CSI-Plugin: 实现数据卷的挂载、卸载功能。ACK默认提供云盘、NAS、OSS三种存储卷的挂载能力</p></li><li><p>CSI-Provisioner: 实现数据卷的自动创造能力，目前支持云盘、NAS两种存储卷创造能力。</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-04-48-plugin1.png"></p><h3 id="CSI存储插件选择-EBS-NAS-OSS"><a href="#CSI存储插件选择-EBS-NAS-OSS" class="headerlink" title="CSI存储插件选择(EBS, NAS, OSS)"></a>CSI存储插件选择(EBS, NAS, OSS)</h3><h4 id="选择EBS的情景"><a href="#选择EBS的情景" class="headerlink" title="选择EBS的情景"></a>选择EBS的情景</h4><p>EBS(阿里云云盘)是阿里云提供的数据块级别的块存储产品，优势是性能高、时延低，适合于OLTP数据库、NoSQL数据库等IO密集型的高性能、低时延的应用工作负载。</p><h4 id="选择NAS的情景"><a href="#选择NAS的情景" class="headerlink" title="选择NAS的情景"></a>选择NAS的情景</h4><p>无需修改应用，可直接挂在NAS。文件存储NAS适用于多计算节点、无状态集群的共享数据访问。</p><h4 id="选择OSS的情景"><a href="#选择OSS的情景" class="headerlink" title="选择OSS的情景"></a>选择OSS的情景</h4><p>OSS采用扁平化的文件组织形式，采用Restful API接口访问，不支持文件随机读写，适用于互联网架构的海量数据的上传下载和分发。</p><h2 id="通过控制台使用云盘静态存储卷"><a href="#通过控制台使用云盘静态存储卷" class="headerlink" title="通过控制台使用云盘静态存储卷"></a>通过控制台使用云盘静态存储卷</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li><p>已创建一个ACK集群，并且在该集群中部署CSI集群</p></li><li><p>创建了一个按需付费的云盘</p></li></ol><h3 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-05-06-pv1.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-05-16-pv2.png"></p><h3 id="创建PVC"><a href="#创建PVC" class="headerlink" title="创建PVC"></a>创建PVC</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-05-28-pvc.png"></p><h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-05-39-app1.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/14-16-06-13-app2.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>Kubernetes存储核心概念：Volume、PV、PVC</p></li><li><p>Kubernetes插件存储分类：In-tree和Out-of-tree两类</p></li><li><p>ACK支持的存储插件模式：FlexVolume和CSI</p></li><li><p>ACK支持通过Pod绑定的三种存储形态：EBS、NAS、OSS</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在Kubernetes里最小的管理单元是Pod&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pod中产生的数据都是临时的，Pod销毁</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACK云原生容器工程师-ACK网络(下)</title>
    <link href="http://eryoung2.github.io/2023/02/13/ACK%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E7%BD%91%E7%BB%9C-%E4%B8%8B/"/>
    <id>http://eryoung2.github.io/2023/02/13/ACK%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E7%BD%91%E7%BB%9C-%E4%B8%8B/</id>
    <published>2023-02-13T07:07:42.000Z</published>
    <updated>2023-02-13T07:17:23.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器网络规划"><a href="#容器网络规划" class="headerlink" title="容器网络规划"></a>容器网络规划</h2><ul><li><p>容器网络规划、VPC专有网络配置阶段、容器网络配置阶段、Service网络配置阶段</p></li><li><p>根据集群业务需求，实现容器网络的配置完成</p></li></ul><h2 id="容器网络实践"><a href="#容器网络实践" class="headerlink" title="容器网络实践"></a>容器网络实践</h2><h3 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-15-11-01-flannel1.png"></p><h3 id="Terway"><a href="#Terway" class="headerlink" title="Terway"></a>Terway</h3><h4 id="Terway网络规划注意事项"><a href="#Terway网络规划注意事项" class="headerlink" title="Terway网络规划注意事项"></a>Terway网络规划注意事项</h4><ul><li><p>建议选用高配ECS规格机型，如5代或6代的8G以上机型</p></li><li><p>共享ENI支持的最大Pod数&#x3D;(ECS支持的ENI数-1)×单个ENI支持的私有ip数</p></li><li><p>独占ENI支持的最大Pod数&#x3D;ECS支持的ENI数-1</p></li></ul><h4 id="Terway网络实践步骤"><a href="#Terway网络实践步骤" class="headerlink" title="Terway网络实践步骤"></a>Terway网络实践步骤</h4><h5 id="1-规划和准备集群网络"><a href="#1-规划和准备集群网络" class="headerlink" title="1. 规划和准备集群网络"></a>1. 规划和准备集群网络</h5><ul><li><p>在创建ACK Kubernetes集群时，需要指定VPC地址段、虚拟交换机、Pod地址段、Service地址段</p></li><li><p>需要先创建一个专有网络VPC，然后在VPC下创建两个虚拟交换机</p></li><li><p>虚拟交换机和Pod交换机需要在同一可用区下</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-15-11-17-terway1.png"></p><h5 id="2-创建专有网络"><a href="#2-创建专有网络" class="headerlink" title="2. 创建专有网络"></a>2. 创建专有网络</h5><ol><li><p>登录专有网络管理控制台</p></li><li><p>在顶部菜单栏，选择地域，然后创建专有网络</p></li><li><p>创建专有网络和虚拟交换机。</p></li></ol><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-15-11-26-terway2.png"></p><h5 id="3-创建ACK集群"><a href="#3-创建ACK集群" class="headerlink" title="3. 创建ACK集群"></a>3. 创建ACK集群</h5><ol><li><p>登录阿里云容器服务ACK管理控制台</p></li><li><p>创建集群</p></li><li><p>在选择集群模板页面，单机标准托管集群下的创建</p></li></ol><h5 id="4-配置Terway网络"><a href="#4-配置Terway网络" class="headerlink" title="4. 配置Terway网络"></a>4. 配置Terway网络</h5><ol><li><p>配置的关键信息：专有网络、虚拟交换机、网络插件选Terway</p></li><li><p>配置Terway模式：独占弹性网卡或者共享弹性网卡(IPVlan)，是否支持NetworkPolicy选项(仅在共享弹性网卡模式下可选)，Pod网段，Service网段</p></li></ol><h5 id="5-配置节点实例及创建集群"><a href="#5-配置节点实例及创建集群" class="headerlink" title="5. 配置节点实例及创建集群"></a>5. 配置节点实例及创建集群</h5><p>选择节点实例，点击创建</p><h4 id="Terway和Flannel模式的不同"><a href="#Terway和Flannel模式的不同" class="headerlink" title="Terway和Flannel模式的不同"></a>Terway和Flannel模式的不同</h4><ul><li><p>Pod需要通过弹性网卡(ENI)接入虚拟交换机，来组件Pod网络</p></li><li><p>不同ECS规格所能支持的弹性网卡数不同</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>容器网络规划步骤介绍</p></li><li><p>容器网络实践</p><ul><li><p>Flannel</p></li><li><p>Terway，主要介绍了ENI模式下如何创建集群网络</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;容器网络规划&quot;&gt;&lt;a href=&quot;#容器网络规划&quot; class=&quot;headerlink&quot; title=&quot;容器网络规划&quot;&gt;&lt;/a&gt;容器网络规划&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;容器网络规划、VPC专有网络配置阶段、容器网络配置阶段、Service网络配置阶段&lt;/p&gt;</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK网络(上)</title>
    <link href="http://eryoung2.github.io/2023/02/13/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E7%BD%91%E7%BB%9C-%E4%B8%8A/"/>
    <id>http://eryoung2.github.io/2023/02/13/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E7%BD%91%E7%BB%9C-%E4%B8%8A/</id>
    <published>2023-02-13T05:08:04.000Z</published>
    <updated>2023-02-13T06:57:40.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器集群网络设计目标"><a href="#容器集群网络设计目标" class="headerlink" title="容器集群网络设计目标"></a>容器集群网络设计目标</h2><h3 id="主要解决的4个问题"><a href="#主要解决的4个问题" class="headerlink" title="主要解决的4个问题"></a>主要解决的4个问题</h3><ul><li><p>容器与容器之间的通信</p></li><li><p>Pod与Pod之间的通信</p></li><li><p>Pod与Service之间的通信</p></li><li><p>外部世界与Service之间的通信</p></li></ul><h3 id="Kubernetes网络接入的三个原则"><a href="#Kubernetes网络接入的三个原则" class="headerlink" title="Kubernetes网络接入的三个原则"></a>Kubernetes网络接入的三个原则</h3><ul><li><p>Pod和Pod的通信不需要NAT转换，可直接通信</p></li><li><p>Node和Pod可以相互通信，在不限制的情况下，Pod可以访问任意网络</p></li><li><p>Pod拥有独立的网络栈，Pod看到自己地址和外部看到自己地址是一样的，Pod内部容器共用一套独立的网络栈</p></li></ul><h3 id="容器到容器之间的通信"><a href="#容器到容器之间的通信" class="headerlink" title="容器到容器之间的通信"></a>容器到容器之间的通信</h3><ul><li><p>在容器中，容器之间的网络通信是通过docker0网桥，凡是连接到docker0的容器，都可以通过它来直接通信。</p></li><li><p>要想容器连接到docker0网桥，我们需要veth pair的虚拟设备来实现</p></li><li><p>当容器在一台宿主机上，访问该容器的ip地址时，这个数据包：</p><ul><li><p>先根据路由规则到达docker0网桥</p></li><li><p>然后被转发到对应的veth pair设备</p></li><li><p>最后，出现在容器里</p></li></ul></li></ul><h3 id="通过Service实现内外部统一访问"><a href="#通过Service实现内外部统一访问" class="headerlink" title="通过Service实现内外部统一访问"></a>通过Service实现内外部统一访问</h3><h4 id="为什么设立Service"><a href="#为什么设立Service" class="headerlink" title="为什么设立Service?"></a>为什么设立Service?</h4><ul><li><p>Kubernetes集群是通过Pod部署的，我们知道在Pod的生命周期中，随时可能被销毁和变化</p></li><li><p>应用创建Pod组来统一访问入口及负载均衡</p></li><li><p>应用服务需要暴露给外部，需要提供给外部用户进行访问</p></li><li><p>Pod之间的通信也可以通过Kubernetes Service进行访问</p></li><li><p>Kubernetes Service可以实现访问负载到一组Pod上</p></li></ul><p>具体如图：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-12-00-svc.png"></p><h3 id="跨主机网络通信"><a href="#跨主机网络通信" class="headerlink" title="跨主机网络通信"></a>跨主机网络通信</h3><ul><li><p>Docker默认不支持容器之间跨主机通信</p></li><li><p>Kubernetes提出了CNI作为网络接口可以实现容器跨主机通信</p><ul><li><p>CNI是Kubernetes中标准的一个调用网络实现的接口</p></li><li><p>Kubelet通过调用此API来调用不同的网络插件来实现不同的网络配置，实现此借口额就是CNI</p></li><li><p>目前常用的CNI有：Flannel、Calico、Weave、Terway等</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-12-17-cni1.png"></p><h3 id="几种常见的CNI介绍"><a href="#几种常见的CNI介绍" class="headerlink" title="几种常见的CNI介绍"></a>几种常见的CNI介绍</h3><ul><li><p>Flannel：Flannel是最早由CoreOS团队推出的CNI，用于让集群中不同节点都使用全局唯一的网络，也是当前Kubernetes开源方案中最成熟的一个，支持HostGW和VXLAN模式。</p></li><li><p>Calico：是一个纯3层的数据中心网络方案，支持IPIP和BGP模式，后者可以无缝集成像Openstack这种IaaS云架构，能够提供可控的VM、容器、裸机之间的IP通信。</p></li><li><p>Terway: 是阿里云开源的基于VPC网络的CNI插件，支持VPC和ENI模式，后者可实现容器网络使用VPC子网网络，即可以与VPC子网重合。</p></li></ul><h2 id="阿里云ACK容器网络技术实现"><a href="#阿里云ACK容器网络技术实现" class="headerlink" title="阿里云ACK容器网络技术实现"></a>阿里云ACK容器网络技术实现</h2><h3 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-12-37-cni2.png"></p><h3 id="阿里云容器服务ACK容器网络模式"><a href="#阿里云容器服务ACK容器网络模式" class="headerlink" title="阿里云容器服务ACK容器网络模式"></a>阿里云容器服务ACK容器网络模式</h3><ul><li><p>容器服务将Kubernetes网络、SLB、VPC进行深度集成，提供了稳定高效能的容器网络。</p></li><li><p>在容器服务中，支持以下互通类型：</p><ul><li><p>在一个容器集群中，Pod之间相互访问</p></li><li><p>在一个容器集群中，Pod访问Service</p></li><li><p>在一个容器集群中，ECS访问Service</p></li><li><p>Pod直接访问同一个VPC下的ECS</p></li><li><p>同一个VPC下的ECS直接访问Pod</p></li></ul></li></ul><h3 id="阿里云容器服务ACK容器网络规划与实现"><a href="#阿里云容器服务ACK容器网络规划与实现" class="headerlink" title="阿里云容器服务ACK容器网络规划与实现"></a>阿里云容器服务ACK容器网络规划与实现</h3><ul><li><p>在创建ACK集群时，您需要执行VPC、虚拟交换机、Pod网络CIDR和Service CIDR</p></li><li><p>建议您提前规划ECS地址、Kubernetes Pod地址和Service地址</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-12-59-network1.png"></p><h3 id="阿里云容器服务ACK容器网络规划注意事项"><a href="#阿里云容器服务ACK容器网络规划注意事项" class="headerlink" title="阿里云容器服务ACK容器网络规划注意事项"></a>阿里云容器服务ACK容器网络规划注意事项</h3><ul><li><p>VPC网段：从10.0.0.0&#x2F;8, 172.16.0.0&#x2F;12, 192.168.0.0&#x2F;16中三选一</p></li><li><p>交换机网段：</p><ul><li><p>在VPC中创建指定的交换机网段，必须是VPC子网段</p></li><li><p>交换机下创建的ECS实例，网络ip从交换机网段中获得</p></li><li><p>一个VPC下，可创建多个交换机，但其网段不可重叠</p></li></ul></li><li><p>Pod地址段(K8S特定概念)</p><ul><li><p>每个Pod具有独立ip地址</p></li><li><p>Pod的地址段不能与VPC网络重叠(针对Flannel和Calico)</p></li></ul></li><li><p>Service地址段(K8S特定概念)</p><ul><li><p>每个Service有独立ip地址</p></li><li><p>Service地址段无法与VPC和Pod地址段重合</p></li><li><p>Service只能在集群内部使用，不能出集群</p></li></ul></li></ul><h2 id="容器网络规划"><a href="#容器网络规划" class="headerlink" title="容器网络规划"></a>容器网络规划</h2><h3 id="VPC专有网络"><a href="#VPC专有网络" class="headerlink" title="VPC专有网络"></a>VPC专有网络</h3><p>专有网络VPC可以基于阿里云帮您构建出一套隔离的网络环境</p><ul><li><p>可以完全掌控自己的虚拟网络，包括自定义IP地址范围、划分网段、配置路由表和网关等</p></li><li><p>容器服务通过配置VPC路由表的方式将容器对容器的访问转发到容器IP所对应的ECS机器上</p></li><li><p>容器服务是依赖VPC的路由表做容器IP到ECS的流量转发的</p></li><li><p>在VPC的路由表配置中，我们可以看到容器服务配置的网段到ECS的配置，这个是容器服务自动完成的，如果配置不小心被删除了，可以对照节点上的docker info找到本节点相应的网段，手动恢复到VPC的路由表中。</p></li></ul><h3 id="VPC专有网络规划"><a href="#VPC专有网络规划" class="headerlink" title="VPC专有网络规划"></a>VPC专有网络规划</h3><p>阿里云容器网络与VPC网络深度集成</p><ul><li><p>在创建阿里云容器网络之前，需要先创建VPC和虚拟交换机</p></li><li><p>需要结合具体业务来规划VPC和交换机的数量及网段等</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-13-34-vpc1.png"></p><h3 id="网络容器插件"><a href="#网络容器插件" class="headerlink" title="网络容器插件"></a>网络容器插件</h3><ul><li><p>Flannel</p></li><li><p>Terway</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-13-58-chajian.png"></p><h3 id="Flannel网络插件"><a href="#Flannel网络插件" class="headerlink" title="Flannel网络插件"></a>Flannel网络插件</h3><ul><li><p>Flannel是最常见的Kubernetes CNI，配合阿里云的VPC高速网络，能提供高性能和稳定的容器网络体验。</p></li><li><p>通过网桥进行数据包转发，container-&gt;Host-&gt;Other pod container</p></li><li><p>三种后端方式：VXLAN，UDP，host-gw</p></li><li><p>Pod网段独立于VPC网段，每个节点需要对应一个VPC的路由表条目。</p></li><li><p>Pod网段会按照掩码均匀划分每个集群中的节点，每个节点上的Pod会从节点上划分的网段中分配IP地址。</p></li><li><p>基于阿里云VPC的Flannel网络无封包，相对默认的Flannel VXLAN性能提升20%</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-14-10-flannel.png"></p><h3 id="Terway"><a href="#Terway" class="headerlink" title="Terway"></a>Terway</h3><ul><li><p>是阿里云开源的基于专有网络VPC的容器网络接口CNI，采用云原生的网络方案</p></li><li><p>基于K8S标准的网络策略来定义容器间的访问策略</p></li><li><p>将原生的弹性网卡分配给Pod实现Pod网络</p></li><li><p>支持基于K8S标准的网络策略来定义容器间的访问策略，并兼容Calico的网络策略。</p></li><li><p>Terway兼容VPC的网络方案，方便对接已有的基础设施</p></li><li><p>没有Overlay封包解包的损耗，简单易用，方便网络诊断</p></li><li><p>直接基于VPC中的弹性网卡来构建容器网络</p></li><li><p>Pod网段直接由弹性网卡资源分配，所以可以与VPC网段重合</p></li><li><p>每个Pod都拥有自己独立的网络栈和ip地址</p></li><li><p>同一台ECS内的Pod之间通信，直接通过机器内部转发；跨ECS的Pod通信，报文通过VPC的弹性网卡进行转发</p></li><li><p>Terway不需要使用VxLAN等隧道技术进行转发，因此通信效率很高</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-14-19-terway.png"></p><h3 id="Flannel与Terway对比"><a href="#Flannel与Terway对比" class="headerlink" title="Flannel与Terway对比"></a>Flannel与Terway对比</h3><p>结论：对于不需要使用Network Policy的用户，可以选择Flannel；否则还是建议选择Terway</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-14-31-duibi.png"></p><h3 id="Service网络"><a href="#Service网络" class="headerlink" title="Service网络"></a>Service网络</h3><p>通过服务抽象，能够解耦前端和后端的关联，从而实现松耦合的微服务设计，以及自动负载均衡实现快速的业务弹性。</p><p>Service是四层负载均衡。</p><p>ACK容器服务采用Service方式为一组容器统一提供固定的访问入口，并对这一组容器做负载均衡。</p><p>服务访问方式：</p><ul><li><p>Nodeport：在cluster每个node上开辟一个转发的端口。</p></li><li><p>ClusterIP: 默认模式，根据是否生成ClusterIP又可分为普通Service和Headless Service两类：</p><ul><li><p>普通Service：通过为Kubernetes的Service分配一个集群内部可访问的固定虚拟ip（Cluster IP），实现集群内的访问。为最常见的方式。</p></li><li><p>Headless Service：该服务不会分配Cluster IP，也不通过kube-proxy做反向代理和负载均衡。而是通过DNS提供稳定的网络ID来访问，DNS会将headless service的后端直接解析为podIP列表。主要供StatefulSet使用。</p></li></ul></li><li><p>LoadBalancer: 除了使用一个Cluster IP和nodePort之外，还会向所使用的公有云申请一个负载均衡器(负载均衡器后端映射到各节点的nodePort)，实现从集群外通过LB访问服务。</p></li></ul><h3 id="Ingress网络"><a href="#Ingress网络" class="headerlink" title="Ingress网络"></a>Ingress网络</h3><ul><li><p>集群内对外暴露的访问接入点，承载几乎全部的流量</p></li><li><p>Ingress是七层负载均衡。</p></li><li><p>可以通过Ingress配置不同的转发规则，从而达到根据不同的规则设置访问集群内不同的Service后端Pod。</p></li><li><p>阿里云容器服务提供高可靠的Ingress Controller组件，集成了阿里云SLB服务，为您的Kubernetes集群提供灵活可靠的路由服务(Ingress)</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/13-13-14-41-ingress.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>容器集群网络设计目标</p></li><li><p>阿里云ACK容器网络技术实现</p></li><li><p>容器网络规划</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;容器集群网络设计目标&quot;&gt;&lt;a href=&quot;#容器集群网络设计目标&quot; class=&quot;headerlink&quot; title=&quot;容器集群网络设计目标&quot;&gt;&lt;/a&gt;容器集群网络设计目标&lt;/h2&gt;&lt;h3 id=&quot;主要解决的4个问题&quot;&gt;&lt;a href=&quot;#主要解决的4个问题&quot; c</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK操作</title>
    <link href="http://eryoung2.github.io/2023/02/11/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%93%8D%E4%BD%9C/"/>
    <id>http://eryoung2.github.io/2023/02/11/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%93%8D%E4%BD%9C/</id>
    <published>2023-02-11T06:47:30.000Z</published>
    <updated>2023-02-11T06:56:07.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li>授权账号(RBAC&#x2F;RAM)</li><li>创建集群(专有版、托管版、serverless版)</li><li>部署应用(镜像、模板)</li><li>运维管理(运维集群、运维应用)</li></ol><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-00-ji1.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-10-ji2.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-31-ji4.png"></p><h3 id="集群查看"><a href="#集群查看" class="headerlink" title="集群查看"></a>集群查看</h3><p>查看集群的基本信息、连接信息、集群资源、集群日志及集群时区</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-47-ji5.png"></p><h2 id="连接集群的方式"><a href="#连接集群的方式" class="headerlink" title="连接集群的方式"></a>连接集群的方式</h2><ul><li><p>使用kubectl直接连接集群</p></li><li><p>使用CloudShell通过kubectl连接集群</p></li><li><p>通过SSH连接集群</p></li><li><p>使用ServiceAccount Token访问集群</p></li><li><p>通过公网访问集群API Server</p></li></ul><h2 id="创建无状态集群（Deployment）"><a href="#创建无状态集群（Deployment）" class="headerlink" title="创建无状态集群（Deployment）"></a>创建无状态集群（Deployment）</h2><h3 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-01-wu1.png"></p><h3 id="应用基本信息"><a href="#应用基本信息" class="headerlink" title="应用基本信息"></a>应用基本信息</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-14-wu2.png"></p><h3 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-36-wu3.png"></p><p>拉取镜像的3种方式：自动更新、手动更新、默认本地</p><h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-50-wu4.png"></p><h3 id="创建并查看"><a href="#创建并查看" class="headerlink" title="创建并查看"></a>创建并查看</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-59-wu5.png"></p><h2 id="有状态应用（Statefulset）"><a href="#有状态应用（Statefulset）" class="headerlink" title="有状态应用（Statefulset）"></a>有状态应用（Statefulset）</h2><h3 id="有状态应用和无状态应用区别："><a href="#有状态应用和无状态应用区别：" class="headerlink" title="有状态应用和无状态应用区别："></a>有状态应用和无状态应用区别：</h3><p>无状态应用与持久化组件无关（例如Volumn、DB等），应用挂掉重启之后，与持久化组件就断开了；有状态应用与持久化组件有关，应用挂掉重启之后，与持久化组件仍有关系。</p><h3 id="Statefulset应用集特点"><a href="#Statefulset应用集特点" class="headerlink" title="Statefulset应用集特点"></a>Statefulset应用集特点</h3><ul><li><p>稳定且需要唯一的应用标识符</p></li><li><p>稳定且持久的存储</p></li><li><p>要求有序、平滑的部署和扩展</p></li><li><p>要求有序、平滑的终止和删除</p></li><li><p>有序的滚动更新</p></li><li><p>Statefulset可能创建的三种资源类型：PVC、Pod、ControllerRevision</p></li></ul><h2 id="创建有状态应用"><a href="#创建有状态应用" class="headerlink" title="创建有状态应用"></a>创建有状态应用</h2><h3 id="镜像创建-1"><a href="#镜像创建-1" class="headerlink" title="镜像创建"></a>镜像创建</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-23-you1.png"></p><h3 id="容器配置（数据卷）"><a href="#容器配置（数据卷）" class="headerlink" title="容器配置（数据卷）"></a>容器配置（数据卷）</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-33-you2.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-43-you3.png"></p><p>可添加云盘、NAS、OSS</p><h3 id="高级配置-1"><a href="#高级配置-1" class="headerlink" title="高级配置"></a>高级配置</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-55-you4.png"></p><h3 id="创建并查看-1"><a href="#创建并查看-1" class="headerlink" title="创建并查看"></a>创建并查看</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-56-03-you5.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>ACK入门操作指引</p></li><li><p>ACK集群入门操作指引</p></li><li><p>ACK创建无状态应用</p></li><li><p>ACK创建有状态应用</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作流程&quot;&gt;&lt;a href=&quot;#操作流程&quot; class=&quot;headerlink&quot; title=&quot;操作流程&quot;&gt;&lt;/a&gt;操作流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;授权账号(RBAC&amp;#x2F;RAM)&lt;/li&gt;
&lt;li&gt;创建集群(专有版、托管版、serverless版)&lt;/</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK Pro概述</title>
    <link href="http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK-Pro%E6%A6%82%E8%BF%B0/"/>
    <id>http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK-Pro%E6%A6%82%E8%BF%B0/</id>
    <published>2023-02-10T10:04:53.000Z</published>
    <updated>2023-02-15T07:47:48.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACK-Pro集群概述"><a href="#ACK-Pro集群概述" class="headerlink" title="ACK Pro集群概述"></a>ACK Pro集群概述</h2><h3 id="对比ACK托管版集群"><a href="#对比ACK托管版集群" class="headerlink" title="对比ACK托管版集群"></a>对比ACK托管版集群</h3><ul><li><p>相比ACK托管版，针对企业版大规模生产环境进一步增强了可靠性、安全性</p></li><li><p>继承了原托管版集群的所有优势</p></li><li><p>提供可赔付的SLA的Kubernetes集群</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-08-24-vs%20ack%20tuoguan.png"></p><h3 id="对比标准版集群"><a href="#对比标准版集群" class="headerlink" title="对比标准版集群"></a>对比标准版集群</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-08-37-vs%20biaozhun.png"></p><h2 id="ACK-Pro各种集群"><a href="#ACK-Pro各种集群" class="headerlink" title="ACK Pro各种集群"></a>ACK Pro各种集群</h2><h3 id="可靠性强化集群"><a href="#可靠性强化集群" class="headerlink" title="可靠性强化集群"></a>可靠性强化集群</h3><p>更可靠的托管Master节点，API Server自动弹性，保证集群平滑扩容海量节点。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-09-39-kekao.png"></p><h3 id="安全性强化集群"><a href="#安全性强化集群" class="headerlink" title="安全性强化集群"></a>安全性强化集群</h3><p>开放安全管理，并提供针对运行中容器更强检测和自动修复能力的安全管理高级版，与KMS结合会更安全。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-09-49-anquan.png"></p><h3 id="调度性强化集群"><a href="#调度性强化集群" class="headerlink" title="调度性强化集群"></a>调度性强化集群</h3><ul><li><p>集成更强调度性能的kube-scheduler，支持多种智能调度算法</p></li><li><p>优化在大规模数据计算、高性能数据处理等业务场景下的容器调度能力</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-10-00-diaodu.png"></p><h3 id="ACK-Pro显著特点"><a href="#ACK-Pro显著特点" class="headerlink" title="ACK Pro显著特点"></a>ACK Pro显著特点</h3><ul><li><p>可靠的强化集群</p></li><li><p>提升安全性的集群</p></li><li><p>调度能力更强</p></li></ul><h4 id="ACK-Pro版适用行业"><a href="#ACK-Pro版适用行业" class="headerlink" title="ACK Pro版适用行业"></a>ACK Pro版适用行业</h4><ul><li><p>金融企业</p></li><li><p>互联网企业</p></li><li><p>大数据计算企业</p></li><li><p>开展中国业务的海外企业</p></li></ul><h2 id="ACK-Pro适用场景"><a href="#ACK-Pro适用场景" class="headerlink" title="ACK Pro适用场景"></a>ACK Pro适用场景</h2><h3 id="弹性伸缩架构"><a href="#弹性伸缩架构" class="headerlink" title="弹性伸缩架构"></a>弹性伸缩架构</h3><ul><li><p>容器服务可以根据业务流量自动对业务扩容、缩容，不需要人工干预</p></li><li><p>避免流量激增扩容不及时导致系统挂掉，以及平时大量资源闲置</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-14-45-shensuo.png"></p><h3 id="DevOps持续交付"><a href="#DevOps持续交付" class="headerlink" title="DevOps持续交付"></a>DevOps持续交付</h3><h3 id="云原生AI"><a href="#云原生AI" class="headerlink" title="云原生AI"></a>云原生AI</h3><ul><li><p>深度学习的三个核心问题：性能、效率、成本</p></li><li><p>ACK Pro无缝整合了云的计算、存储、负载均衡等服务，同时贯穿了深度学习的全生命周期</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-14-55-cncf.png"></p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul><li><p>企业生产环境中，通过合理微服务拆分，将每个微服务应用存储在阿里云镜像帮您管理</p></li><li><p>您只需迭代每个微服务应用，有阿里云容器服务ACK提供调度、编排、部署、灰度发布</p></li><li><p>帮助企业快速实现敏捷开发和部署落地，加速企业业务迭代</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-15-18-microservice.png"></p><h3 id="混合云架构"><a href="#混合云架构" class="headerlink" title="混合云架构"></a>混合云架构</h3><ul><li><p>在容器服务控制台上同时管理云上云下的资源，不需要在多种云管理控制台中反复切换</p></li><li><p>基于容器基础设施无关的特性，使用同一套镜像和编排同时在云上云下部署应用</p></li><li><p>基于阿里云容器服务ACK实现统一运维多个云端资源</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-15-31-mixcloud.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>ACK Pro集群概述，与ACK托管版和ACK标准版对比</p></li><li><p>ACK Pro各种集群：可靠性强化集群、安全性强化集群、调度性强化集群</p></li><li><p>ACK Pro显著特点、适用行业</p></li><li><p>ACK适用场景：弹性伸缩架构、DevOps持续交付、云原生AI、微服务架构、混合云架构</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ACK-Pro集群概述&quot;&gt;&lt;a href=&quot;#ACK-Pro集群概述&quot; class=&quot;headerlink&quot; title=&quot;ACK Pro集群概述&quot;&gt;&lt;/a&gt;ACK Pro集群概述&lt;/h2&gt;&lt;h3 id=&quot;对比ACK托管版集群&quot;&gt;&lt;a href=&quot;#对比ACK托管</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK概述</title>
    <link href="http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%A6%82%E8%BF%B0/"/>
    <id>http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%A6%82%E8%BF%B0/</id>
    <published>2023-02-09T17:46:34.000Z</published>
    <updated>2023-02-09T17:50:32.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACK简介"><a href="#ACK简介" class="headerlink" title="ACK简介"></a>ACK简介</h2><p>阿里云容器服务ACK，是阿里云针对云原生推出的拳头产品，基于原版Kubernetes进行适配和增强，简化集群的搭建和运维工作，整合阿里云虚拟化、存储、网络和安全能力，使得扩容和缩容更加简易，打造云端最佳的Kubernetes容器化应用运行环境。</p><h2 id="ACK分类"><a href="#ACK分类" class="headerlink" title="ACK分类"></a>ACK分类</h2><p>ACK产品根据运维整合度，可分为三类：</p><ul><li><p><strong>专有版Kubernetes</strong></p></li><li><p><strong>托管版Kubernetes</strong></p></li><li><p><strong>Serverless Kubernetes</strong></p></li></ul><p>三者的特点和区别如下：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-01-50-02-diff.png"></p><p>适用人群分别为：</p><ul><li><p>专业版ACK：懂技术、有运维K8S的能力、资源规划明显、Master节点定制、完全自营、成本不敏感</p></li><li><p>托管版ACK: Kubernetes能上手、不关心Master节点、只部署应用、降低成本</p></li><li><p>Serverless Kubernetes：批量任务、突发扩容、开箱即用、零运维、按量付费、不关注基础设施</p></li></ul><h4 id="ACK-vs-原生K8S"><a href="#ACK-vs-原生K8S" class="headerlink" title="ACK vs 原生K8S"></a>ACK vs 原生K8S</h4><ul><li><p>ACK基于原生K8S</p></li><li><p>ACK整合阿里云虚拟化、网络、存储、安全能力</p></li><li><p>高性能可伸缩能力加强</p></li><li><p>简化集群的运维和扩容工作，更专注应用开发</p></li></ul><p>也可参考此图：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-01-50-14-diff2.png"></p><h2 id="ACK核心功能"><a href="#ACK核心功能" class="headerlink" title="ACK核心功能"></a>ACK核心功能</h2><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>通过控制台一键创建Kubernetes集群，支持跨可用区高可用。</p><p>特点如下：</p><ul><li><p>集群形态：支持ACK&#x2F;ACK Pro&#x2F;ASK</p></li><li><p>组件升级：一键升级K8S版本</p></li><li><p>弹性伸缩：支持垂直伸缩、水平伸缩等多种扩容模式</p></li><li><p>多云管理：支持多云、混合云集群管理</p></li><li><p>安全授权：支持RAM授权和RBAC权限管理</p></li></ul><h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><ul><li><p>一站式容器全生命周期管理</p></li><li><p>应用创建：从镜像、模板的创建，支持环境变量、应用健康的配置</p></li><li><p>应用全生命周期管理：支持应用查看、更新、删除、回滚等</p></li><li><p>应用调度：支持节点亲和性调度、应用亲和性和反亲和性调度</p></li><li><p>应用伸缩：支持手动伸缩应用容器实例，HPA自动伸缩策略</p></li><li><p>应用发布：支持灰度发布和蓝绿发布</p></li><li><p>应用目录：支持应用目录，简化云服务集成</p></li></ul><h3 id="存储与网络"><a href="#存储与网络" class="headerlink" title="存储与网络"></a>存储与网络</h3><ul><li><p>整合阿里云虚拟化、网络、存储、安全能力</p></li><li><p>支持阿里云云盘、NAS、OSS等持久化存储支持</p></li><li><p>支持高性能Flannel和Terway容器网络</p></li></ul><h3 id="运维与安全"><a href="#运维与安全" class="headerlink" title="运维与安全"></a>运维与安全</h3><ul><li>提供全方位的安全管理体系：基础架构安全、运行时安全、可信软件供应链安全</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-01-50-23-security.png"></p><ul><li><p>监控：支持集群、节点、应用、容器实例监控</p></li><li><p>日志：日志管理及日志查看</p></li><li><p>安全中心：提升容器安全整体纵深防御能力</p></li><li><p>安全沙箱：提供安全沙箱环境，具备独立内核</p></li><li><p>支持机密计算，提供可信执行加密环境</p></li></ul><h3 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h3><ul><li><p>使用场景：在线业务弹性、大规模计算训练、深度学习GPU或共享GPU的训练和推理、定时周期性负载变化等。</p></li><li><p>弹性伸缩维度：弹性层调度、资源层调度</p></li><li><p>调度层组件：容器水平伸缩（HPA）、容器垂直伸缩（VPA）、容器定时伸缩（Cron-HPA）、弹性负载（Elastic-Workload）</p></li></ul><h2 id="容器服务ACK产品优势"><a href="#容器服务ACK产品优势" class="headerlink" title="容器服务ACK产品优势"></a>容器服务ACK产品优势</h2><ul><li><p>强大的集群管理</p></li><li><p>极致弹性的资源扩张</p></li><li><p>一站式容器管理</p></li><li><p>丰富的工作节点</p></li><li><p>最优的IaaS层能力</p></li><li><p>企业级的安全稳定</p></li><li><p>全天候技术支持</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ACK简介&quot;&gt;&lt;a href=&quot;#ACK简介&quot; class=&quot;headerlink&quot; title=&quot;ACK简介&quot;&gt;&lt;/a&gt;ACK简介&lt;/h2&gt;&lt;p&gt;阿里云容器服务ACK，是阿里云针对云原生推出的拳头产品，基于原版Kubernetes进行适配和增强，简化集群的搭建和</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>地址转换技术</title>
    <link href="http://eryoung2.github.io/2023/02/09/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%8A%80%E6%9C%AF/"/>
    <id>http://eryoung2.github.io/2023/02/09/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%8A%80%E6%9C%AF/</id>
    <published>2023-02-09T09:08:14.000Z</published>
    <updated>2023-02-09T09:10:12.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们上网的过程中，不可能只用同一个ip地址来访问，在公网和内网之间，需要一些地址转换来实现公网和内网ip的变化。通常，我们可以使用NAT来做；在公网ip不固定的时候，也需要使用MASQUERADE来做地址转换。</p><h2 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h2><p>我们都知道，在ip数据包中，有两个参数可以定位包的源地址和目的地址，一个是源地址ip，一个是目标地址ip。我们常用的NAT有两种，一种是SNAT，修改源地址；一种是DNAT，修改目标地址。</p><h3 id="SNAT-Source-NAT"><a href="#SNAT-Source-NAT" class="headerlink" title="SNAT(Source NAT)"></a>SNAT(Source NAT)</h3><p>此协议转换包的源地址，通常用于内网ip转公网ip，也就是正向代理会对发出的ip包做SNAT，使其可以传到公网环境中进行下一跳路由动作。</p><p>此修改作用于iptables的POSTROUTING阶段，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s &lt;修改之前的ip段&gt; -o &lt;出口网卡&gt; -j SNAT --to-source &lt;修改之后的ip&gt; </span><br></pre></td></tr></table></figure><h3 id="DNAT-Destination-NAT"><a href="#DNAT-Destination-NAT" class="headerlink" title="DNAT(Destination NAT)"></a>DNAT(Destination NAT)</h3><p>此协议转换包的目的地址，通常用于公网ip转内网ip，也就是反向代理会对收到的ip包做DNAT，使其可以传到内网环境中进行下一跳路由动作。</p><p>此修改作用于iptables的PREROUTING阶段，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d &lt;需要使用的ip地址&gt; -i &lt;入口网卡&gt; -j DNAT --to-destination &lt;修改之前的ip段&gt;</span><br></pre></td></tr></table></figure><h2 id="MASQUERADE-伪装"><a href="#MASQUERADE-伪装" class="headerlink" title="MASQUERADE(伪装)"></a>MASQUERADE(伪装)</h2><p>当我们的网卡绑定的公网ip是动态的，我们就需要动态读取网卡上的ip信息，这时我们使用MASQUERADE协议可以实现。</p><p>当然，MASQUERADE是一种特殊的SNAT，通常用于动态网络环境中，也作用于POSTROUTING阶段。</p><p>具体的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s &lt;修改之前的ip段&gt; -o &lt;出口网卡&gt; MASQUERADE</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我们上网的过程中，不可能只用同一个ip地址来访问，在公网和内网之间，需要一些地址转换来实现公网和内网ip的变化。通常，我们可以使用NAT来</summary>
      
    
    
    
    <category term="面试" scheme="http://eryoung2.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
    <category term="网络" scheme="http://eryoung2.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-云原生概要-1</title>
    <link href="http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E8%A6%81-1/"/>
    <id>http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E8%A6%81-1/</id>
    <published>2023-01-31T08:04:47.000Z</published>
    <updated>2023-02-09T17:51:46.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云原生概念"><a href="#云原生概念" class="headerlink" title="云原生概念"></a>云原生概念</h2><p>说到云，我们都不陌生。我们身边有各种厂商的云产品，例如AWS、GCP、AZure、阿里云、腾讯云等，但是说到云原生这个概念，恐怕就不是单纯的产品上云这么简单了，而是从产品的架构设计、网络规划、拓扑图补全、产品落地、后期运维等步骤中，都需要考虑云产品的特点而进行设计的。</p><p>云原生这个词是近几年伴随着云技术的迅猛发展而流行起来的一个概念，在不同时期我们对于云原生的概念定义也不一样。我这里列出几个比较具有代表性的定义方法：</p><ul><li><p>Heroku于2011年提出了十二因子的应用定义，该定义可以适用于各种编程语言，通常被认为是最早对于云原生的技术定义。<br>其十二因子分别为：**<font color="red">基准代码；依赖；配置；后端服务；构建、发布、运行；进程；端口绑定；并发；易处理；环境等价；日志；进程管理</font>**</p></li><li><p>Pivital于2015年提出了“Cloud Native”的概念：云原生是一种可以充分利用云计算优势的构建和运行应用的方法。主要包括以下要素：**<font color="red">Devops；持续交付；微服务；容器</font>**</p></li><li><p>云原生计算基金会对于云原生定义的最新版本是：云原生的代表技术为**<font color="red">容器、服务网格、微服务、不可变基础设施、声明式API</font>**</p></li><li><p>阿里巴巴对云原生的定义：云原生是一条使用户能低心智负担的、敏捷的、以可扩展可复制的方式，最大限度利用云的能力、发挥云特点的最佳路径。</p></li></ul><p>&amp;nbsp;</p><h2 id="云原生的定位及意义"><a href="#云原生的定位及意义" class="headerlink" title="云原生的定位及意义"></a>云原生的定位及意义</h2><h3 id="云原生是种架构模式及软件开发的新的思想理念"><a href="#云原生是种架构模式及软件开发的新的思想理念" class="headerlink" title="云原生是种架构模式及软件开发的新的思想理念"></a>云原生是种架构模式及软件开发的新的思想理念</h3><ul><li><p>云原生基于云计算理念的深化，是面向云应用设计的一种新的架构设计理念</p></li><li><p>充分发挥云效能的最佳实践路径</p></li><li><p>帮助企业构建弹性可靠、松耦合、易管理可观测的应用系统</p></li><li><p>提升交付效率，降低运维复杂度</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-16-31-17-linian.png"></p><h3 id="云原生架构与传统架构对比"><a href="#云原生架构与传统架构对比" class="headerlink" title="云原生架构与传统架构对比"></a>云原生架构与传统架构对比</h3><ul><li>传统软件架构，用户不仅仅需要关注基础设施的能力及其运维，还需要采购及维护大量的第三方软件以及非功能性能力，降低软件开发效率，并且没有充分利用云计算IaaS与PaaS的能力。</li><li>从技术的角度，云原生架构是基于云原生技术的一组架构原则和设计模式的集合，旨在将云应用中<br>的非业务代码部分进行最大化的剥离，从而让云设施接管应用中原有的大量非功能特性(如弹性、<br>韧性、安全、可观测性、灰度等)，使业务不再有非功能性业务中断困扰的同时，具备轻量、敏捷、<br>高度自动化的特点。</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-16-32-19-duibi.png"></p><h3 id="云原生技术改变了软件开发及运维模式"><a href="#云原生技术改变了软件开发及运维模式" class="headerlink" title="云原生技术改变了软件开发及运维模式"></a>云原生技术改变了软件开发及运维模式</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-16-33-11-moshi.png"></p><h3 id="容器技术（docker）"><a href="#容器技术（docker）" class="headerlink" title="容器技术（docker）"></a>容器技术（docker）</h3><p>容器技术处在云原生的技术栈中的底层一环，是保证云原生能实现的基础。其包括3个核心：</p><ul><li><p>镜像：没有生命周期的打包制品</p></li><li><p>容器：具有生命周期的运行态</p></li><li><p>容器仓库：存储镜像的仓库</p></li></ul><p>三者的关系如下：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/02-17-48-36-docker.png"></p><p>它们之间的调用关系如下：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/02-17-51-55-diaoyong.png"></p><p>由于Dockerfile是提前写好的，所以镜像打包时的规格是一致的，但是不同需求下，可以添加不同的参数，如添加存储卷、添加映射端口、是否后台运行等，这时容器的状态会有不同。</p><h3 id="容器编排技术（kubernetes）"><a href="#容器编排技术（kubernetes）" class="headerlink" title="容器编排技术（kubernetes）"></a>容器编排技术（kubernetes）</h3><p>随着容器规模的越来越大，节点规模也会变大，我们对容器的管理也更加复杂。而容器编排技术就是为了解决在多集群节点中更好地管理容器应用的解决方案。</p><p>Kubernetes是目前使用最广泛的容器编排技术。在传统时代，我们需要操作系统来管理硬件资源，在操作系统基础上来部署软件和应用；而在云原生的理念当中，Kubernetes就扮演着操作系统的作用。它通过已知的不可变基础设施，通过声明式API来管理和调度各种应用资源，例如Pod、Service、Deployment、Statefulset、PV、PVC、Daemonset、ingress-gateway等。</p><p>Kubernetes的核心功能有以下几项：</p><p>● 服务发现与负载均衡<br>● 容器的自动装箱<br>● 存储编排<br>● 自动化容器恢复<br>● 自动发布与回顾<br>● 批量与密文管理<br>● 批量执行<br>● 水平伸缩</p><p>可以看到，kubernetes可以说是非常全能的一套容器编排解决方案，而它的架构是master-node，master节点会有控制模块，而node节点会有通信组件、网络代理和容器运行时。二者的架构如图所示：</p><h5 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h5><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-02-25-core.png"></p><h5 id="主节点架构"><a href="#主节点架构" class="headerlink" title="主节点架构"></a>主节点架构</h5><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-02-48-master.png"></p><h5 id="工作节点架构"><a href="#工作节点架构" class="headerlink" title="工作节点架构"></a>工作节点架构</h5><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-03-07-node.png"></p><p>其中，Kubelet是个服务，kube-proxy有两种方式：iptables或ipvs, CRI是容器运行时</p><h4 id="Kubernetes应用场景"><a href="#Kubernetes应用场景" class="headerlink" title="Kubernetes应用场景"></a>Kubernetes应用场景</h4><ul><li><p>典型调度场景<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-08-32-statement1.png"></p></li><li><p>调度<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-08-59-schedule.png"></p></li><li><p>自动恢复<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-09-24-auto-recovery.png"></p></li><li><p>弹性伸缩<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-09-53-autoscaler.png"></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单介绍了：</p><ul><li><p>云原生概念</p></li><li><p>云原生的定位与意义</p></li><li><p>容器技术-Docker</p></li><li><p>容器编排技术-Kubernetes</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://www.cnblogs.com/young233/p/10958624.html">docker入门1–简介、安装 - eryoung2 - 博客园</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/young233/p/10961741.html">docker入门2–生命周期 - eryoung2 - 博客园</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/young233/p/15119748.html">kubernetes 搭建集群 - eryoung2 - 博客园</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/young233/p/15145682.html">k8s 五个重要概念 - eryoung2 - 博客园</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;云原生概念&quot;&gt;&lt;a href=&quot;#云原生概念&quot; class=&quot;headerlink&quot; title=&quot;云原生概念&quot;&gt;&lt;/a&gt;云原生概念&lt;/h2&gt;&lt;p&gt;说到云，我们都不陌生。我们身边有各种厂商的云产品，例如AWS、GCP、AZure、阿里云、腾讯云等，但是说到云原生这</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - 考试大纲</title>
    <link href="http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <id>http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</id>
    <published>2023-01-31T05:42:59.000Z</published>
    <updated>2023-02-02T15:32:29.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACP云原生容器工程师-大纲简介"><a href="#ACP云原生容器工程师-大纲简介" class="headerlink" title="ACP云原生容器工程师 - 大纲简介"></a>ACP云原生容器工程师 - 大纲简介</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-13-59-20-dagang.png" alt="imagepng"></p><h2 id="ACP云原生容器工程师-所需知识"><a href="#ACP云原生容器工程师-所需知识" class="headerlink" title="ACP云原生容器工程师 - 所需知识"></a>ACP云原生容器工程师 - 所需知识</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-13-59-29-zhishi.png" alt="imagepng"></p><h2 id="ACP云原生容器工程师-考试范围"><a href="#ACP云原生容器工程师-考试范围" class="headerlink" title="ACP云原生容器工程师 - 考试范围"></a>ACP云原生容器工程师 - 考试范围</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-13-59-37-fanwei.png"></p><h2 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h2><ul><li>云原生通识技术: **<font color="red">云原生定义、核心技术、典型架构&#x2F;技术、Docker&#x2F;K8s功能特点、核心组件、应用实践</font>**等。</li><li>ACK: **<font color="red">概念(ACK)三种形态、架构、功能、优势、应用场景、生命周期；网络、存储、日志监控的使用；ACK弹性伸缩、集群管理、应用发布管理、安全管理体系</font>**等。</li><li>ASK: **<font color="red">ASK与ACK区别、使用场景、核心功能、组件；ASK具体配置和操作，ASK集群管理、应用管理、网络、存储、日志、监控；集群弹性伸缩；ASK使用中的注意事项、安全管理</font>**等。</li><li>ASM: **<font color="red">服务网格的概念、优势、架构特点、应用场景；ASM核心功能使用：授权管理、网格诊断、入口网关配置、流量管理、可观测性管理等；构建ASM统一网格、构建统一的管理系统；ASM注意点及解决方法</font>**。</li><li>ACR: **<font color="red">Docker基本概念、ACR基本概念、二者关系、异同点、适用场景、ACR默认实例版和企业版核心功能；ACR操作和配置(创建、网络、权限、交付链管理、镜像安全扫描及加速等)；ACR注意事项、解决常见问题</font>**。</li><li>ACK@Edge: **<font color="red">熟悉基础概念(边缘容器场景、云边一体化协同等)；ACK@Edge的具体操作和配置、可视化管理；ACK@Edge的统一管理和统一生命周期</font>**等。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>ACK(<a href="https://help.aliyun.com/product/85222.html?spm=a2c4g.750001.list.167.18987b13uyzIJ4">容器服务 ACK-阿里云帮助中心</a>)</li><li>ASK(<a href="https://help.aliyun.com/knowledge_list/127525.html?spm=5176.11065259.1996646101.8.b1602d4b6rgCT2">Serverless容器集群ASK_容器服务Kubernetes版-阿里云帮助中心</a>)</li><li>服务网格 – ASM(<a href="https://help.aliyun.com/product/147365.html?spm=5176.10695662.3291411370.5.35ce19eaTCBBaV">服务网格 ASM-阿里云帮助中心</a>)</li><li>容器镜像服务(<a href="https://help.aliyun.com/document_detail/60945.html?spm=5176.10695662.1362911.4.54b639f3wLxseL">https://help.aliyun.com/document_detail/60945.html?spm=5176.10695662.1362911.4.54b639f3wLxseL</a>)</li><li>边缘容器服务(<a href="https://help.aliyun.com/document_detail/163259.html?spm=5176.10695662.8115314850.4.3b34a67b2O6mFx">什么是ACK@Edge_容器服务Kubernetes版-阿里云帮助中心</a>)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ACP云原生容器工程师-大纲简介&quot;&gt;&lt;a href=&quot;#ACP云原生容器工程师-大纲简介&quot; class=&quot;headerlink&quot; title=&quot;ACP云原生容器工程师 - 大纲简介&quot;&gt;&lt;/a&gt;ACP云原生容器工程师 - 大纲简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>《在那遥远的地方》-- 王洛宾</title>
    <link href="http://eryoung2.github.io/2022/12/18/%E3%80%8A%E5%9C%A8%E9%82%A3%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%8B-%E7%8E%8B%E6%B4%9B%E5%AE%BE/"/>
    <id>http://eryoung2.github.io/2022/12/18/%E3%80%8A%E5%9C%A8%E9%82%A3%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%8B-%E7%8E%8B%E6%B4%9B%E5%AE%BE/</id>
    <published>2022-12-18T14:43:22.000Z</published>
    <updated>2022-12-18T14:46:57.620Z</updated>
    
    <content type="html"><![CDATA[<p>在那遥远的地方，有位好姑娘，<br>人们走过了她的帐房 ，都要回头留恋地张望。  </p><p>她那粉红的笑脸，好像红太阳，<br>她那活泼动人的眼睛，好像晚上明媚的月亮。    </p><p>我愿变一只小羊，跟在她身旁，<br>我愿她拿着细细的皮鞭，不断轻轻的打在我身上。<br>我愿她拿着细细的皮鞭，不断轻轻的打在我身上。</p><p>有位好姑娘，人们走过了她的帐房，都要回头留恋地张望。    </p><p>她那粉红的笑脸，好像红太阳，<br>她那美丽动人的眼睛，好像晚上明媚的月亮。</p><p>我愿抛弃了财产，跟她去放羊，<br>每天看着那粉红的笑脸，和那美丽金边的衣裳。</p><p>我愿做一只小羊，跟在她身旁，<br>我愿她拿着细细的皮鞭，不断轻轻的打在我身上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在那遥远的地方，有位好姑娘，&lt;br&gt;人们走过了她的帐房 ，都要回头留恋地张望。  &lt;/p&gt;
&lt;p&gt;她那粉红的笑脸，好像红太阳，&lt;br&gt;她那活泼动人的眼睛，好像晚上明媚的月亮。    &lt;/p&gt;
&lt;p&gt;我愿变一只小羊，跟在她身旁，&lt;br&gt;我愿她拿着细细的皮鞭，不断轻轻的打在我身</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="民歌" scheme="http://eryoung2.github.io/tags/%E6%B0%91%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码(比较全的版本)</title>
    <link href="http://eryoung2.github.io/2022/09/30/HTTP%E7%8A%B6%E6%80%81%E7%A0%81-%E6%AF%94%E8%BE%83%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>http://eryoung2.github.io/2022/09/30/HTTP%E7%8A%B6%E6%80%81%E7%A0%81-%E6%AF%94%E8%BE%83%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC/</id>
    <published>2022-09-30T12:44:00.000Z</published>
    <updated>2022-09-30T12:47:36.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx-信息相应"><a href="#1xx-信息相应" class="headerlink" title="1xx: 信息相应"></a>1xx: 信息相应</h2><p>100: Continue, 客户端继续请求<br>101: Switching Protocal，切换协议，响应客户端的请求头<br>102: Processing，服务器收到正在处理，没有响应可用<br>103: Early Hints, 主要用于与 Link 链接头一起使用，以允许用户代理在服务器准备响应阶段时开始预加载 preloading 资源。</p><h2 id="2xx-成功响应"><a href="#2xx-成功响应" class="headerlink" title="2xx: 成功响应"></a>2xx: 成功响应</h2><p>200: OK, 相应成功<br>201: Created，请求成功，因此创建一个新资源<br>202: Accepted，请求收到，但未响应<br>203: Non-Authoritative Information, 服务器已处理请求，但是返回的不是原始服务器的确定集合，而是来自本地或第三方的拷贝<br>204：No Content, 对于该请求没有的内容可发送，但头部字段可能有用。用户代理可能会用此时请求头部信息来更新原来资源的头部缓存字段。<br>205：Reset Content, 告诉用户代理重置发送此请求的文档。<br>206: Partial Content, 客户端部分请求资源被响应。<br>207：Multi-Status, 对于多个状态代码都可能合适的情况，传输有关多个资源的信息。<br>208：Already Reported, 在 DAV 里面使用 dav:propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。<br>226: IM Used, 服务器已经完成了对资源的GET请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。</p><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h2><p>300：Multiple Choice, 多个可能的响应。<br>301：Moved Permanently，永久重定向。<br>302：Found，临时重定向。<br>303：See Other，从其他URL进行进一步改变。<br>304: Not Modified, 未更改，可用缓存。<br>305：Use Proxy，使用代理。<br>306：unused，没用了。<br>307：Temporary Redirect, 临时重定向，等同于302。<br>308：Permanent Redirect, 永久重定向，等同于301。</p><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h2><p>400: Bad request, 请求错误<br>401: Unauthorized, 未进行身份验证。<br>402: Payment Required，将代码保留并留到未来使用。<br>403: Forbidden, 无权限访问。<br>404：Not Found, 找不到请求资源。<br>405: Method not allowed，目标资源不支持该方法。<br>406：Not Acceptable, 当 web 服务器在执行服务端驱动型内容协商机制后，没有发现任何符合用户代理给定标准的内容时，就会发送此响应。<br>407：Proxy Authentication Required, 代理未进行身份认证。<br>408: Request Timeout，请求超时。<br>409: Conflict, 请求冲突。<br>410：Gone，当请求的内容已从服务器中永久删除且没有转发地址时，将发送此响应。<br>411：Length Required，请求头部的Content-Length未定义。<br>412：Precondition Failed, 客户端在头部指出了服务器不满足的先决条件。<br>413:Payload Too Large, 请求实体大于服务器定义的限制。<br>414：URL Too Long, URL超过服务器规定。<br>415: Unsupported Media Type, 服务器不支持的媒体格式。<br>416: Range not Satisfiable, 请求头部的Range字段不满足。<br>417: Exceptation Failed, 无法满足Except请求标头字段所指示的期望。<br>418: I am a teapot, 拒绝用茶壶煮咖啡？<br>421: Misdirected Request, 请求被定向到无法相应的服务器。<br>422: Unprocessable Entity, 请求格式正确，但语义错误。<br>423: Locked, 访问资源被锁。<br>424: Failed Dependency, 因为前一个请求失败而请求失败。<br>425: Too early, 服务器不愿冒险处理可能被重播的请求。<br>426: Upgrade Required, 拒绝使用当前协议执行请求。<br>428: Precondition Required, 源服务器要求请求是有条件的。此响应旨在防止’丢失更新’问题，即当第三方修改服务器上的状态时，客户端 GET 获取资源的状态，对其进行修改并将其 PUT 放回服务器，从而导致冲突。<br>429: Too many requires, 请求过多。<br>431: Request Header Fields Too Large, 请求字段太大，减小之后可以重新提交请求。<br>451: Unavailable For Legal Reason, 用户代理请求了无法合法提供的资源。<br>499：Client Closed Request, 客户端主动断开连接。</p><h2 id="5xx-服务端错误响应"><a href="#5xx-服务端错误响应" class="headerlink" title="5xx: 服务端错误响应"></a>5xx: 服务端错误响应</h2><p>500: Internal Server Error，服务器内部问题。<br>501: Not Implemented，服务器不支持请求方法。<br>502: Bad Gateway, 服务器作为网关得到错误响应。<br>503: Service Unavailable, 服务不可用。<br>504: Gateway Timeout, 服务器充当网关未获取响应。<br>505: HTTP Version Not Supported, HTTP版本不对。<br>506: Variant Also Negotiates, 服务器存在内部配置错误。<br>507: Insufficient Storage, 无法在资源上执行该方法。<br>508: Loop Detected，服务器处理请求时循环了。<br>510: Not extended, 服务器需要对请求进行扩展才能完成请求。<br>511: Network Authentication Required, 客户端需要进行身份验证才可以访问网络资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1xx-信息相应&quot;&gt;&lt;a href=&quot;#1xx-信息相应&quot; class=&quot;headerlink&quot; title=&quot;1xx: 信息相应&quot;&gt;&lt;/a&gt;1xx: 信息相应&lt;/h2&gt;&lt;p&gt;100: Continue, 客户端继续请求&lt;br&gt;101: Switching Pro</summary>
      
    
    
    
    <category term="面试" scheme="http://eryoung2.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="HTTP" scheme="http://eryoung2.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>jenkins docker安装时插件缺失</title>
    <link href="http://eryoung2.github.io/2022/09/19/jenkins-docker%E5%AE%89%E8%A3%85%E6%97%B6%E6%8F%92%E4%BB%B6%E7%BC%BA%E5%A4%B1/"/>
    <id>http://eryoung2.github.io/2022/09/19/jenkins-docker%E5%AE%89%E8%A3%85%E6%97%B6%E6%8F%92%E4%BB%B6%E7%BC%BA%E5%A4%B1/</id>
    <published>2022-09-18T16:37:45.000Z</published>
    <updated>2022-09-18T16:44:50.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天又试着装了一下docker版的jenkins，今天用了<font color="red">jenkins:2.60.3</font>这个镜像，发现某些插件没有，导致安装不成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">an error occurred during installation:No such plugin: cloudbees-folder</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我检查了一大圈，发现这个带版本的镜像<font color="red">jenkins:2.60.3</font>的确没有此插件，从其他地方下载也没办法放到镜像里边去，所以需要换一个jenkins镜像。</p><p>换到<font color="red">jenkins&#x2F;jenkins</font>就好了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来发现之前写的文章，发现用的就是这个<font color="red">jenkins&#x2F;jenkins</font>镜像，词镜像里的插件比较全，就没遇到类似问题。</p><h2 id="文章链接："><a href="#文章链接：" class="headerlink" title="文章链接："></a>文章链接：</h2><blockquote><p><a href="https://www.cnblogs.com/young233/p/14815787.html">docker 安装jenkins - eryoung2 - 博客园</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天又试着装了一下docker版的jenkins，今天用了&lt;font color=&quot;red&quot;&gt;jenkins:2.60.3&lt;/font&gt;这个</summary>
      
    
    
    
    <category term="工具使用" scheme="http://eryoung2.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="jenkins" scheme="http://eryoung2.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>linux添加BBR加速</title>
    <link href="http://eryoung2.github.io/2022/09/16/linux%E6%B7%BB%E5%8A%A0BBR%E5%8A%A0%E9%80%9F/"/>
    <id>http://eryoung2.github.io/2022/09/16/linux%E6%B7%BB%E5%8A%A0BBR%E5%8A%A0%E9%80%9F/</id>
    <published>2022-09-15T20:15:28.000Z</published>
    <updated>2022-09-15T20:16:36.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BBR简介"><a href="#BBR简介" class="headerlink" title="BBR简介"></a>BBR简介</h2><p>TCP BBR是由来自Google的 Neal Cardwell 和 Yuchung Cheng 发表的新的TCP拥塞控制算法，目前已经在Google内部大范围使用并且随着linux 4.9版本正式发布。可大幅提升上网的访问速度。</p><h2 id="BBR添加"><a href="#BBR添加" class="headerlink" title="BBR添加"></a>BBR添加</h2><ol><li>查看内核版本，需要大于4.9</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><ol start="2"><li>开启BBR</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ol start="3"><li>生效</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ol start="4"><li>检查状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文只是记录BBR使用方法，至于通信原理尚在研读当中，如有进展会再出一篇文章进行讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BBR简介&quot;&gt;&lt;a href=&quot;#BBR简介&quot; class=&quot;headerlink&quot; title=&quot;BBR简介&quot;&gt;&lt;/a&gt;BBR简介&lt;/h2&gt;&lt;p&gt;TCP BBR是由来自Google的 Neal Cardwell 和 Yuchung Cheng 发表的新的TCP拥</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
