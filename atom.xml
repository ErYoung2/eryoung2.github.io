<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eryoung2的个人博客</title>
  
  <subtitle>ErYoung2写字的地方</subtitle>
  <link href="http://eryoung2.github.io/atom.xml" rel="self"/>
  
  <link href="http://eryoung2.github.io/"/>
  <updated>2023-02-11T06:56:07.985Z</updated>
  <id>http://eryoung2.github.io/</id>
  
  <author>
    <name>ErYoung2</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ACP云原生容器工程师-ACK操作</title>
    <link href="http://eryoung2.github.io/2023/02/11/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%93%8D%E4%BD%9C/"/>
    <id>http://eryoung2.github.io/2023/02/11/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%93%8D%E4%BD%9C/</id>
    <published>2023-02-11T06:47:30.000Z</published>
    <updated>2023-02-11T06:56:07.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li>授权账号(RBAC&#x2F;RAM)</li><li>创建集群(专有版、托管版、serverless版)</li><li>部署应用(镜像、模板)</li><li>运维管理(运维集群、运维应用)</li></ol><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-00-ji1.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-10-ji2.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-31-ji4.png"></p><h3 id="集群查看"><a href="#集群查看" class="headerlink" title="集群查看"></a>集群查看</h3><p>查看集群的基本信息、连接信息、集群资源、集群日志及集群时区</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-53-47-ji5.png"></p><h2 id="连接集群的方式"><a href="#连接集群的方式" class="headerlink" title="连接集群的方式"></a>连接集群的方式</h2><ul><li><p>使用kubectl直接连接集群</p></li><li><p>使用CloudShell通过kubectl连接集群</p></li><li><p>通过SSH连接集群</p></li><li><p>使用ServiceAccount Token访问集群</p></li><li><p>通过公网访问集群API Server</p></li></ul><h2 id="创建无状态集群（Deployment）"><a href="#创建无状态集群（Deployment）" class="headerlink" title="创建无状态集群（Deployment）"></a>创建无状态集群（Deployment）</h2><h3 id="镜像创建"><a href="#镜像创建" class="headerlink" title="镜像创建"></a>镜像创建</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-01-wu1.png"></p><h3 id="应用基本信息"><a href="#应用基本信息" class="headerlink" title="应用基本信息"></a>应用基本信息</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-14-wu2.png"></p><h3 id="容器配置"><a href="#容器配置" class="headerlink" title="容器配置"></a>容器配置</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-36-wu3.png"></p><p>拉取镜像的3种方式：自动更新、手动更新、默认本地</p><h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-50-wu4.png"></p><h3 id="创建并查看"><a href="#创建并查看" class="headerlink" title="创建并查看"></a>创建并查看</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-54-59-wu5.png"></p><h2 id="有状态应用（Statefulset）"><a href="#有状态应用（Statefulset）" class="headerlink" title="有状态应用（Statefulset）"></a>有状态应用（Statefulset）</h2><h3 id="有状态应用和无状态应用区别："><a href="#有状态应用和无状态应用区别：" class="headerlink" title="有状态应用和无状态应用区别："></a>有状态应用和无状态应用区别：</h3><p>无状态应用与持久化组件无关（例如Volumn、DB等），应用挂掉重启之后，与持久化组件就断开了；有状态应用与持久化组件有关，应用挂掉重启之后，与持久化组件仍有关系。</p><h3 id="Statefulset应用集特点"><a href="#Statefulset应用集特点" class="headerlink" title="Statefulset应用集特点"></a>Statefulset应用集特点</h3><ul><li><p>稳定且需要唯一的应用标识符</p></li><li><p>稳定且持久的存储</p></li><li><p>要求有序、平滑的部署和扩展</p></li><li><p>要求有序、平滑的终止和删除</p></li><li><p>有序的滚动更新</p></li><li><p>Statefulset可能创建的三种资源类型：PVC、Pod、ControllerRevision</p></li></ul><h2 id="创建有状态应用"><a href="#创建有状态应用" class="headerlink" title="创建有状态应用"></a>创建有状态应用</h2><h3 id="镜像创建-1"><a href="#镜像创建-1" class="headerlink" title="镜像创建"></a>镜像创建</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-23-you1.png"></p><h3 id="容器配置（数据卷）"><a href="#容器配置（数据卷）" class="headerlink" title="容器配置（数据卷）"></a>容器配置（数据卷）</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-33-you2.png"></p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-43-you3.png"></p><p>可添加云盘、NAS、OSS</p><h3 id="高级配置-1"><a href="#高级配置-1" class="headerlink" title="高级配置"></a>高级配置</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-55-55-you4.png"></p><h3 id="创建并查看-1"><a href="#创建并查看-1" class="headerlink" title="创建并查看"></a>创建并查看</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/11-14-56-03-you5.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>ACK入门操作指引</p></li><li><p>ACK集群入门操作指引</p></li><li><p>ACK创建无状态应用</p></li><li><p>ACK创建有状态应用</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作流程&quot;&gt;&lt;a href=&quot;#操作流程&quot; class=&quot;headerlink&quot; title=&quot;操作流程&quot;&gt;&lt;/a&gt;操作流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;授权账号(RBAC&amp;#x2F;RAM)&lt;/li&gt;
&lt;li&gt;创建集群(专有版、托管版、serverless版)&lt;/</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK Pro概述</title>
    <link href="http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK-Pro%E6%A6%82%E8%BF%B0/"/>
    <id>http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK-Pro%E6%A6%82%E8%BF%B0/</id>
    <published>2023-02-10T10:04:53.000Z</published>
    <updated>2023-02-10T10:15:36.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACK-Pro集群概述"><a href="#ACK-Pro集群概述" class="headerlink" title="ACK Pro集群概述"></a>ACK Pro集群概述</h2><h3 id="对比ACK托管版集群"><a href="#对比ACK托管版集群" class="headerlink" title="对比ACK托管版集群"></a>对比ACK托管版集群</h3><ul><li><p>相比ACK托管版，针对企业版大规模生产环境进一步增强了可靠性、安全性</p></li><li><p>继承了原托管版集群的所有优势</p></li><li><p>提供可赔付的SLA的Kubernetes集群</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-08-24-vs%20ack%20tuoguan.png"></p><h3 id="对比标准版集群"><a href="#对比标准版集群" class="headerlink" title="对比标准版集群"></a>对比标准版集群</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-08-37-vs%20biaozhun.png"></p><h2 id="ACK-Pro各种集群"><a href="#ACK-Pro各种集群" class="headerlink" title="ACK Pro各种集群"></a>ACK Pro各种集群</h2><h3 id="可靠性强化集群"><a href="#可靠性强化集群" class="headerlink" title="可靠性强化集群"></a>可靠性强化集群</h3><p>更可靠的托管Master节点，API Server自动弹性，保证集群平滑扩容海量节点。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-09-39-kekao.png"></p><h3 id="安全性强化集群"><a href="#安全性强化集群" class="headerlink" title="安全性强化集群"></a>安全性强化集群</h3><p>开放安全管理，并提供针对运行中容器更强检测和自动修复能力的安全管理高级版，与KMS结合会更安全。</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-09-49-anquan.png"></p><h3 id="调度性强化集群"><a href="#调度性强化集群" class="headerlink" title="调度性强化集群"></a>调度性强化集群</h3><ul><li><p>集成更强调度性能的kube-scheduler，支持多种智能调度算法</p></li><li><p>优化在大规模数据计算、高性能数据处理等业务场景下的容器调度能力</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-10-00-diaodu.png"></p><h3 id="ACK-Pro显著特点"><a href="#ACK-Pro显著特点" class="headerlink" title="ACK Pro显著特点"></a>ACK Pro显著特点</h3><ul><li><p>可靠的强化集群</p></li><li><p>提升安全性的集群</p></li><li><p>调度能力更强</p></li></ul><h4 id="ACK-Pro版适用行业"><a href="#ACK-Pro版适用行业" class="headerlink" title="ACK Pro版适用行业"></a>ACK Pro版适用行业</h4><ul><li><p>金融企业</p></li><li><p>互联网企业</p></li><li><p>大数据计算企业</p></li><li><p>开展中国业务的海外企业</p></li></ul><h2 id="ACK-Pro适用场景"><a href="#ACK-Pro适用场景" class="headerlink" title="ACK Pro适用场景"></a>ACK Pro适用场景</h2><h3 id="弹性伸缩架构"><a href="#弹性伸缩架构" class="headerlink" title="弹性伸缩架构"></a>弹性伸缩架构</h3><ul><li><p>容器服务可以根据业务流量自动对业务扩容、缩容，不需要人工干预</p></li><li><p>避免流量激增扩容不及时导致系统挂掉，以及平时大量资源闲置</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-14-45-shensuo.png"></p><h3 id="DevOps持续交付"><a href="#DevOps持续交付" class="headerlink" title="DevOps持续交付"></a>DevOps持续交付</h3><h3 id="云原生AI"><a href="#云原生AI" class="headerlink" title="云原生AI"></a>云原生AI</h3><ul><li><p>深度学习的三个核心问题：性能、效率、成本</p></li><li><p>ACK Pro无缝整合了云的计算、存储、负载均衡等服务，同时贯穿了深度学习的全生命周期</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-14-55-cncf.png"></p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul><li><p>企业生产环境中，通过合理微服务拆分，将每个微服务应用存储在阿里云镜像帮您管理</p></li><li><p>您只需迭代每个微服务应用，有阿里云容器服务ACK提供调度、编排、部署、灰度发布</p></li><li><p>帮助企业快速实现敏捷开发和部署落地，加速企业业务迭代</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-15-18-microservice.png"></p><h3 id="混合云架构"><a href="#混合云架构" class="headerlink" title="混合云架构"></a>混合云架构</h3><ul><li><p>在容器服务控制台上同时管理云上云下的资源，不需要在多种云管理控制台中反复切换</p></li><li><p>基于容器基础设施无关的特性，使用同一套镜像和编排同时在云上云下部署应用</p></li><li><p>基于阿里云容器服务ACK实现统一运维多个云端资源</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-18-15-31-mixcloud.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>ACK Pro集群概述，与ACK托管版和ACK标准版对比</p></li><li><p>ACK Pro各种集群：可靠性强化集群、安全性强化集群、调度性强化集群</p></li><li><p>ACK Pro显著特点、适用行业</p></li><li><p>ACK适用场景：弹性伸缩架构、DevOps持续交付、云原生AI、微服务架构、混合云架构</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ACK-Pro集群概述&quot;&gt;&lt;a href=&quot;#ACK-Pro集群概述&quot; class=&quot;headerlink&quot; title=&quot;ACK Pro集群概述&quot;&gt;&lt;/a&gt;ACK Pro集群概述&lt;/h2&gt;&lt;h3 id=&quot;对比ACK托管版集群&quot;&gt;&lt;a href=&quot;#对比ACK托管</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-ACK概述</title>
    <link href="http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%A6%82%E8%BF%B0/"/>
    <id>http://eryoung2.github.io/2023/02/10/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-ACK%E6%A6%82%E8%BF%B0/</id>
    <published>2023-02-09T17:46:34.000Z</published>
    <updated>2023-02-09T17:50:32.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACK简介"><a href="#ACK简介" class="headerlink" title="ACK简介"></a>ACK简介</h2><p>阿里云容器服务ACK，是阿里云针对云原生推出的拳头产品，基于原版Kubernetes进行适配和增强，简化集群的搭建和运维工作，整合阿里云虚拟化、存储、网络和安全能力，使得扩容和缩容更加简易，打造云端最佳的Kubernetes容器化应用运行环境。</p><h2 id="ACK分类"><a href="#ACK分类" class="headerlink" title="ACK分类"></a>ACK分类</h2><p>ACK产品根据运维整合度，可分为三类：</p><ul><li><p><strong>专有版Kubernetes</strong></p></li><li><p><strong>托管版Kubernetes</strong></p></li><li><p><strong>Serverless Kubernetes</strong></p></li></ul><p>三者的特点和区别如下：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-01-50-02-diff.png"></p><p>适用人群分别为：</p><ul><li><p>专业版ACK：懂技术、有运维K8S的能力、资源规划明显、Master节点定制、完全自营、成本不敏感</p></li><li><p>托管版ACK: Kubernetes能上手、不关心Master节点、只部署应用、降低成本</p></li><li><p>Serverless Kubernetes：批量任务、突发扩容、开箱即用、零运维、按量付费、不关注基础设施</p></li></ul><h4 id="ACK-vs-原生K8S"><a href="#ACK-vs-原生K8S" class="headerlink" title="ACK vs 原生K8S"></a>ACK vs 原生K8S</h4><ul><li><p>ACK基于原生K8S</p></li><li><p>ACK整合阿里云虚拟化、网络、存储、安全能力</p></li><li><p>高性能可伸缩能力加强</p></li><li><p>简化集群的运维和扩容工作，更专注应用开发</p></li></ul><p>也可参考此图：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-01-50-14-diff2.png"></p><h2 id="ACK核心功能"><a href="#ACK核心功能" class="headerlink" title="ACK核心功能"></a>ACK核心功能</h2><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>通过控制台一键创建Kubernetes集群，支持跨可用区高可用。</p><p>特点如下：</p><ul><li><p>集群形态：支持ACK&#x2F;ACK Pro&#x2F;ASK</p></li><li><p>组件升级：一键升级K8S版本</p></li><li><p>弹性伸缩：支持垂直伸缩、水平伸缩等多种扩容模式</p></li><li><p>多云管理：支持多云、混合云集群管理</p></li><li><p>安全授权：支持RAM授权和RBAC权限管理</p></li></ul><h3 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h3><ul><li><p>一站式容器全生命周期管理</p></li><li><p>应用创建：从镜像、模板的创建，支持环境变量、应用健康的配置</p></li><li><p>应用全生命周期管理：支持应用查看、更新、删除、回滚等</p></li><li><p>应用调度：支持节点亲和性调度、应用亲和性和反亲和性调度</p></li><li><p>应用伸缩：支持手动伸缩应用容器实例，HPA自动伸缩策略</p></li><li><p>应用发布：支持灰度发布和蓝绿发布</p></li><li><p>应用目录：支持应用目录，简化云服务集成</p></li></ul><h3 id="存储与网络"><a href="#存储与网络" class="headerlink" title="存储与网络"></a>存储与网络</h3><ul><li><p>整合阿里云虚拟化、网络、存储、安全能力</p></li><li><p>支持阿里云云盘、NAS、OSS等持久化存储支持</p></li><li><p>支持高性能Flannel和Terway容器网络</p></li></ul><h3 id="运维与安全"><a href="#运维与安全" class="headerlink" title="运维与安全"></a>运维与安全</h3><ul><li>提供全方位的安全管理体系：基础架构安全、运行时安全、可信软件供应链安全</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/10-01-50-23-security.png"></p><ul><li><p>监控：支持集群、节点、应用、容器实例监控</p></li><li><p>日志：日志管理及日志查看</p></li><li><p>安全中心：提升容器安全整体纵深防御能力</p></li><li><p>安全沙箱：提供安全沙箱环境，具备独立内核</p></li><li><p>支持机密计算，提供可信执行加密环境</p></li></ul><h3 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h3><ul><li><p>使用场景：在线业务弹性、大规模计算训练、深度学习GPU或共享GPU的训练和推理、定时周期性负载变化等。</p></li><li><p>弹性伸缩维度：弹性层调度、资源层调度</p></li><li><p>调度层组件：容器水平伸缩（HPA）、容器垂直伸缩（VPA）、容器定时伸缩（Cron-HPA）、弹性负载（Elastic-Workload）</p></li></ul><h2 id="容器服务ACK产品优势"><a href="#容器服务ACK产品优势" class="headerlink" title="容器服务ACK产品优势"></a>容器服务ACK产品优势</h2><ul><li><p>强大的集群管理</p></li><li><p>极致弹性的资源扩张</p></li><li><p>一站式容器管理</p></li><li><p>丰富的工作节点</p></li><li><p>最优的IaaS层能力</p></li><li><p>企业级的安全稳定</p></li><li><p>全天候技术支持</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ACK简介&quot;&gt;&lt;a href=&quot;#ACK简介&quot; class=&quot;headerlink&quot; title=&quot;ACK简介&quot;&gt;&lt;/a&gt;ACK简介&lt;/h2&gt;&lt;p&gt;阿里云容器服务ACK，是阿里云针对云原生推出的拳头产品，基于原版Kubernetes进行适配和增强，简化集群的搭建和</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>地址转换技术</title>
    <link href="http://eryoung2.github.io/2023/02/09/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%8A%80%E6%9C%AF/"/>
    <id>http://eryoung2.github.io/2023/02/09/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%8A%80%E6%9C%AF/</id>
    <published>2023-02-09T09:08:14.000Z</published>
    <updated>2023-02-09T09:10:12.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们上网的过程中，不可能只用同一个ip地址来访问，在公网和内网之间，需要一些地址转换来实现公网和内网ip的变化。通常，我们可以使用NAT来做；在公网ip不固定的时候，也需要使用MASQUERADE来做地址转换。</p><h2 id="NAT-Network-Address-Translation"><a href="#NAT-Network-Address-Translation" class="headerlink" title="NAT(Network Address Translation)"></a>NAT(Network Address Translation)</h2><p>我们都知道，在ip数据包中，有两个参数可以定位包的源地址和目的地址，一个是源地址ip，一个是目标地址ip。我们常用的NAT有两种，一种是SNAT，修改源地址；一种是DNAT，修改目标地址。</p><h3 id="SNAT-Source-NAT"><a href="#SNAT-Source-NAT" class="headerlink" title="SNAT(Source NAT)"></a>SNAT(Source NAT)</h3><p>此协议转换包的源地址，通常用于内网ip转公网ip，也就是正向代理会对发出的ip包做SNAT，使其可以传到公网环境中进行下一跳路由动作。</p><p>此修改作用于iptables的POSTROUTING阶段，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s &lt;修改之前的ip段&gt; -o &lt;出口网卡&gt; -j SNAT --to-source &lt;修改之后的ip&gt; </span><br></pre></td></tr></table></figure><h3 id="DNAT-Destination-NAT"><a href="#DNAT-Destination-NAT" class="headerlink" title="DNAT(Destination NAT)"></a>DNAT(Destination NAT)</h3><p>此协议转换包的目的地址，通常用于公网ip转内网ip，也就是反向代理会对收到的ip包做DNAT，使其可以传到内网环境中进行下一跳路由动作。</p><p>此修改作用于iptables的PREROUTING阶段，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d &lt;需要使用的ip地址&gt; -i &lt;入口网卡&gt; -j DNAT --to-destination &lt;修改之前的ip段&gt;</span><br></pre></td></tr></table></figure><h2 id="MASQUERADE-伪装"><a href="#MASQUERADE-伪装" class="headerlink" title="MASQUERADE(伪装)"></a>MASQUERADE(伪装)</h2><p>当我们的网卡绑定的公网ip是动态的，我们就需要动态读取网卡上的ip信息，这时我们使用MASQUERADE协议可以实现。</p><p>当然，MASQUERADE是一种特殊的SNAT，通常用于动态网络环境中，也作用于POSTROUTING阶段。</p><p>具体的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s &lt;修改之前的ip段&gt; -o &lt;出口网卡&gt; MASQUERADE</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在我们上网的过程中，不可能只用同一个ip地址来访问，在公网和内网之间，需要一些地址转换来实现公网和内网ip的变化。通常，我们可以使用NAT来</summary>
      
    
    
    
    <category term="面试" scheme="http://eryoung2.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
    <category term="网络" scheme="http://eryoung2.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师-云原生概要-1</title>
    <link href="http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E8%A6%81-1/"/>
    <id>http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A6%82%E8%A6%81-1/</id>
    <published>2023-01-31T08:04:47.000Z</published>
    <updated>2023-02-09T17:51:46.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云原生概念"><a href="#云原生概念" class="headerlink" title="云原生概念"></a>云原生概念</h2><p>说到云，我们都不陌生。我们身边有各种厂商的云产品，例如AWS、GCP、AZure、阿里云、腾讯云等，但是说到云原生这个概念，恐怕就不是单纯的产品上云这么简单了，而是从产品的架构设计、网络规划、拓扑图补全、产品落地、后期运维等步骤中，都需要考虑云产品的特点而进行设计的。</p><p>云原生这个词是近几年伴随着云技术的迅猛发展而流行起来的一个概念，在不同时期我们对于云原生的概念定义也不一样。我这里列出几个比较具有代表性的定义方法：</p><ul><li><p>Heroku于2011年提出了十二因子的应用定义，该定义可以适用于各种编程语言，通常被认为是最早对于云原生的技术定义。<br>其十二因子分别为：**<font color="red">基准代码；依赖；配置；后端服务；构建、发布、运行；进程；端口绑定；并发；易处理；环境等价；日志；进程管理</font>**</p></li><li><p>Pivital于2015年提出了“Cloud Native”的概念：云原生是一种可以充分利用云计算优势的构建和运行应用的方法。主要包括以下要素：**<font color="red">Devops；持续交付；微服务；容器</font>**</p></li><li><p>云原生计算基金会对于云原生定义的最新版本是：云原生的代表技术为**<font color="red">容器、服务网格、微服务、不可变基础设施、声明式API</font>**</p></li><li><p>阿里巴巴对云原生的定义：云原生是一条使用户能低心智负担的、敏捷的、以可扩展可复制的方式，最大限度利用云的能力、发挥云特点的最佳路径。</p></li></ul><p>&amp;nbsp;</p><h2 id="云原生的定位及意义"><a href="#云原生的定位及意义" class="headerlink" title="云原生的定位及意义"></a>云原生的定位及意义</h2><h3 id="云原生是种架构模式及软件开发的新的思想理念"><a href="#云原生是种架构模式及软件开发的新的思想理念" class="headerlink" title="云原生是种架构模式及软件开发的新的思想理念"></a>云原生是种架构模式及软件开发的新的思想理念</h3><ul><li><p>云原生基于云计算理念的深化，是面向云应用设计的一种新的架构设计理念</p></li><li><p>充分发挥云效能的最佳实践路径</p></li><li><p>帮助企业构建弹性可靠、松耦合、易管理可观测的应用系统</p></li><li><p>提升交付效率，降低运维复杂度</p></li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-16-31-17-linian.png"></p><h3 id="云原生架构与传统架构对比"><a href="#云原生架构与传统架构对比" class="headerlink" title="云原生架构与传统架构对比"></a>云原生架构与传统架构对比</h3><ul><li>传统软件架构，用户不仅仅需要关注基础设施的能力及其运维，还需要采购及维护大量的第三方软件以及非功能性能力，降低软件开发效率，并且没有充分利用云计算IaaS与PaaS的能力。</li><li>从技术的角度，云原生架构是基于云原生技术的一组架构原则和设计模式的集合，旨在将云应用中<br>的非业务代码部分进行最大化的剥离，从而让云设施接管应用中原有的大量非功能特性(如弹性、<br>韧性、安全、可观测性、灰度等)，使业务不再有非功能性业务中断困扰的同时，具备轻量、敏捷、<br>高度自动化的特点。</li></ul><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-16-32-19-duibi.png"></p><h3 id="云原生技术改变了软件开发及运维模式"><a href="#云原生技术改变了软件开发及运维模式" class="headerlink" title="云原生技术改变了软件开发及运维模式"></a>云原生技术改变了软件开发及运维模式</h3><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-16-33-11-moshi.png"></p><h3 id="容器技术（docker）"><a href="#容器技术（docker）" class="headerlink" title="容器技术（docker）"></a>容器技术（docker）</h3><p>容器技术处在云原生的技术栈中的底层一环，是保证云原生能实现的基础。其包括3个核心：</p><ul><li><p>镜像：没有生命周期的打包制品</p></li><li><p>容器：具有生命周期的运行态</p></li><li><p>容器仓库：存储镜像的仓库</p></li></ul><p>三者的关系如下：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/02-17-48-36-docker.png"></p><p>它们之间的调用关系如下：</p><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/02-17-51-55-diaoyong.png"></p><p>由于Dockerfile是提前写好的，所以镜像打包时的规格是一致的，但是不同需求下，可以添加不同的参数，如添加存储卷、添加映射端口、是否后台运行等，这时容器的状态会有不同。</p><h3 id="容器编排技术（kubernetes）"><a href="#容器编排技术（kubernetes）" class="headerlink" title="容器编排技术（kubernetes）"></a>容器编排技术（kubernetes）</h3><p>随着容器规模的越来越大，节点规模也会变大，我们对容器的管理也更加复杂。而容器编排技术就是为了解决在多集群节点中更好地管理容器应用的解决方案。</p><p>Kubernetes是目前使用最广泛的容器编排技术。在传统时代，我们需要操作系统来管理硬件资源，在操作系统基础上来部署软件和应用；而在云原生的理念当中，Kubernetes就扮演着操作系统的作用。它通过已知的不可变基础设施，通过声明式API来管理和调度各种应用资源，例如Pod、Service、Deployment、Statefulset、PV、PVC、Daemonset、ingress-gateway等。</p><p>Kubernetes的核心功能有以下几项：</p><p>● 服务发现与负载均衡<br>● 容器的自动装箱<br>● 存储编排<br>● 自动化容器恢复<br>● 自动发布与回顾<br>● 批量与密文管理<br>● 批量执行<br>● 水平伸缩</p><p>可以看到，kubernetes可以说是非常全能的一套容器编排解决方案，而它的架构是master-node，master节点会有控制模块，而node节点会有通信组件、网络代理和容器运行时。二者的架构如图所示：</p><h5 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h5><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-02-25-core.png"></p><h5 id="主节点架构"><a href="#主节点架构" class="headerlink" title="主节点架构"></a>主节点架构</h5><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-02-48-master.png"></p><h5 id="工作节点架构"><a href="#工作节点架构" class="headerlink" title="工作节点架构"></a>工作节点架构</h5><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-03-07-node.png"></p><p>其中，Kubelet是个服务，kube-proxy有两种方式：iptables或ipvs, CRI是容器运行时</p><h4 id="Kubernetes应用场景"><a href="#Kubernetes应用场景" class="headerlink" title="Kubernetes应用场景"></a>Kubernetes应用场景</h4><ul><li><p>典型调度场景<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-08-32-statement1.png"></p></li><li><p>调度<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-08-59-schedule.png"></p></li><li><p>自动恢复<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-09-24-auto-recovery.png"></p></li><li><p>弹性伸缩<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/02/03-00-09-53-autoscaler.png"></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单介绍了：</p><ul><li><p>云原生概念</p></li><li><p>云原生的定位与意义</p></li><li><p>容器技术-Docker</p></li><li><p>容器编排技术-Kubernetes</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://www.cnblogs.com/young233/p/10958624.html">docker入门1–简介、安装 - eryoung2 - 博客园</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/young233/p/10961741.html">docker入门2–生命周期 - eryoung2 - 博客园</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/young233/p/15119748.html">kubernetes 搭建集群 - eryoung2 - 博客园</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/young233/p/15145682.html">k8s 五个重要概念 - eryoung2 - 博客园</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;云原生概念&quot;&gt;&lt;a href=&quot;#云原生概念&quot; class=&quot;headerlink&quot; title=&quot;云原生概念&quot;&gt;&lt;/a&gt;云原生概念&lt;/h2&gt;&lt;p&gt;说到云，我们都不陌生。我们身边有各种厂商的云产品，例如AWS、GCP、AZure、阿里云、腾讯云等，但是说到云原生这</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>ACP云原生容器工程师 - 考试大纲</title>
    <link href="http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <id>http://eryoung2.github.io/2023/01/31/ACP%E4%BA%91%E5%8E%9F%E7%94%9F%E5%AE%B9%E5%99%A8%E5%B7%A5%E7%A8%8B%E5%B8%88-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</id>
    <published>2023-01-31T05:42:59.000Z</published>
    <updated>2023-02-02T15:32:29.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ACP云原生容器工程师-大纲简介"><a href="#ACP云原生容器工程师-大纲简介" class="headerlink" title="ACP云原生容器工程师 - 大纲简介"></a>ACP云原生容器工程师 - 大纲简介</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-13-59-20-dagang.png" alt="imagepng"></p><h2 id="ACP云原生容器工程师-所需知识"><a href="#ACP云原生容器工程师-所需知识" class="headerlink" title="ACP云原生容器工程师 - 所需知识"></a>ACP云原生容器工程师 - 所需知识</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-13-59-29-zhishi.png" alt="imagepng"></p><h2 id="ACP云原生容器工程师-考试范围"><a href="#ACP云原生容器工程师-考试范围" class="headerlink" title="ACP云原生容器工程师 - 考试范围"></a>ACP云原生容器工程师 - 考试范围</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2023/01/31-13-59-37-fanwei.png"></p><h2 id="考试重点"><a href="#考试重点" class="headerlink" title="考试重点"></a>考试重点</h2><ul><li>云原生通识技术: **<font color="red">云原生定义、核心技术、典型架构&#x2F;技术、Docker&#x2F;K8s功能特点、核心组件、应用实践</font>**等。</li><li>ACK: **<font color="red">概念(ACK)三种形态、架构、功能、优势、应用场景、生命周期；网络、存储、日志监控的使用；ACK弹性伸缩、集群管理、应用发布管理、安全管理体系</font>**等。</li><li>ASK: **<font color="red">ASK与ACK区别、使用场景、核心功能、组件；ASK具体配置和操作，ASK集群管理、应用管理、网络、存储、日志、监控；集群弹性伸缩；ASK使用中的注意事项、安全管理</font>**等。</li><li>ASM: **<font color="red">服务网格的概念、优势、架构特点、应用场景；ASM核心功能使用：授权管理、网格诊断、入口网关配置、流量管理、可观测性管理等；构建ASM统一网格、构建统一的管理系统；ASM注意点及解决方法</font>**。</li><li>ACR: **<font color="red">Docker基本概念、ACR基本概念、二者关系、异同点、适用场景、ACR默认实例版和企业版核心功能；ACR操作和配置(创建、网络、权限、交付链管理、镜像安全扫描及加速等)；ACR注意事项、解决常见问题</font>**。</li><li>ACK@Edge: **<font color="red">熟悉基础概念(边缘容器场景、云边一体化协同等)；ACK@Edge的具体操作和配置、可视化管理；ACK@Edge的统一管理和统一生命周期</font>**等。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>ACK(<a href="https://help.aliyun.com/product/85222.html?spm=a2c4g.750001.list.167.18987b13uyzIJ4">容器服务 ACK-阿里云帮助中心</a>)</li><li>ASK(<a href="https://help.aliyun.com/knowledge_list/127525.html?spm=5176.11065259.1996646101.8.b1602d4b6rgCT2">Serverless容器集群ASK_容器服务Kubernetes版-阿里云帮助中心</a>)</li><li>服务网格 – ASM(<a href="https://help.aliyun.com/product/147365.html?spm=5176.10695662.3291411370.5.35ce19eaTCBBaV">服务网格 ASM-阿里云帮助中心</a>)</li><li>容器镜像服务(<a href="https://help.aliyun.com/document_detail/60945.html?spm=5176.10695662.1362911.4.54b639f3wLxseL">https://help.aliyun.com/document_detail/60945.html?spm=5176.10695662.1362911.4.54b639f3wLxseL</a>)</li><li>边缘容器服务(<a href="https://help.aliyun.com/document_detail/163259.html?spm=5176.10695662.8115314850.4.3b34a67b2O6mFx">什么是ACK@Edge_容器服务Kubernetes版-阿里云帮助中心</a>)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ACP云原生容器工程师-大纲简介&quot;&gt;&lt;a href=&quot;#ACP云原生容器工程师-大纲简介&quot; class=&quot;headerlink&quot; title=&quot;ACP云原生容器工程师 - 大纲简介&quot;&gt;&lt;/a&gt;ACP云原生容器工程师 - 大纲简介&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="考试" scheme="http://eryoung2.github.io/categories/%E8%80%83%E8%AF%95/"/>
    
    
    <category term="阿里云ACP认证" scheme="http://eryoung2.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91ACP%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>《在那遥远的地方》-- 王洛宾</title>
    <link href="http://eryoung2.github.io/2022/12/18/%E3%80%8A%E5%9C%A8%E9%82%A3%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%8B-%E7%8E%8B%E6%B4%9B%E5%AE%BE/"/>
    <id>http://eryoung2.github.io/2022/12/18/%E3%80%8A%E5%9C%A8%E9%82%A3%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%8B-%E7%8E%8B%E6%B4%9B%E5%AE%BE/</id>
    <published>2022-12-18T14:43:22.000Z</published>
    <updated>2022-12-18T14:46:57.620Z</updated>
    
    <content type="html"><![CDATA[<p>在那遥远的地方，有位好姑娘，<br>人们走过了她的帐房 ，都要回头留恋地张望。  </p><p>她那粉红的笑脸，好像红太阳，<br>她那活泼动人的眼睛，好像晚上明媚的月亮。    </p><p>我愿变一只小羊，跟在她身旁，<br>我愿她拿着细细的皮鞭，不断轻轻的打在我身上。<br>我愿她拿着细细的皮鞭，不断轻轻的打在我身上。</p><p>有位好姑娘，人们走过了她的帐房，都要回头留恋地张望。    </p><p>她那粉红的笑脸，好像红太阳，<br>她那美丽动人的眼睛，好像晚上明媚的月亮。</p><p>我愿抛弃了财产，跟她去放羊，<br>每天看着那粉红的笑脸，和那美丽金边的衣裳。</p><p>我愿做一只小羊，跟在她身旁，<br>我愿她拿着细细的皮鞭，不断轻轻的打在我身上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在那遥远的地方，有位好姑娘，&lt;br&gt;人们走过了她的帐房 ，都要回头留恋地张望。  &lt;/p&gt;
&lt;p&gt;她那粉红的笑脸，好像红太阳，&lt;br&gt;她那活泼动人的眼睛，好像晚上明媚的月亮。    &lt;/p&gt;
&lt;p&gt;我愿变一只小羊，跟在她身旁，&lt;br&gt;我愿她拿着细细的皮鞭，不断轻轻的打在我身</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="民歌" scheme="http://eryoung2.github.io/tags/%E6%B0%91%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码(比较全的版本)</title>
    <link href="http://eryoung2.github.io/2022/09/30/HTTP%E7%8A%B6%E6%80%81%E7%A0%81-%E6%AF%94%E8%BE%83%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC/"/>
    <id>http://eryoung2.github.io/2022/09/30/HTTP%E7%8A%B6%E6%80%81%E7%A0%81-%E6%AF%94%E8%BE%83%E5%85%A8%E7%9A%84%E7%89%88%E6%9C%AC/</id>
    <published>2022-09-30T12:44:00.000Z</published>
    <updated>2022-09-30T12:47:36.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx-信息相应"><a href="#1xx-信息相应" class="headerlink" title="1xx: 信息相应"></a>1xx: 信息相应</h2><p>100: Continue, 客户端继续请求<br>101: Switching Protocal，切换协议，响应客户端的请求头<br>102: Processing，服务器收到正在处理，没有响应可用<br>103: Early Hints, 主要用于与 Link 链接头一起使用，以允许用户代理在服务器准备响应阶段时开始预加载 preloading 资源。</p><h2 id="2xx-成功响应"><a href="#2xx-成功响应" class="headerlink" title="2xx: 成功响应"></a>2xx: 成功响应</h2><p>200: OK, 相应成功<br>201: Created，请求成功，因此创建一个新资源<br>202: Accepted，请求收到，但未响应<br>203: Non-Authoritative Information, 服务器已处理请求，但是返回的不是原始服务器的确定集合，而是来自本地或第三方的拷贝<br>204：No Content, 对于该请求没有的内容可发送，但头部字段可能有用。用户代理可能会用此时请求头部信息来更新原来资源的头部缓存字段。<br>205：Reset Content, 告诉用户代理重置发送此请求的文档。<br>206: Partial Content, 客户端部分请求资源被响应。<br>207：Multi-Status, 对于多个状态代码都可能合适的情况，传输有关多个资源的信息。<br>208：Already Reported, 在 DAV 里面使用 dav:propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。<br>226: IM Used, 服务器已经完成了对资源的GET请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。</p><h2 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx: 重定向"></a>3xx: 重定向</h2><p>300：Multiple Choice, 多个可能的响应。<br>301：Moved Permanently，永久重定向。<br>302：Found，临时重定向。<br>303：See Other，从其他URL进行进一步改变。<br>304: Not Modified, 未更改，可用缓存。<br>305：Use Proxy，使用代理。<br>306：unused，没用了。<br>307：Temporary Redirect, 临时重定向，等同于302。<br>308：Permanent Redirect, 永久重定向，等同于301。</p><h2 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx: 客户端错误"></a>4xx: 客户端错误</h2><p>400: Bad request, 请求错误<br>401: Unauthorized, 未进行身份验证。<br>402: Payment Required，将代码保留并留到未来使用。<br>403: Forbidden, 无权限访问。<br>404：Not Found, 找不到请求资源。<br>405: Method not allowed，目标资源不支持该方法。<br>406：Not Acceptable, 当 web 服务器在执行服务端驱动型内容协商机制后，没有发现任何符合用户代理给定标准的内容时，就会发送此响应。<br>407：Proxy Authentication Required, 代理未进行身份认证。<br>408: Request Timeout，请求超时。<br>409: Conflict, 请求冲突。<br>410：Gone，当请求的内容已从服务器中永久删除且没有转发地址时，将发送此响应。<br>411：Length Required，请求头部的Content-Length未定义。<br>412：Precondition Failed, 客户端在头部指出了服务器不满足的先决条件。<br>413:Payload Too Large, 请求实体大于服务器定义的限制。<br>414：URL Too Long, URL超过服务器规定。<br>415: Unsupported Media Type, 服务器不支持的媒体格式。<br>416: Range not Satisfiable, 请求头部的Range字段不满足。<br>417: Exceptation Failed, 无法满足Except请求标头字段所指示的期望。<br>418: I am a teapot, 拒绝用茶壶煮咖啡？<br>421: Misdirected Request, 请求被定向到无法相应的服务器。<br>422: Unprocessable Entity, 请求格式正确，但语义错误。<br>423: Locked, 访问资源被锁。<br>424: Failed Dependency, 因为前一个请求失败而请求失败。<br>425: Too early, 服务器不愿冒险处理可能被重播的请求。<br>426: Upgrade Required, 拒绝使用当前协议执行请求。<br>428: Precondition Required, 源服务器要求请求是有条件的。此响应旨在防止’丢失更新’问题，即当第三方修改服务器上的状态时，客户端 GET 获取资源的状态，对其进行修改并将其 PUT 放回服务器，从而导致冲突。<br>429: Too many requires, 请求过多。<br>431: Request Header Fields Too Large, 请求字段太大，减小之后可以重新提交请求。<br>451: Unavailable For Legal Reason, 用户代理请求了无法合法提供的资源。<br>499：Client Closed Request, 客户端主动断开连接。</p><h2 id="5xx-服务端错误响应"><a href="#5xx-服务端错误响应" class="headerlink" title="5xx: 服务端错误响应"></a>5xx: 服务端错误响应</h2><p>500: Internal Server Error，服务器内部问题。<br>501: Not Implemented，服务器不支持请求方法。<br>502: Bad Gateway, 服务器作为网关得到错误响应。<br>503: Service Unavailable, 服务不可用。<br>504: Gateway Timeout, 服务器充当网关未获取响应。<br>505: HTTP Version Not Supported, HTTP版本不对。<br>506: Variant Also Negotiates, 服务器存在内部配置错误。<br>507: Insufficient Storage, 无法在资源上执行该方法。<br>508: Loop Detected，服务器处理请求时循环了。<br>510: Not extended, 服务器需要对请求进行扩展才能完成请求。<br>511: Network Authentication Required, 客户端需要进行身份验证才可以访问网络资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1xx-信息相应&quot;&gt;&lt;a href=&quot;#1xx-信息相应&quot; class=&quot;headerlink&quot; title=&quot;1xx: 信息相应&quot;&gt;&lt;/a&gt;1xx: 信息相应&lt;/h2&gt;&lt;p&gt;100: Continue, 客户端继续请求&lt;br&gt;101: Switching Pro</summary>
      
    
    
    
    <category term="面试" scheme="http://eryoung2.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="HTTP" scheme="http://eryoung2.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>jenkins docker安装时插件缺失</title>
    <link href="http://eryoung2.github.io/2022/09/19/jenkins-docker%E5%AE%89%E8%A3%85%E6%97%B6%E6%8F%92%E4%BB%B6%E7%BC%BA%E5%A4%B1/"/>
    <id>http://eryoung2.github.io/2022/09/19/jenkins-docker%E5%AE%89%E8%A3%85%E6%97%B6%E6%8F%92%E4%BB%B6%E7%BC%BA%E5%A4%B1/</id>
    <published>2022-09-18T16:37:45.000Z</published>
    <updated>2022-09-18T16:44:50.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天又试着装了一下docker版的jenkins，今天用了<font color="red">jenkins:2.60.3</font>这个镜像，发现某些插件没有，导致安装不成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">an error occurred during installation:No such plugin: cloudbees-folder</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我检查了一大圈，发现这个带版本的镜像<font color="red">jenkins:2.60.3</font>的确没有此插件，从其他地方下载也没办法放到镜像里边去，所以需要换一个jenkins镜像。</p><p>换到<font color="red">jenkins&#x2F;jenkins</font>就好了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>后来发现之前写的文章，发现用的就是这个<font color="red">jenkins&#x2F;jenkins</font>镜像，词镜像里的插件比较全，就没遇到类似问题。</p><h2 id="文章链接："><a href="#文章链接：" class="headerlink" title="文章链接："></a>文章链接：</h2><blockquote><p><a href="https://www.cnblogs.com/young233/p/14815787.html">docker 安装jenkins - eryoung2 - 博客园</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天又试着装了一下docker版的jenkins，今天用了&lt;font color=&quot;red&quot;&gt;jenkins:2.60.3&lt;/font&gt;这个</summary>
      
    
    
    
    <category term="工具使用" scheme="http://eryoung2.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="jenkins" scheme="http://eryoung2.github.io/tags/jenkins/"/>
    
  </entry>
  
  <entry>
    <title>linux添加BBR加速</title>
    <link href="http://eryoung2.github.io/2022/09/16/linux%E6%B7%BB%E5%8A%A0BBR%E5%8A%A0%E9%80%9F/"/>
    <id>http://eryoung2.github.io/2022/09/16/linux%E6%B7%BB%E5%8A%A0BBR%E5%8A%A0%E9%80%9F/</id>
    <published>2022-09-15T20:15:28.000Z</published>
    <updated>2022-09-15T20:16:36.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BBR简介"><a href="#BBR简介" class="headerlink" title="BBR简介"></a>BBR简介</h2><p>TCP BBR是由来自Google的 Neal Cardwell 和 Yuchung Cheng 发表的新的TCP拥塞控制算法，目前已经在Google内部大范围使用并且随着linux 4.9版本正式发布。可大幅提升上网的访问速度。</p><h2 id="BBR添加"><a href="#BBR添加" class="headerlink" title="BBR添加"></a>BBR添加</h2><ol><li>查看内核版本，需要大于4.9</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><ol start="2"><li>开启BBR</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><ol start="3"><li>生效</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><ol start="4"><li>检查状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文只是记录BBR使用方法，至于通信原理尚在研读当中，如有进展会再出一篇文章进行讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BBR简介&quot;&gt;&lt;a href=&quot;#BBR简介&quot; class=&quot;headerlink&quot; title=&quot;BBR简介&quot;&gt;&lt;/a&gt;BBR简介&lt;/h2&gt;&lt;p&gt;TCP BBR是由来自Google的 Neal Cardwell 和 Yuchung Cheng 发表的新的TCP拥</summary>
      
    
    
    
    <category term="操作系统" scheme="http://eryoung2.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="linux" scheme="http://eryoung2.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu dpkg问题解决</title>
    <link href="http://eryoung2.github.io/2022/08/15/ubuntu-dpkg%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://eryoung2.github.io/2022/08/15/ubuntu-dpkg%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</id>
    <published>2022-08-15T06:58:36.000Z</published>
    <updated>2022-08-15T07:00:04.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>今天玩ubuntu发现以下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg was interrupted, you must manually run sudo dpkg –configure -a to correct the problem</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /var/lib/apt/lists/lock</span><br><span class="line"></span><br><span class="line">sudo rm /var/cache/apt/archives/lock</span><br><span class="line"></span><br><span class="line">cd /var/lib/dpkg/updates</span><br><span class="line"></span><br><span class="line">sudo rm *</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>或者杀掉apt进程，参考我另一篇博客。</p><p><a href="https://www.cnblogs.com/young233/p/12445729.html">ubuntu could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock 解决方法 - eryoung2 - 博客园</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;今天玩ubuntu发现以下报错：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="错误排查" scheme="http://eryoung2.github.io/categories/%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="ubuntu" scheme="http://eryoung2.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>《郭源潮》-- 宋冬野</title>
    <link href="http://eryoung2.github.io/2022/08/10/%E3%80%8A%E9%83%AD%E6%BA%90%E6%BD%AE%E3%80%8B-%E5%AE%8B%E5%86%AC%E9%87%8E/"/>
    <id>http://eryoung2.github.io/2022/08/10/%E3%80%8A%E9%83%AD%E6%BA%90%E6%BD%AE%E3%80%8B-%E5%AE%8B%E5%86%AC%E9%87%8E/</id>
    <published>2022-08-10T13:40:23.000Z</published>
    <updated>2022-08-10T13:42:42.373Z</updated>
    
    <content type="html"><![CDATA[<p>你说你知道，他们的世界，<br>悲歌三首，买一切。<br>买昆仑落脚，蓬莱放思想，<br>买人们的争执，酿酒汤。<br>买公主坟的乌鸦，事发之木和东窗之麻，<br>买胭脂河里船行渔歌，黄金世界中万物法则。<br>你我都一样，将被遗忘，郭源潮，<br>你的病也和我的一样，风月难扯，离合不骚。<br>层楼终究误少年，自由早晚乱余生，<br>你我山前没相见，山后别相逢。</p><p>    </p><p>    </p><p>买石灰街车站的海鸥，山水禽兽和年少一梦，<br>买太平湖底陈年水墨，哥本哈根的童年传说。<br>其实你我都一样，终将被遗忘，郭源潮，<br>你的病也和我的一样，风月难扯，离合不骚。<br>层楼终究误少年，自由早晚乱余生，<br>你我山前没相见，山后别相逢。</p><p>    </p><p>    </p><p>其实你我都一样，终将被遗忘，郭源潮，<br>你的病也和我的一样，风月难扯，离合不骚。<br>层楼终究误少年，自由早晚乱余生，<br>你我山前没相见，山后别相逢。</p><p>    </p><p>你我山前没相见，山后别相逢。</p><p>    </p><p>你我山前没相见，山后别相逢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你说你知道，他们的世界，&lt;br&gt;悲歌三首，买一切。&lt;br&gt;买昆仑落脚，蓬莱放思想，&lt;br&gt;买人们的争执，酿酒汤。&lt;br&gt;买公主坟的乌鸦，事发之木和东窗之麻，&lt;br&gt;买胭脂河里船行渔歌，黄金世界中万物法则。&lt;br&gt;你我都一样，将被遗忘，郭源潮，&lt;br&gt;你的病也和我的一样，风月</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="宋冬野" scheme="http://eryoung2.github.io/tags/%E5%AE%8B%E5%86%AC%E9%87%8E/"/>
    
  </entry>
  
  <entry>
    <title>powershell执行策略</title>
    <link href="http://eryoung2.github.io/2022/08/09/powershell%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/"/>
    <id>http://eryoung2.github.io/2022/08/09/powershell%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5/</id>
    <published>2022-08-09T09:33:58.000Z</published>
    <updated>2022-08-09T12:16:10.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博文，我介绍了一下powershell和cmd的对比。通过学习，我发现powershell的确比cmd更加power，也更加适应现在的使用场景。<br>那么本文将继续介绍一个powershell的另一个特性，执行策略。</p><h2 id="execution-policy描述"><a href="#execution-policy描述" class="headerlink" title="execution policy描述"></a>execution policy描述</h2><p>首先我们看看官网是怎么描述execution policy的:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PowerShell&#x27;s execution policy is a safety feature that controls the conditions under which PowerShell loads configuration files and runs scripts. This feature helps prevent the execution of malicious scripts.</span><br><span class="line"></span><br><span class="line">On a Windows computer you can set an execution policy for the local computer, for the current user, or for a particular session. You can also use a Group Policy setting to set execution policies for computers and users.</span><br><span class="line"></span><br><span class="line">Execution policies for the local computer and current user are stored in the registry. You don&#x27;t need to set execution policies in your PowerShell profile. The execution policy for a particular session is stored only in memory and is lost when the session is closed.</span><br><span class="line"></span><br><span class="line">The execution policy isn&#x27;t a security system that restricts user actions. For example, users can easily bypass a policy by typing the script contents at the command line when they cannot run a script. Instead, the execution policy helps users to set basic rules and prevents them from violating them unintentionally.</span><br><span class="line"></span><br><span class="line">On non-Windows computers, the default execution policy is Unrestricted and cannot be changed. The Set-ExecutionPolicy cmdlet is available, but PowerShell displays a console message that it&#x27;s not supported. While Get-ExecutionPolicy returns Unrestricted on non-Windows platforms, the behavior really matches Bypass because those platforms do not implement the Windows Security Zones.</span><br></pre></td></tr></table></figure><p>我们总结一下，这段文字中提到了几个要点：</p><ol><li>powershell的执行策略是种安全特性，保证不会什么猫狗脚本都执行，对于操作系统是种保护。</li><li>windows的执行策略执行粒度分3种：本机、当前用户、特定会话。本机和当前用户的策略会存进注册表，当前会话的执行策略只会进内存，会话一断就会消失。</li><li>执行策略并不会限制用户操作，只是给了用户一把安全锁，可用可不用。</li><li>对于非windows机器，不会有执行策略的设置，因此会建议windows机器来做设置。</li></ol><h2 id="常见的执行策略"><a href="#常见的执行策略" class="headerlink" title="常见的执行策略"></a>常见的执行策略</h2><p>明白了上面的几个要点，我们来看windows提供了哪些执行策略供我们使用。</p><ol><li><p>ByPass<br>任何脚本都可以执行，且没有任何提示。</p></li><li><p>Undefined<br>没有设置脚本执行策略。</p></li><li><p>Unrestricted<br>允许运行未签名的脚本，但是会有安全性提示。</p></li><li><p>Default<br>默认策略，对客户端是Restricted，对服务端是RemoteSigned</p></li><li><p>RemoteSigned<br>Windows Server 2012 R2 之后的默认策略<br>如果从网络下载的脚本会有限制，需要添加数字签名；如果是本地创建的脚本，则不需要数字签名可以运行。</p></li></ol><p>但是问题来了，真的会有老哥从网络上下载到本地运行，而不是复制粘贴到本地，自己创建的文件里？</p><p>不会吧，不会吧？<br><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/08/09-20-15-39-buhui.jpg" alt="image"></p><ol start="6"><li><p>AllSigned<br>本策略只允许运行具有数字签名的脚本。</p></li><li><p>Restricted<br>本策略允许运行命令，但无法运行脚本。</p></li></ol><h2 id="运行范围"><a href="#运行范围" class="headerlink" title="运行范围"></a>运行范围</h2><p>上面也讲了，powershell有3种范围：本机、当前用户、当前会话。<br>可使用Scope选项进行设置。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Windows\system32&gt; <span class="built_in">Get-ExecutionPolicy</span> <span class="literal">-Scope</span> LocalMachine</span><br><span class="line">RemoteSigned</span><br><span class="line"><span class="built_in">PS</span> C:\Windows\system32&gt; <span class="built_in">Get-ExecutionPolicy</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line">Undefined</span><br><span class="line"><span class="built_in">PS</span> C:\Windows\system32&gt; <span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUserc</span><br><span class="line">执行策略更改</span><br><span class="line">执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=<span class="number">135170</span></span><br><span class="line">中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?</span><br><span class="line">[<span class="type">Y</span>] 是(Y)  [<span class="type">A</span>] 全是(A)  [<span class="type">N</span>] 否(N)  [<span class="type">L</span>] 全否(L)  [<span class="type">S</span>] 暂停(S)  [?] 帮助 (默认值为“N”): A</span><br><span class="line"><span class="built_in">PS</span> C:\Windows\system32&gt; <span class="built_in">Get-ExecutionPolicy</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line">RemoteSigned</span><br></pre></td></tr></table></figure><h2 id="cmd调用powershell"><a href="#cmd调用powershell" class="headerlink" title="cmd调用powershell"></a>cmd调用powershell</h2><p>由于powershell和cmd是不同的命令行，而且powershell有执行策略的限制，如果我们想使用cmd去运行powershell脚本，除了需要设置powershell的策略，还需要使用cmd设置ps1脚本默认的运行方式。<br>默认方式是打开&#x2F;编辑，而不是运行。</p><p>设置成运行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ftype</span> Microsoft.PowerShellScript.<span class="number">1</span>=&quot;<span class="variable">%SystemRoot%</span>\system32\WindowsPowerShell\v1.<span class="number">0</span>\powershell.exe&quot; &quot;%<span class="number">1</span>&quot;</span><br></pre></td></tr></table></figure><p>设置成编辑：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ftype</span> Microsoft.PowerShellScript.<span class="number">1</span>=&quot;<span class="variable">%SystemRoot%</span>\system32\notepad.exe&quot; &quot;%<span class="number">1</span>&quot;</span><br></pre></td></tr></table></figure><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_execution_policies?view=powershell-7.2">微软powershell官方文档</a><br><a href="https://www.cnblogs.com/sparkdev/p/7460518.html">powershell脚本执行策略</a><br><a href="https://www.codeleading.com/article/55285613479/">CMD命令行修改.ps1文件（powershell脚本）的默认打开方式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇博文，我介绍了一下powershell和cmd的对比。通过学习，我发现powershell的确比cmd更加power，也更加适应现在的</summary>
      
    
    
    
    <category term="windows" scheme="http://eryoung2.github.io/categories/windows/"/>
    
    
    <category term="powershell" scheme="http://eryoung2.github.io/tags/powershell/"/>
    
  </entry>
  
  <entry>
    <title>powershell和cmd比较</title>
    <link href="http://eryoung2.github.io/2022/08/04/powershell%E5%92%8Ccmd%E6%AF%94%E8%BE%83/"/>
    <id>http://eryoung2.github.io/2022/08/04/powershell%E5%92%8Ccmd%E6%AF%94%E8%BE%83/</id>
    <published>2022-08-04T09:33:58.000Z</published>
    <updated>2022-08-09T12:07:17.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>计算机啊这东西，本质上是硬件和软件的综合体。如果只有硬件没有软件的话，这也是台辣鸡而已。而计算机软件中最靠近硬件的一层，就是操作系统层。</p><p>操作系统有很多种，比如Unix&#x2F;Linux&#x2F;Mac OS&#x2F;Windows几种。其中，我们接触的第一款操作系统应该就是微软(巨硬)公司的windows系列了。这款操作系统从1985年发表第一款操作系统Windows1.0开始，到现在已经有将近40年的历史了。所以Windows内部也一定存在很多祖传的应用，比如Windows NT、扫雷、cmd等。</p><p>虽然Windows是一款以视窗为主要交互模式的操作系统，但是对于一个脚本佬，命令行同样重要。甚至有时命令行的交互效率比视窗的点点点更高，也更快捷方便(就比如我刚开始使用linux的shell的时候，对此非常抗拒，觉得十分难用；但是用久了就回不去了，现在整天骂Windows，为啥设计得如此不透明)。</p><p>当然啦，脚本佬毕竟是少数，大部分人还是觉得Windows的点点点更加符合自己的使用习惯。然而作为一个脚本佬，就没办法再搁那儿点点点了，这样难免被人说lowbi。于是我简单地看了一下Windows的命令行，发现有两种–黑框的cmd和篮框的powershell。那本文主要讨论这二者的异同。</p><p>    </p><h2 id="cmd-vs-powershell"><a href="#cmd-vs-powershell" class="headerlink" title="cmd vs powershell"></a>cmd vs powershell</h2><p>我呢，是个土包子，看到这二者的第一感觉就是，powershell是加强版的cmd。这句话说了等于没说，因为的确如此。如果这个问题是个面试题，你要这么答，很难保证面试官不会继续问下去，“请详细讲讲，这二者有啥异同”？这时候就喝喝了，你就没话可讲了，最后就得被迫回家等消息。那我们这里不废话，直接上表格：</p><table><thead><tr><th></th><th>cmd</th><th>powershell</th></tr></thead><tbody><tr><td>框框颜色</td><td>黑色</td><td>蓝色</td></tr><tr><td>起用时间</td><td>1981年</td><td>2006年</td></tr><tr><td>适用性</td><td>仅支持cmd脚本(bat,cmd)</td><td>支持cmd脚本(bat,cmd)和powershell脚本(ps1)</td></tr><tr><td>扩展性</td><td>仅支持cmd内置函数</td><td>支持cmd内置函数+powershell cmdlet</td></tr><tr><td>命令别名</td><td>不支持</td><td>支持</td></tr><tr><td>输出内容类型</td><td>文本</td><td>对象</td></tr><tr><td>程序并发</td><td>不支持</td><td>支持</td></tr><tr><td>是否有ISE(编译器)</td><td>无，只有命令行</td><td>有，而且能直接调试</td></tr><tr><td>是否支持.net库</td><td>否</td><td>是</td></tr><tr><td>是否支持WMI（监控工具）</td><td>否</td><td>是</td></tr><tr><td>是否可以管理微软云资源</td><td>否</td><td>是</td></tr><tr><td>是否支持shell</td><td>否</td><td>是</td></tr><tr><td>是否可以运行所有类型程序</td><td>否</td><td>是</td></tr></tbody></table><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面我总结了powershell和cmd的异同点，可以从中看到powershell是cmd的加强版，但是加强得过了头，基本上也可以作为Windows不同世代，实现命令行交互的两种方式了。其中cmd能做的事情powershell都能做，而powershell除了兼容cmd以外，也增加了几项对脚本佬更加友善的改进：</p><ol><li><p>增加了cmdlet，使得很多功能可以像成熟的编程语言一样直接调用。</p></li><li><p>拉进了与linux shell的操作距离，使得学习成本大大降低。</p></li><li><p>支持了很多更友善的功能，比如ISE和WMI，操作感比cmd更先进。</p></li><li><p>增加了操作其他语言的便捷性，使得powershell通用性更好。</p></li><li><p>增加了管理其余基础资源的功能，使得我们使用vagrant或者terraform时更方便。</p></li><li><p>由于powershell本身建立在.net框架之上，所以直接可以调用,net相关功能，对于.net开发者是一种福音。</p></li></ol><p>总之，它给了常年使用linux命令行方式进行作业的人(比如我这脚本佬)更好的信心去使用windows进行编程和测试，其强大的功能也令我叹为观止。只能说I need more 抛瓦烧，微软巨硬，魔兽该出新资料片啦！</p><p>    </p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://www.educba.com/powershell-vs-command-prompt/">PowerShell vs Command Prompt | Top 14 Differences You Should Know</a></p><p><a href="https://www.yiibai.com/powershell/powershell-cmdlet.html">https://www.yiibai.com/powershell/powershell-cmdlet.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/380068863">https://zhuanlan.zhihu.com/p/380068863</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;计算机啊这东西，本质上是硬件和软件的综合体。如果只有硬件没有软件的话，这也是台辣鸡而已。而计算机软件中最靠近硬件的一层，就是操作系统层。&lt;/</summary>
      
    
    
    
    <category term="windows" scheme="http://eryoung2.github.io/categories/windows/"/>
    
    
    <category term="powershell" scheme="http://eryoung2.github.io/tags/powershell/"/>
    
    <category term="cmd" scheme="http://eryoung2.github.io/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>podman网络缺失</title>
    <link href="http://eryoung2.github.io/2022/07/30/podman%E7%BD%91%E7%BB%9C%E7%BC%BA%E5%A4%B1/"/>
    <id>http://eryoung2.github.io/2022/07/30/podman%E7%BD%91%E7%BB%9C%E7%BC%BA%E5%A4%B1/</id>
    <published>2022-07-29T19:37:47.000Z</published>
    <updated>2022-07-29T19:38:44.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>podman由于没有daemon，使用的时候会出现network问题。</p><p>今天打算跑一个busybox时，发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@home:~/manifests# podman run -it busybox</span><br><span class="line">ERRO[0000] error loading cached network config: network &quot;podman&quot; not found in CNI cache</span><br><span class="line">WARN[0000] falling back to loading from existing plugins on disk</span><br><span class="line">ERRO[0000] Error tearing down partially created network namespace for container 25909b12b14aa8a8d1c1934e6e58b5cb55ca0e4e9af45fdff359620f3bc290ce: CNI network &quot;podman&quot; not found</span><br><span class="line">Error: error configuring network namespace for container 25909b12b14aa8a8d1c1934e6e58b5cb55ca0e4e9af45fdff359620f3bc290ce: CNI network &quot;podman&quot; not found</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>没有podman所支持的网络环境。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以跑以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@home:~/manifests# podman network create podman</span><br><span class="line">/etc/cni/net.d/podman.conflist</span><br></pre></td></tr></table></figure><p>然后问题解决，就可以启动容器了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@home:~/manifests# podman run -it busybox</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://github.com/containers/podman/issues/12651">Running podman with sudo returns <code>error loading cached network config: network &amp;quot;podman&amp;quot; not found in CNI cache</code> · Issue #12651 · containers&#x2F;podman · GitHub</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;podman由于没有daemon，使用的时候会出现network问题。&lt;/p&gt;
&lt;p&gt;今天打算跑一个busybox时，发现报错：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="容器" scheme="http://eryoung2.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="podman" scheme="http://eryoung2.github.io/tags/podman/"/>
    
  </entry>
  
  <entry>
    <title>git fetch和git pull对比</title>
    <link href="http://eryoung2.github.io/2022/07/26/git-fetch%E5%92%8Cgit-pull%E5%AF%B9%E6%AF%94/"/>
    <id>http://eryoung2.github.io/2022/07/26/git-fetch%E5%92%8Cgit-pull%E5%AF%B9%E6%AF%94/</id>
    <published>2022-07-26T10:45:20.000Z</published>
    <updated>2022-07-26T11:22:19.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h2><p>你：面试官您好，我是xxx，毕业于xxx学校，工作xxx年，精通各种git命令。</p><p>面试官：您好您好，我问个常见的问题考察一下您的技术水平哈。请问，git pull和git fetch有什么区别，二者都在什么情况下使用？</p><p>你：emmmm…母鸡喔</p><p>面试官（微笑）：回家等消息吧，有结果通知你~</p><h2 id="二者区分"><a href="#二者区分" class="headerlink" title="二者区分"></a>二者区分</h2><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>首先我们来看一下git fetch的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch only downloads latest changes into the local repository. </span><br><span class="line">It downloads fresh changes that other developers have pushed to </span><br><span class="line">the remote repository since the late fetch and allows you to review </span><br><span class="line">and merge manually at a later time using git merge. </span><br><span class="line">Because it doesn&#x27;t change your working directory or the staging area, </span><br><span class="line">it is entirely safe, and you can run it as often as you want.</span><br></pre></td></tr></table></figure><p>我们提取几个关键信息：</p><ol><li><p>git fetch提取远端的最新改变到本地</p></li><li><p>git fetch不强行改变本地状态和预存区</p></li><li><p>可使用git merge手动合并</p></li><li><p>git fetch很安全</p></li></ol><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>我们再看一下git pull的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git pull downloads latest changes into the local repository </span><br><span class="line">and it also automatically merges change in your working directory. </span><br><span class="line">It doesn&#x27;t give you a chance to review the changes before merging, </span><br><span class="line">and as a consequence, &#x27;merge conflicts&#x27; can and do occur. One important thing</span><br><span class="line">to keep in mind is that it will merge only into the current working branch.</span><br><span class="line">Other branches will stay unaffected.</span><br></pre></td></tr></table></figure><p>我们再提取几个关键信息：</p><ol><li><p>git pull直接将改动同步到本地工作区</p></li><li><p>git pull没机会做merge操作</p></li><li><p>git pull可能出现merge冲突</p></li><li><p>最好在同分支之间使用git pull，否则会出错误</p></li></ol><p>总之：<font color="red">git pull &#x3D; git fetch + git merge</font></p><h2 id="二者在git中的位置"><a href="#二者在git中的位置" class="headerlink" title="二者在git中的位置"></a>二者在git中的位置</h2><p><img src="https://raw.githubusercontent.com/ErYoung2/imgbed/master/2022/07/26-18-47-43-git%20fetch%20vs%20git%20pull.png" alt="image"></p><h2 id="git-fetch使用"><a href="#git-fetch使用" class="headerlink" title="git fetch使用"></a>git fetch使用</h2><ol><li>获取远端分支的最新内容到FETCH_HEAD，并查看。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git <span class="built_in">log</span> -p FETCH_HEAD</span><br></pre></td></tr></table></figure><ol start="2"><li>如果可以合并，就合并内容到本地</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>这里解释一下这个FETCH_HEAD, 它是一个版本链接，记录在本地一个文件中(.git&#x2F;FETCH_HEAD)，指向当前分支最新版本。</p><h2 id="git-pull使用"><a href="#git-pull使用" class="headerlink" title="git pull使用"></a>git pull使用</h2><p>git pull的使用相当于上面两步的和，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此题不难，但答不上来的侮辱性极强。</p><p>本题主要考察的是git的基础知识，多看一些博客或者文章就可以搞定。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://www.youtube.com/watch?v=ip1UxTswbo8&ab_channel=KKJavaTutorials">git fetch vs git pull</a></p><p><a href="https://git-scm.com/docs/git-fetch">git官网</a></p><p><a href="https://juejin.cn/post/6844903921794859021">git fetch &amp; pull详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;情景重现&quot;&gt;&lt;a href=&quot;#情景重现&quot; class=&quot;headerlink&quot; title=&quot;情景重现&quot;&gt;&lt;/a&gt;情景重现&lt;/h2&gt;&lt;p&gt;你：面试官您好，我是xxx，毕业于xxx学校，工作xxx年，精通各种git命令。&lt;/p&gt;
&lt;p&gt;面试官：您好您好，我问个常见</summary>
      
    
    
    
    <category term="工具使用" scheme="http://eryoung2.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="git" scheme="http://eryoung2.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>《高山低谷》-- 林奕匡</title>
    <link href="http://eryoung2.github.io/2022/07/23/%E9%AB%98%E5%B1%B1%E4%BD%8E%E8%B0%B7-%E6%9E%97%E5%A5%95%E5%8C%A1/"/>
    <id>http://eryoung2.github.io/2022/07/23/%E9%AB%98%E5%B1%B1%E4%BD%8E%E8%B0%B7-%E6%9E%97%E5%A5%95%E5%8C%A1/</id>
    <published>2022-07-23T03:17:26.000Z</published>
    <updated>2022-08-10T13:43:58.889Z</updated>
    
    <content type="html"><![CDATA[<p>站在树林内，就如没氧气，<br>在夕阳下，寂寥吧，没权利见你。<br>早知高的山、低的谷，将你我分隔两地，失去人情味。<br>你那贵族游戏，我的街角游记，<br>天真到信真心，太儿戏。</p><p>    </p><p>你快乐过生活，我拼命去生存，<br>几多人位于山之巅俯瞰我的疲倦。<br>渴望被成全，努力做人谁怕气喘，<br>但那终点，挂在那天边。</p><p>    </p><p>你界定了生活，我侮辱了生存，<br>只适宜滞于山之谷整理我的凌乱。<br>渴望大团圆，脚下路程难以削短，<br>未见终点，也未见恩典，我与你极远。</p><p>    </p><p>越望，越无望，未来没有我，<br>在断崖下，尽头吧，乐园未有过。<br>仿佛天一黑天一光挥发了一句再会，只见人下堕。<br>快慰继续传播，你都不慰问我，<br>区分到太清楚，太严苛。</p><p>    </p><p>你快乐过生活，我拼命去生存，<br>几多人位于山之巅俯瞰我的疲倦。<br>渴望被成全，努力做人谁怕气喘，<br>但那终点，挂在那天边。</p><p>    </p><p>你界定了生活，我侮辱了生存，<br>只适宜滞于山之谷整理我的凌乱。<br>渴望大团圆，脚下路程难以削短，<br>未见终点，也未见恩典，我与你极远。</p><p>    </p><p>我却尚要生存，偷偷存活于山之谷等到某天魂断。<br>你继续盘旋，我继续埋藏我爱恋，<br>没有终点，永没有终点，那永远极远。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;站在树林内，就如没氧气，&lt;br&gt;在夕阳下，寂寥吧，没权利见你。&lt;br&gt;早知高的山、低的谷，将你我分隔两地，失去人情味。&lt;br&gt;你那贵族游戏，我的街角游记，&lt;br&gt;天真到信真心，太儿戏。&lt;/p&gt;
&lt;p&gt;    &lt;/p&gt;
&lt;p&gt;你快乐过生活，我拼命去生存，&lt;br&gt;几多人位于山之</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="林奕匡" scheme="http://eryoung2.github.io/tags/%E6%9E%97%E5%A5%95%E5%8C%A1/"/>
    
  </entry>
  
  <entry>
    <title>ruby gem timed out解决</title>
    <link href="http://eryoung2.github.io/2022/07/23/ruby-gem-timed-out%E8%A7%A3%E5%86%B3/"/>
    <id>http://eryoung2.github.io/2022/07/23/ruby-gem-timed-out%E8%A7%A3%E5%86%B3/</id>
    <published>2022-07-22T19:33:00.000Z</published>
    <updated>2022-07-22T19:34:18.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在折腾vagrant的时候，发现当我安装vagrant时，需要一些ruby插件。</p><p>如果我们没有设置正确的源，就会报time out的错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: While executing gem ... (Gem::RemoteFetcher::UnknownHostError)</span><br><span class="line">    timed out (https://api.rubygems.org/latest_specs.4.8.gz)</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>可以使用国内源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">gem sources -a https://gems.ruby-china.com/</span><br></pre></td></tr></table></figure><p>就可以了。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p><a href="https://gems.ruby-china.com/">ruby gems中文官网</a></p><p><a href="https://blog.csdn.net/Never__Give_Up_/article/details/100592393">Ruby Gem Timeout【超时】问题的解决_Joel__Li的博客-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天在折腾vagrant的时候，发现当我安装vagrant时，需要一些ruby插件。&lt;/p&gt;
&lt;p&gt;如果我们没有设置正确的源，就会报time</summary>
      
    
    
    
    <category term="环境配置" scheme="http://eryoung2.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="ruby" scheme="http://eryoung2.github.io/tags/ruby/"/>
    
  </entry>
  
  <entry>
    <title>《飘向北方》-- namewee</title>
    <link href="http://eryoung2.github.io/2022/07/20/%E9%A3%98%E5%90%91%E5%8C%97%E6%96%B9-namewee/"/>
    <id>http://eryoung2.github.io/2022/07/20/%E9%A3%98%E5%90%91%E5%8C%97%E6%96%B9-namewee/</id>
    <published>2022-07-20T07:06:30.000Z</published>
    <updated>2022-08-10T13:43:34.563Z</updated>
    
    <content type="html"><![CDATA[<p>王：</p><p>漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。</p><p>    </p><p>黄：<br>有人说他在老家欠了一堆钱，想要避避风头，<br>有人说他练就了一身武艺，却没机会展露，<br>有人失去了自我，手足无措四处漂流，<br>有人为了梦想为了三餐为养家糊口。<br>他住在燕郊区，残破的求职公寓，<br>拥挤的大楼里，堆满陌生人都来自外地，<br>他埋头写着履历，怀抱着多少憧憬，<br>往返在九三零号公路，内心盼着奇迹。<br>不听也不想，不敢回头望的遗憾，<br>扛下了梦想，要毅然决然去流浪。<br>卸下了自尊、光环，过去多风光，<br>就算再不堪、败仗，也不能投降。<br>再见了南方，眺望最美丽的家乡，<br>椰子树摇晃，梦境倒映着的幻象。<br>雾霾太猖狂，不散，都看不清前方。</p><p>    </p><p>王：<br>漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。<br>也是最后寄望，回不去的远方～Oh～</p><p>    </p><p>黄：<br>空气太脏、太浑浊，他说不喜欢，<br>车太混乱、太匆忙，他还不习惯。<br>人行道一双有一双，斜视冷漠的眼光，<br>他经常自将己灌醉，强迫融入，这大染缸。<br>走着脚步蹒跚，二锅头在摇晃，<br>失意的人啊偶尔醉倒在那胡同陋巷。<br>咀嚼爆肚涮羊，手中盛着一碗热汤，<br>用力地、温暖着，内心里的不安。<br>不听也不想，不敢回头望的遗憾，<br>扛下了梦想，要毅然决然去流浪。<br>卸下了自尊、光环，过去多风光，<br>就算再不堪、败仗，也不能投降。<br>再见了南方，眺望最美丽的家乡，<br>椰子树摇晃，梦境倒映着的幻象。<br>雾霾太猖狂，不散，都看不清前方。</p><p>    </p><p>王：<br>漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。<br>就像那尘土飘散随着风向，谁又能带领着我一起飞翔，<br>我站在天坛中央闭上眼，祈求一家人都平安。</p><p>我漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。</p><p>我漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；<br>我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。</p><p>    </p><p>合：<br>我站在天子脚下，被踩的喘不过气，<br>走在前门大街，跟人潮，总会分歧。<br>或许我根本不属于这里，早就该离去，<br>谁能给我致命的一击，请用力到彻底。<br>这里是梦想的中心，但梦想都遥不可及，<br>这里是圆梦的圣地，但却总是扑朔迷离。<br>多少人敌不过残酷的现实，从此销声匿迹，<br>多少人陷入了昏迷，剩下一具，空壳尸体。<br>Rest in Peace～</p><p>    </p><p> </p><p>王：<br>漂向北方，别再问我家乡～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;王：&lt;/p&gt;
&lt;p&gt;漂向北方，别问我家乡，高耸古老的城墙，挡不住忧伤；&lt;br&gt;我漂向北方，家人是否无恙，肩上沉重的行囊，盛满了惆怅。&lt;/p&gt;
&lt;p&gt;    &lt;/p&gt;
&lt;p&gt;黄：&lt;br&gt;有人说他在老家欠了一堆钱，想要避避风头，&lt;br&gt;有人说他练就了一身武艺，却没机会展露，&lt;b</summary>
      
    
    
    
    <category term="歌词" scheme="http://eryoung2.github.io/categories/%E6%AD%8C%E8%AF%8D/"/>
    
    
    <category term="namewee" scheme="http://eryoung2.github.io/tags/namewee/"/>
    
    <category term="王力宏" scheme="http://eryoung2.github.io/tags/%E7%8E%8B%E5%8A%9B%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm介绍</title>
    <link href="http://eryoung2.github.io/2022/07/19/kubeadm%E4%BB%8B%E7%BB%8D/"/>
    <id>http://eryoung2.github.io/2022/07/19/kubeadm%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-07-19T05:01:17.000Z</published>
    <updated>2022-07-19T07:09:11.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，k8s中有三位大哥：kubelet, kubeadm, kubectl.</p><p>其中：</p><ul><li><p>kubelet是服务，用来调用下层的container管理器，从而对底层容器进行管理。</p></li><li><p>kubectl是API，供我们调用，键入命令对k8s资源进行管理。</p></li><li><p>kubeadm是管理器，我们可以使用它进行k8s节点的管理。</p></li></ul><p>基于kubeadm，我们最常用的功能有三个：</p><ul><li><p>init：初始化k8s节点</p></li><li><p>join：将worker节点加入到k8s集群</p></li><li><p>reset：尽最大努力还原init或者join对集群的影响</p></li></ul><p>那么，接下来就对这三个功能进行介绍。</p><h2 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>运行此命令来搭建 Kubernetes 控制平面节点。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>“init” 命令执行以下阶段：</p><p>1 预加载(preflight), 检查环境。</p><p>2 生成CA证书。</p><p>3 生成kubeconfig文件，以便kubelet和kubectl连接到API服务器，并生成一个admin.conf，便于管理。</p><p>4 为 API 服务器、控制器管理器和调度器生成静态 Pod 的清单文件。</p><p>5 对控制平面节点应用标签和污点标记以便不会在它上面运行其它的工作负载。</p><p>6 生成token令牌。</p><p>7 创建configmap提供集群节点的信息与RBAC的访问规则；允许启动引导token令牌访问API；配置自动签发新的CSR请求。</p><p>8 安装插件，coredns和kube-proxy，需要安装CNI之后才可使用coredns。</p><p>按照官方说法，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">preflight                    Run pre-flight checks</span><br><span class="line">certs                        Certificate generation</span><br><span class="line">  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components</span><br><span class="line">  /apiserver                   Generate the certificate for serving the Kubernetes API</span><br><span class="line">  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet</span><br><span class="line">  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy</span><br><span class="line">  /front-proxy-client          Generate the certificate for the front proxy client</span><br><span class="line">  /etcd-ca                     Generate the self-signed CA to provision identities for etcd</span><br><span class="line">  /etcd-server                 Generate the certificate for serving etcd</span><br><span class="line">  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other</span><br><span class="line">  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd</span><br><span class="line">  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd</span><br><span class="line">  /sa                          Generate a private key for signing service account tokens along with its public key</span><br><span class="line">kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file</span><br><span class="line">  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself</span><br><span class="line">  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes</span><br><span class="line">  /controller-manager          Generate a kubeconfig file for the controller manager to use</span><br><span class="line">  /scheduler                   Generate a kubeconfig file for the scheduler to use</span><br><span class="line">kubelet-start                Write kubelet settings and (re)start the kubelet</span><br><span class="line">control-plane                Generate all static Pod manifest files necessary to establish the control plane</span><br><span class="line">  /apiserver                   Generates the kube-apiserver static Pod manifest</span><br><span class="line">  /controller-manager          Generates the kube-controller-manager static Pod manifest</span><br><span class="line">  /scheduler                   Generates the kube-scheduler static Pod manifest</span><br><span class="line">etcd                         Generate static Pod manifest file for local etcd</span><br><span class="line">  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance</span><br><span class="line">upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap</span><br><span class="line">  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap</span><br><span class="line">  /kubelet                     Upload the kubelet component config to a ConfigMap</span><br><span class="line">upload-certs                 Upload certificates to kubeadm-certs</span><br><span class="line">mark-control-plane           Mark a node as a control-plane</span><br><span class="line">bootstrap-token              Generates bootstrap tokens used to join a node to a cluster</span><br><span class="line">kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap</span><br><span class="line">  /experimental-cert-rotation  Enable kubelet client certificate rotation</span><br><span class="line">addon                        Install required addons for passing Conformance tests</span><br><span class="line">  /coredns                     Install the CoreDNS addon to a Kubernetes cluster</span><br><span class="line">  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-h --help 帮助</span><br><span class="line">--dry-run 干跑，看效果，不做改变</span><br><span class="line">--apiserver-advertise-address apiserver的ip地址，默认主节点ip</span><br><span class="line">--apiserver-bind-port apiserver监听端口，默认6443</span><br><span class="line">--node-name string 指定节点名称</span><br><span class="line">--image-repository 指定容器的仓库，默认k8s.gcr.io</span><br><span class="line">--pod-network-cidr 指定pod的CIDR，例如“10.244.0.0/16”</span><br><span class="line">--token-ttl duration 指定token的有效时间，默认24小时</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>内容很多，我谨列出几个常见的参数，具体使用可查询官方文档。</p><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-init/">kubeadm init | Kubernetes</a></p><h2 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a>kubeadm join</h2><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><p>使得worker node加入到k8s集群中。</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>kubeadm初始化集群时，我们需要建立双向信任。这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p><p>有两种主要的发现方案：</p><p>1 使用共享令牌和 API 服务器的 IP 地址(基于令牌发现)，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</span><br></pre></td></tr></table></figure><p>2 提供一个标准 kubeconfig 文件的一个子集(基于文件发现)，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --discovery-file path/to/file.conf</span><br><span class="line">kubeadm join --discovery-file https://url/file.conf</span><br></pre></td></tr></table></figure><p>kubeadm join运行的过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">preflight              Run join pre-flight checks</span><br><span class="line">control-plane-prepare  Prepare the machine for serving a control plane</span><br><span class="line">  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret</span><br><span class="line">  /certs                 Generate the certificates for the new control plane components</span><br><span class="line">  /kubeconfig            Generate the kubeconfig for the new control plane components</span><br><span class="line">  /control-plane         Generate the manifests for the new control plane components</span><br><span class="line">kubelet-start          Write kubelet settings, certificates and (re)start the kubelet</span><br><span class="line">control-plane-join     Join a machine as a control plane instance</span><br><span class="line">  /etcd                  Add a new local etcd member</span><br><span class="line">  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap (DEPRECATED)</span><br><span class="line">  /mark-control-plane    Mark a node as a control-plane</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-h --help 帮助</span><br><span class="line">--dry-run 干跑，看效果，不做改变</span><br><span class="line">--discovery-token 基于令牌的发现</span><br><span class="line">--discovery-file 基于文件的发现</span><br></pre></td></tr></table></figure><p>内容很多，我谨列出几个常见的参数，具体使用可查询官方文档。</p><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-join/">kubeadm join | Kubernetes</a></p><h2 id="kubeadm-reset"><a href="#kubeadm-reset" class="headerlink" title="kubeadm reset"></a>kubeadm reset</h2><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><p>该命令尽力还原由 kubeadm init 或 kubeadm join 所做的更改。</p><h3 id="过程-2"><a href="#过程-2" class="headerlink" title="过程"></a>过程</h3><p>过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">preflight              Run reset pre-flight checks</span><br><span class="line">update-cluster-status  Remove this node from the ClusterStatus object.</span><br><span class="line">remove-etcd-member     Remove a local etcd member.</span><br><span class="line">cleanup-node           Run cleanup node.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[reset] Reading configuration from the cluster...</span><br><span class="line">[reset] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">W0719 03:48:16.785110    4092 preflight.go:55] [reset] WARNING: Changes made to this host by &#x27;kubeadm init&#x27; or &#x27;kubeadm join&#x27; will be reverted.</span><br><span class="line">[reset] Are you sure you want to proceed? [y/N]: y</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">[reset] Stopping the kubelet service</span><br><span class="line">[reset] Unmounting mounted directories in &quot;/var/lib/kubelet&quot;</span><br><span class="line">[reset] Deleting contents of directories: [/etc/kubernetes/manifests /etc/kubernetes/pki]</span><br><span class="line">[reset] Deleting files: [/etc/kubernetes/admin.conf /etc/kubernetes/kubelet.conf /etc/kubernetes/bootstrap-kubelet.conf /etc/kubernetes/controller-manager.conf /etc/kubernetes/scheduler.conf]</span><br><span class="line">[reset] Deleting contents of stateful directories: [/var/lib/etcd /var/lib/kubelet /var/lib/dockershim /var/run/kubernetes /var/lib/cni]</span><br></pre></td></tr></table></figure><p>需要注意，它只会删除掉&#x2F;etc&#x2F;kubernetes&#x2F;下的文件，～&#x2F;.kube下的文件需要手动删除，否则重新建立k8s集群时会报错。</p><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-h --help 帮助</span><br><span class="line">--dry-run 干跑，看效果，不做改变</span><br><span class="line">-f 不询问，强制执行</span><br><span class="line">--cri-socket 指定CRI插槽，默认为/var/lib/kubelet</span><br></pre></td></tr></table></figure><p>内容很多，我谨列出几个常见的参数，具体使用可查询官方文档。</p><p>(<a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-reset/">kubeadm reset | Kubernetes</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，k8s中有三位大哥：kubelet, kubeadm, kubectl.&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="云原生" scheme="http://eryoung2.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="k8s" scheme="http://eryoung2.github.io/tags/k8s/"/>
    
  </entry>
  
</feed>
